    1                   ;       MS-BASIC START UP ROUTINE
    2                   ;       TARGET: SBCV20 EMULATION MODE
    3                   ;       ASSEMBLER: ARCPIT XZ80.EXE
    4                   ;
    5 8200              EMROM      EQU      8200H
    6 0500              EMRAM      EQU      0500H
    7 000D              CR         EQU      0DH
    8 000A              LF         EQU      0AH
    9 00FB              GETCH      EQU      251
   10 00FC              KBHIT      EQU      252
   11 00FD              PUTCH      EQU      253
   12                   ;
   13 8200                         ORG      EMROM
   14                   ;
   15                   ;       RESET VECTOR
   16 8200 C31382                  JP       SINIT
   17                   ;
   18                   ;       BUFFER -> A
   19 8203 EDEDFB       RXA:       DB       0EDH, 0EDH, GETCH ;CALLN GETCH
   20 8206 C9                      RET
   21                   ;
   22                   ;       A -> 8251
   23 8207 EDEDFD       TXA:       DB       0EDH, 0EDH, PUTCH ;CALLN PUTCH
   24 820A C9                      RET
   25                   ;
   26                   ;       CHECK RECEIVE STATUS
   27 820B EDEDFC       CHKCHR:    DB       0EDH, 0EDH, KBHIT ;CALLN KBHIT
   28 820E FE00                    CP       00H
   29 8210 C9                      RET
   30                   ;
   31 8211 EDFD         MONITR:    DB       0EDH, 0FDH  ;RETEM
   32                   ;
   33                   ;       SYSTEM INITIALIZE
   34 8213 216605       SINIT:     LD       HL,STACK
   35 8216 F9                      LD       SP,HL
   36                   ;
   37                   ;       START BASIC
   38 8217 C31A82                  JP       COLD
   39                   ;
   40                   ;======================================================
   41                   ; The updates to the original BASIC within this file ar
   42                   ;
   43                   ; You have permission to use this for NON COMMERCIAL US
   44                   ; If you wish to use it elsewhere, please include an ac
   45                   ;
   46                   ; http://searle.hostei.com/grant/index.html
   47                   ;
   48                   ; eMail: home.micros01@btinternet.com
   49                   ;
   50                   ; If the above don't work, please perform an Internet s
   51                   ; updated the web page hosting service.
   52                   ;
   53                   ;======================================================
   54                   ;
   55                   ; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
   56                   ; Scanned from source published in 80-BUS NEWS from Vol
   57                   ; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
   58                   ; Adapted for the freeware Zilog Macro Assembler 2.10 t
   59                   ; the original ROM code (checksum A934H). PA
   60                   ;
   61                   ; GENERAL EQUATES
   62                   ;
   63 0003              CTRLC      EQU      03H         ; Control "C"
   64 0007              CTRLG      EQU      07H         ; Control "G"
   65 0008              BKSP       EQU      08H         ; Back space
   66 000A              LF         EQU      0AH         ; Line feed
   67 000C              CS         EQU      0CH         ; Clear screen
   68 000D              CR         EQU      0DH         ; Carriage return
   69 000F              CTRLO      EQU      0FH         ; Control "O"
   70 0011              CTRLQ      EQU      11H         ; Control "Q"
   71 0012              CTRLR      EQU      12H         ; Control "R"
   72 0013              CTRLS      EQU      13H         ; Control "S"
   73 0015              CTRLU      EQU      15H         ; Control "U"
   74 001B              ESC        EQU      1BH         ; Escape
   75 007F              DEL        EQU      7FH         ; Delete
   76                   ;
   77                   ; BASIC WORK SPACE LOCATIONS
   78                   ;
   79 0500              WRKSPC     EQU      EMRAM       ; BASIC Work space
   80 0503              USR        EQU      WRKSPC+3H   ; "USR (x)" jump
   81 0506              OUTSUB     EQU      WRKSPC+6H   ; "OUT p,n"
   82 0507              OTPORT     EQU      WRKSPC+7H   ; Port (p)
   83 0509              DIVSUP     EQU      WRKSPC+9H   ; Division support rout
   84 050A              DIV1       EQU      WRKSPC+0AH  ; <- Values
   85 050E              DIV2       EQU      WRKSPC+0EH  ; <- to
   86 0512              DIV3       EQU      WRKSPC+12H  ; <- be
   87 0515              DIV4       EQU      WRKSPC+15H  ; <- inserted
   88 0517              SEED       EQU      WRKSPC+17H  ; Random number seed
   89 053A              LSTRND     EQU      WRKSPC+3AH  ; Last random number
   90 053E              INPSUB     EQU      WRKSPC+3EH  ; #INP (x)" Routine
   91 053F              INPORT     EQU      WRKSPC+3FH  ; PORT (x)
   92 0541              NULLS      EQU      WRKSPC+41H  ; Number of nulls
   93 0542              LWIDTH     EQU      WRKSPC+42H  ; Terminal width
   94 0543              COMMAN     EQU      WRKSPC+43H  ; Width for commas
   95 0544              NULFLG     EQU      WRKSPC+44H  ; Null after input byte
   96 0545              CTLOFG     EQU      WRKSPC+45H  ; Control "O" flag
   97 0546              LINESC     EQU      WRKSPC+46H  ; Lines counter
   98 0548              LINESN     EQU      WRKSPC+48H  ; Lines number
   99 054A              CHKSUM     EQU      WRKSPC+4AH  ; Array load/save check
  100 054C              NMIFLG     EQU      WRKSPC+4CH  ; Flag for NMI break ro
  101 054D              BRKFLG     EQU      WRKSPC+4DH  ; Break flag
  102 054E              RINPUT     EQU      WRKSPC+4EH  ; Input reflection
  103 0551              POINT      EQU      WRKSPC+51H  ; "POINT" reflection (u
  104 0554              PSET       EQU      WRKSPC+54H  ; "SET" reflection
  105 0557              RESET      EQU      WRKSPC+57H  ; "RESET" reflection
  106 055A              STRSPC     EQU      WRKSPC+5AH  ; Bottom of string spac
  107 055C              LINEAT     EQU      WRKSPC+5CH  ; Current line number
  108 055E              BASTXT     EQU      WRKSPC+5EH  ; Pointer to start of p
  109 0561              BUFFER     EQU      WRKSPC+61H  ; Input buffer
  110 0566              STACK      EQU      WRKSPC+66H  ; Initial stack
  111 05AB              CURPOS     EQU      WRKSPC+0ABH ; Character position on
  112 05AC              LCRFLG     EQU      WRKSPC+0ACH ; Locate/Create flag
  113 05AD              TYPE       EQU      WRKSPC+0ADH ; Data type flag
  114 05AE              DATFLG     EQU      WRKSPC+0AEH ; Literal statement fla
  115 05AF              LSTRAM     EQU      WRKSPC+0AFH ; Last available RAM
  116 05B1              TMSTPT     EQU      WRKSPC+0B1H ; Temporary string poin
  117 05B3              TMSTPL     EQU      WRKSPC+0B3H ; Temporary string pool
  118 05BF              TMPSTR     EQU      WRKSPC+0BFH ; Temporary string
  119 05C3              STRBOT     EQU      WRKSPC+0C3H ; Bottom of string spac
  120 05C5              CUROPR     EQU      WRKSPC+0C5H ; Current operator in E
  121 05C7              LOOPST     EQU      WRKSPC+0C7H ; First statement of lo
  122 05C9              DATLIN     EQU      WRKSPC+0C9H ; Line of current DATA 
  123 05CB              FORFLG     EQU      WRKSPC+0CBH ; "FOR" loop flag
  124 05CC              LSTBIN     EQU      WRKSPC+0CCH ; Last byte entered
  125 05CD              READFG     EQU      WRKSPC+0CDH ; Read/Input flag
  126 05CE              BRKLIN     EQU      WRKSPC+0CEH ; Line of break
  127 05D0              NXTOPR     EQU      WRKSPC+0D0H ; Next operator in EVAL
  128 05D2              ERRLIN     EQU      WRKSPC+0D2H ; Line of error
  129 05D4              CONTAD     EQU      WRKSPC+0D4H ; Where to CONTinue
  130 05D6              PROGND     EQU      WRKSPC+0D6H ; End of program
  131 05D8              VAREND     EQU      WRKSPC+0D8H ; End of variables
  132 05DA              ARREND     EQU      WRKSPC+0DAH ; End of arrays
  133 05DC              NXTDAT     EQU      WRKSPC+0DCH ; Next data item
  134 05DE              FNRGNM     EQU      WRKSPC+0DEH ; Name of FN argument
  135 05E0              FNARG      EQU      WRKSPC+0E0H ; FN argument value
  136 05E4              FPREG      EQU      WRKSPC+0E4H ; Floating point regist
  137 05E7              FPEXP      EQU      FPREG+3     ; Floating point expone
  138 05E8              SGNRES     EQU      WRKSPC+0E8H ; Sign of result
  139 05E9              PBUFF      EQU      WRKSPC+0E9H ; Number print buffer
  140 05F6              MULVAL     EQU      WRKSPC+0F6H ; Multiplier
  141 05F9              PROGST     EQU      WRKSPC+0F9H ; Start of program text
  142 065D              STLOOK     EQU      WRKSPC+15DH ; Start of memory test
  143                   ;
  144                   ; BASIC ERROR CODE VALUES
  145                   ;
  146 0000              NF         EQU      00H         ; NEXT without FOR
  147 0002              SN         EQU      02H         ; Syntax error
  148 0004              RG         EQU      04H         ; RETURN without GOSUB
  149 0006              OD         EQU      06H         ; Out of DATA
  150 0008              FC         EQU      08H         ; Function call error
  151 000A              OV         EQU      0AH         ; Overflow
  152 000C              OM         EQU      0CH         ; Out of memory
  153 000E              UL         EQU      0EH         ; Undefined line number
  154 0010              BS         EQU      10H         ; Bad subscript
  155 0012              RD         EQU      12H         ; Re-DIMensioned array
  156 0014              DZ         EQU      14H         ; Division by zero (/0)
  157 0016              ID         EQU      16H         ; Illegal direct
  158 0018              TM         EQU      18H         ; Type miss-match
  159 001A              OS         EQU      1AH         ; Out of string space
  160 001C              LS         EQU      1CH         ; String too long
  161 001E              ST         EQU      1EH         ; String formula too co
  162 0020              CN         EQU      20H         ; Can't CONTinue
  163 0022              UF         EQU      22H         ; UnDEFined FN function
  164 0024              MO         EQU      24H         ; Missing operand
  165 0026              HX         EQU      26H         ; HEX error
  166 0028              BN         EQU      28H         ; BIN error
  167                   ;
  168 821A C32082       COLD:      JP       STARTB      ; Jump for cold start
  169 821D C39582       WARM:      JP       WARMST      ; Jump for warm start
  170 8220 C32782       STARTB:    JP       CSTART      ; Jump to initialise
  171                   ;
  172 8223 EC8A                    DW       DEINT       ; Get integer -32768 to
  173 8225 6392                    DW       ABPASS      ; Return integer in AB
  174                   ;
  175 8227 210005       CSTART:    LD       HL,WRKSPC   ; Start of workspace RA
  176 822A F9                      LD       SP,HL       ; Set up a temporary st
  177 822B C38D9E                  JP       INITST      ; Go to initialise
  178                   ;
  179 822E 110585       INIT:      LD       DE,INITAB   ; Initialise workspace
  180 8231 0663                    LD       B,INITBE-INITAB+3 ; Bytes to copy
  181 8233 210005                  LD       HL,WRKSPC   ; Into workspace RAM
  182 8236 1A           COPY:      LD       A,(DE)      ; Get source
  183 8237 77                      LD       (HL),A      ; To destination
  184 8238 23                      INC      HL          ; Next destination
  185 8239 13                      INC      DE          ; Next source
  186 823A 05                      DEC      B           ; Count bytes
  187 823B C23682                  JP       NZ,COPY     ; More to move
  188 823E F9                      LD       SP,HL       ; Temporary stack
  189 823F CD0687                  CALL     CLREG       ; Clear registers and s
  190 8242 CDE28C                  CALL     PRCRLF      ; Output CRLF
  191 8245 32AA05                  LD       (BUFFER+72+1),A ; Mark end of buffe
  192 8248 32F905                  LD       (PROGST),A  ; Initialise program ar
  193 824B 215D06       MSIZE:     LD       HL,STLOOK   ; Point to start of RAM
  194 824E 23           MLOOP:     INC      HL          ; Next byte
  195 824F 7C                      LD       A,H         ; Above address FFFF ?
  196 8250 B5                      OR       L
  197 8251 CA5D82                  JP       Z,SETTOP    ; Yes - 64K RAM
  198 8254 7E                      LD       A,(HL)      ; Get contents
  199 8255 47                      LD       B,A         ; Save it
  200 8256 2F                      CPL                  ; Flip all bits
  201 8257 77                      LD       (HL),A      ; Put it back
  202 8258 BE                      CP       (HL)        ; RAM there if same
  203 8259 70                      LD       (HL),B      ; Restore old contents
  204 825A CA4E82                  JP       Z,MLOOP     ; If RAM - test next by
  205                   ;
  206 825D 2B           SETTOP:    DEC      HL          ; Back one byte
  207 825E 115C06                  LD       DE,STLOOK-1 ; See if enough RAM
  208 8261 CD9C88                  CALL     CPDEHL      ; Compare DE with HL
  209 8264 DA9E82                  JP       C,NEMEM     ; If not enough RAM
  210 8267 11CEFF                  LD       DE,0-50     ; 50 Bytes string space
  211 826A 22AF05                  LD       (LSTRAM),HL ; Save last available R
  212 826D 19                      ADD      HL,DE       ; Allocate string space
  213 826E 225A05                  LD       (STRSPC),HL ; Save string space
  214 8271 CDE186                  CALL     CLRPTR      ; Clear program area
  215 8274 2A5A05                  LD       HL,(STRSPC) ; Get end of memory
  216 8277 11EFFF                  LD       DE,0-17     ; Offset for free bytes
  217 827A 19                      ADD      HL,DE       ; Adjust HL
  218 827B 11F905                  LD       DE,PROGST   ; Start of program text
  219 827E 7D                      LD       A,L         ; Get LSB
  220 827F 93                      SUB      E           ; Adjust it
  221 8280 6F                      LD       L,A         ; Re-save
  222 8281 7C                      LD       A,H         ; Get MSB
  223 8282 9A                      SBC      A,D         ; Adjust it
  224 8283 67                      LD       H,A         ; Re-save
  225 8284 E5                      PUSH     HL          ; Save bytes free
  226 8285 21B682                  LD       HL,SIGNON   ; Sign-on message
  227 8288 CD8193                  CALL     PRS         ; Output string
  228 828B E1                      POP      HL          ; Get bytes free back
  229 828C CD269A                  CALL     PRNTHL      ; Output amount of free
  230 828F 21A782                  LD       HL,BFREE    ; " Bytes free" message
  231 8292 CD8193                  CALL     PRS         ; Output string
  232                   ;
  233 8295 316605       WARMST:    LD       SP,STACK    ; Temporary stack
  234 8298 CD0687       BRKRET:    CALL     CLREG       ; Clear registers and s
  235 829B C31F86                  JP       PRNTOK      ; Go to get command lin
  236                   ;
  237 829E 21F382       NEMEM:     LD       HL,MEMMSG   ; Memory size not enoug
  238 82A1 CD8193                  CALL     PRS         ; Print it
  239 82A4 C3A482       XXXXX:     JP       XXXXX       ; Stop
  240                   ;
  241 82A7 204279746573 BFREE:     DB       " Bytes free",CR,LF,0,0
           20667265650D 
           0A0000       
  242                   ;
  243 82B6 494E54454C38 SIGNON:    DB       "INTEL8080 BASIC Ver 4.7b",CR,LF
           303830204241 
           534943205665 
           7220342E3762 
           0D0A         
  244 82D0 436F70797269            DB       "Copyright ",40,"C",41
           676874202843 
           29           
  245 82DD 203139373820            DB       " 1978 by Microsoft",CR,LF,0,0
           6279204D6963 
           726F736F6674 
           0D0A0000     
  246                   ;
  247 82F3 4D656D6F7279 MEMMSG:    DB       "Memory size not enough",CR,LF
           2073697A6520 
           6E6F7420656E 
           6F7567680D0A 
  248 830B 546865207379            DB       "The system is stopped.",CR,LF,0,0
           7374656D2069 
           732073746F70 
           7065642E0D0A 
           0000         
  249                   ;
  250                   ; FUNCTION ADDRESS TABLE
  251                   ;
  252 8325 9B98         FNCTAB:    DW       SGN
  253 8327 5F99                    DW       INT
  254 8329 B198                    DW       ABS
  255 832B 0305                    DW       USR
  256 832D 4192                    DW       FRE
  257 832F C895                    DW       INP
  258 8331 6F92                    DW       POS
  259 8333 259B                    DW       SQR
  260 8335 049C                    DW       RND
  261 8337 4097                    DW       LOG
  262 8339 739B                    DW       EXP
  263 833B 799C                    DW       COS
  264 833D 7F9C                    DW       SIN
  265 833F E09C                    DW       TAN
  266 8341 F59C                    DW       ATN
  267 8343 1C96                    DW       PEEK
  268 8345 609D                    DW       DEEK
  269 8347 5105                    DW       POINT
  270 8349 F394                    DW       LEN
  271 834B 0B93                    DW       STR
  272 834D 8D95                    DW       VAL
  273 834F 0295                    DW       ASC
  274 8351 1395                    DW       CHR
  275 8353 829D                    DW       HEX
  276 8355 1F9E                    DW       BIN
  277 8357 2395                    DW       LEFT
  278 8359 5395                    DW       RIGHT
  279 835B 5D95                    DW       MID
  280                   ;
  281                   ; RESERVED WORD LIST
  282                   ;
  283 835D C54E44       WORDS:     DB       0C5H,"ND"
  284 8360 C64F52                  DB       0C6H,"OR"
  285 8363 CE455854                DB       0CEH,"EXT"
  286 8367 C4415441                DB       0C4H,"ATA"
  287 836B C94E505554              DB       0C9H,"NPUT"
  288 8370 C4494D                  DB       0C4H,"IM"
  289 8373 D2454144                DB       0D2H,"EAD"
  290 8377 CC4554                  DB       0CCH,"ET"
  291 837A C74F544F                DB       0C7H,"OTO"
  292 837E D2554E                  DB       0D2H,"UN"
  293 8381 C946                    DB       0C9H,"F"
  294 8383 D24553544F52            DB       0D2H,"ESTORE"
           45           
  295 838A C74F535542              DB       0C7H,"OSUB"
  296 838F D2455455524E            DB       0D2H,"ETURN"
  297 8395 D2454D                  DB       0D2H,"EM"
  298 8398 D3544F50                DB       0D3H,"TOP"
  299 839C CF5554                  DB       0CFH,"UT"
  300 839F CF4E                    DB       0CFH,"N"
  301 83A1 CE554C4C                DB       0CEH,"ULL"
  302 83A5 D7414954                DB       0D7H,"AIT"
  303 83A9 C44546                  DB       0C4H,"EF"
  304 83AC D04F4B45                DB       0D0H,"OKE"
  305 83B0 C44F4B45                DB       0C4H,"OKE"
  306 83B4 D3435245454E            DB       0D3H,"CREEN"
  307 83BA CC494E4553              DB       0CCH,"INES"
  308 83BF C34C53                  DB       0C3H,"LS"
  309 83C2 D749445448              DB       0D7H,"IDTH"
  310 83C7 CD4F4E49544F            DB       0CDH,"ONITOR"
           52           
  311 83CE D34554                  DB       0D3H,"ET"
  312 83D1 D245534554              DB       0D2H,"ESET"
  313 83D6 D052494E54              DB       0D0H,"RINT"
  314 83DB C34F4E54                DB       0C3H,"ONT"
  315 83DF CC495354                DB       0CCH,"IST"
  316 83E3 C34C454152              DB       0C3H,"LEAR"
  317 83E8 C34C4F4144              DB       0C3H,"LOAD"
  318 83ED C353415645              DB       0C3H,"SAVE"
  319 83F2 CE4557                  DB       0CEH,"EW"
  320                   ;
  321 83F5 D4414228                DB       0D4H,"AB("
  322 83F9 D44F                    DB       0D4H,"O"
  323 83FB C64E                    DB       0C6H,"N"
  324 83FD D3504328                DB       0D3H,"PC("
  325 8401 D448454E                DB       0D4H,"HEN"
  326 8405 CE4F54                  DB       0CEH,"OT"
  327 8408 D3544550                DB       0D3H,"TEP"
  328                   ;
  329 840C AB                      DB       0ABH
  330 840D AD                      DB       0ADH
  331 840E AA                      DB       0AAH
  332 840F AF                      DB       0AFH
  333 8410 DE                      DB       0DEH
  334 8411 C14E44                  DB       0C1H,"ND"
  335 8414 CF52                    DB       0CFH,"R"
  336 8416 BE                      DB       0BEH
  337 8417 BD                      DB       0BDH
  338 8418 BC                      DB       0BCH
  339                   ;
  340 8419 D3474E                  DB       0D3H,"GN"
  341 841C C94E54                  DB       0C9H,"NT"
  342 841F C14253                  DB       0C1H,"BS"
  343 8422 D55352                  DB       0D5H,"SR"
  344 8425 C65245                  DB       0C6H,"RE"
  345 8428 C94E50                  DB       0C9H,"NP"
  346 842B D04F53                  DB       0D0H,"OS"
  347 842E D35152                  DB       0D3H,"QR"
  348 8431 D24E44                  DB       0D2H,"ND"
  349 8434 CC4F47                  DB       0CCH,"OG"
  350 8437 C55850                  DB       0C5H,"XP"
  351 843A C34F53                  DB       0C3H,"OS"
  352 843D D3494E                  DB       0D3H,"IN"
  353 8440 D4414E                  DB       0D4H,"AN"
  354 8443 C1544E                  DB       0C1H,"TN"
  355 8446 D045454B                DB       0D0H,"EEK"
  356 844A C445454B                DB       0C4H,"EEK"
  357 844E D04F494E54              DB       0D0H,"OINT"
  358 8453 CC454E                  DB       0CCH,"EN"
  359 8456 D3545224                DB       0D3H,"TR$"
  360 845A D6414C                  DB       0D6H,"AL"
  361 845D C15343                  DB       0C1H,"SC"
  362 8460 C3485224                DB       0C3H,"HR$"
  363 8464 C8455824                DB       0C8H,"EX$"
  364 8468 C2494E24                DB       0C2H,"IN$"
  365 846C CC45465424              DB       0CCH,"EFT$"
  366 8471 D24947485424            DB       0D2H,"IGHT$"
  367 8477 CD494424                DB       0CDH,"ID$"
  368 847B 80                      DB       80H         ; End of list marker
  369                   ;
  370                   ; KEYWORD ADDRESS TABLE
  371                   ;
  372 847C 848A         WORDTB:    DW       PEND
  373 847E 7789                    DW       FOR
  374 8480 5C8E                    DW       NEXT
  375 8482 D18B                    DW       DATA
  376 8484 638D                    DW       INPUT
  377 8486 9990                    DW       DIM
  378 8488 928D                    DW       READ
  379 848A E88B                    DW       LET
  380 848C 8E8B                    DW       GOTO
  381 848E 718B                    DW       RUN
  382 8490 608C                    DW       IF
  383 8492 408A                    DW       RESTOR
  384 8494 7D8B                    DW       GOSUB
  385 8496 AC8B                    DW       RETURN
  386 8498 D38B                    DW       REM
  387 849A 828A                    DW       STOP
  388 849C D495                    DW       POUT
  389 849E 428C                    DW       ON
  390 84A0 C38A                    DW       NULL
  391 84A2 DA95                    DW       WAIT
  392 84A4 7792                    DW       DEF
  393 84A6 2396                    DW       POKE
  394 84A8 6B9D                    DW       DOKE
  395 84AA D38B                    DW       REM
  396 84AC 4F9D                    DW       LINES
  397 84AE 429D                    DW       CLS
  398 84B0 479D                    DW       WIDTH
  399 84B2 1182                    DW       MONITR
  400 84B4 5405                    DW       PSET
  401 84B6 5705                    DW       RESET
  402 84B8 848C                    DW       PRINT
  403 84BA B08A                    DW       CONT
  404 84BC E888                    DW       LIST
  405 84BE 2B8B                    DW       CLEAR
  406 84C0 D38B                    DW       REM
  407 84C2 D38B                    DW       REM
  408 84C4 E086                    DW       NEW
  409                   ;
  410                   ; RESERVED WORD TOKEN VALUES
  411                   ;
  412 0080              ZEND       EQU      080H        ; END
  413 0081              ZFOR       EQU      081H        ; FOR
  414 0083              ZDATA      EQU      083H        ; DATA
  415 0088              ZGOTO      EQU      088H        ; GOTO
  416 008C              ZGOSUB     EQU      08CH        ; GOSUB
  417 008E              ZREM       EQU      08EH        ; REM
  418 009E              ZPRINT     EQU      09EH        ; PRINT
  419 00A4              ZNEW       EQU      0A4H        ; NEW
  420                   ;
  421 00A5              ZTAB       EQU      0A5H        ; TAB
  422 00A6              ZTO        EQU      0A6H        ; TO
  423 00A7              ZFN        EQU      0A7H        ; FN
  424 00A8              ZSPC       EQU      0A8H        ; SPC
  425 00A9              ZTHEN      EQU      0A9H        ; THEN
  426 00AA              ZNOT       EQU      0AAH        ; NOT
  427 00AB              ZSTEP      EQU      0ABH        ; STEP
  428                   ;
  429 00AC              ZPLUS      EQU      0ACH        ; +
  430 00AD              ZMINUS     EQU      0ADH        ; -
  431 00AE              ZTIMES     EQU      0AEH        ; *
  432 00AF              ZDIV       EQU      0AFH        ; /
  433 00B2              ZOR        EQU      0B2H        ; OR
  434 00B3              ZGTR       EQU      0B3H        ; >
  435 00B4              ZEQUAL     EQU      0B4H        ; M
  436 00B5              ZLTH       EQU      0B5H        ; <
  437 00B6              ZSGN       EQU      0B6H        ; SGN
  438 00C7              ZPOINT     EQU      0C7H        ; POINT
  439 00CF              ZLEFT      EQU      0CDH +2     ; LEFT$
  440                   ;
  441                   ; ARITHMETIC PRECEDENCE TABLE
  442                   ;
  443 84C6 79           PRITAB:    DB       79H         ; Precedence value
  444 84C7 0D9A                    DW       PADD        ; FPREG = <last> + FPRE
  445                   ;
  446 84C9 79                      DB       79H         ; Precedence value
  447 84CA 4196                    DW       PSUB        ; FPREG = <last> - FPRE
  448                   ;
  449 84CC 7C                      DB       7CH         ; Precedence value
  450 84CD 7F97                    DW       MULT        ; PPREG = <last> * FPRE
  451                   ;
  452 84CF 7C                      DB       7CH         ; Precedence value
  453 84D0 E097                    DW       DIV         ; FPREG = <last> / FPRE
  454                   ;
  455 84D2 7F                      DB       7FH         ; Precedence value
  456 84D3 2E9B                    DW       POWER       ; FPREG = <last> ^ FPRE
  457                   ;
  458 84D5 50                      DB       50H         ; Precedence value
  459 84D6 F28F                    DW       PAND        ; FPREG = <last> AND FP
  460                   ;
  461 84D8 46                      DB       46H         ; Precedence value
  462 84D9 F18F                    DW       POR         ; FPREG = <last> OR FPR
  463                   ;
  464                   ; BASIC ERROR CODE LIST
  465                   ;
  466 84DB 4E46         ERRORS:    DB       "NF"        ; NEXT without FOR
  467 84DD 534E                    DB       "SN"        ; Syntax error
  468 84DF 5247                    DB       "RG"        ; RETURN without GOSUB
  469 84E1 4F44                    DB       "OD"        ; Out of DATA
  470 84E3 4643                    DB       "FC"        ; Illegal function call
  471 84E5 4F56                    DB       "OV"        ; Overflow error
  472 84E7 4F4D                    DB       "OM"        ; Out of memory
  473 84E9 554C                    DB       "UL"        ; Undefined line
  474 84EB 4253                    DB       "BS"        ; Bad subscript
  475 84ED 4444                    DB       "DD"        ; Re-DIMensioned array
  476 84EF 2F30                    DB       "/0"        ; Division by zero
  477 84F1 4944                    DB       "ID"        ; Illegal direct
  478 84F3 544D                    DB       "TM"        ; Type mis-match
  479 84F5 4F53                    DB       "OS"        ; Out of string space
  480 84F7 4C53                    DB       "LS"        ; String too long
  481 84F9 5354                    DB       "ST"        ; String formula too co
  482 84FB 434E                    DB       "CN"        ; Can't CONTinue
  483 84FD 5546                    DB       "UF"        ; Undefined FN function
  484 84FF 4D4F                    DB       "MO"        ; Missing operand
  485 8501 4858                    DB       "HX"        ; HEX error
  486 8503 424E                    DB       "BN"        ; BIN error
  487                   ;
  488                   ; INITIALISATION TABLE --------------------------------
  489                   ;
  490 8505 C39582       INITAB:    JP       WARMST      ; Warm start jump
  491 8508 C3018B                  JP       FCERR       ; "USR (X)" jump (Set t
  492 850B D300                    OUT      (0),A       ; "OUT p,n" skeleton
  493 850D C9                      RET
  494 850E D600                    SUB      0           ; Division support rout
  495 8510 6F                      LD       L,A
  496 8511 7C                      LD       A,H
  497 8512 DE00                    SBC      A,0
  498 8514 67                      LD       H,A
  499 8515 78                      LD       A,B
  500 8516 DE00                    SBC      A,0
  501 8518 47                      LD       B,A
  502 8519 3E00                    LD       A,0
  503 851B C9                      RET
  504 851C 000000                  DB       0,0,0       ; Random number seed ta
  505 851F 354ACA99                DB       035H,04AH,0CAH,099H ;-2.65145E+07
  506 8523 391C7698                DB       039H,01CH,076H,098H ; 1.61291E+07
  507 8527 2295B398                DB       022H,095H,0B3H,098H ;-1.17691E+07
  508 852B 0ADD4798                DB       00AH,0DDH,047H,098H ; 1.30983E+07
  509 852F 53D19999                DB       053H,0D1H,099H,099H ;-2-01612E+07
  510 8533 0A1A9F98                DB       00AH,01AH,09FH,098H ;-1.04269E+07
  511 8537 65BCCD98                DB       065H,0BCH,0CDH,098H ;-1.34831E+07
  512 853B D6773E98                DB       0D6H,077H,03EH,098H ; 1.24825E+07
  513 853F 52C74F80                DB       052H,0C7H,04FH,080H ; Last random n
  514 8543 DB00                    IN       A,(0)       ; INP (x) skeleton
  515 8545 C9                      RET
  516 8546 01                      DB       1           ; POS (x) number (1)
  517 8547 FF                      DB       255         ; Terminal width (255 =
  518 8548 1C                      DB       28          ; Width for commas (3 c
  519 8549 00                      DB       0           ; No nulls after input 
  520 854A 00                      DB       0           ; Output enabled (^O of
  521 854B 1400                    DW       20          ; Initial lines counter
  522 854D 1400                    DW       20          ; Initial lines number
  523 854F 0000                    DW       0           ; Array load/save check
  524 8551 00                      DB       0           ; Break not by NMI
  525 8552 00                      DB       0           ; Break flag
  526 8553 C31988                  JP       TTYLIN      ; Input reflection (set
  527 8556 C30000                  JP       0000H       ; POINT reflection unus
  528 8559 C30000                  JP       0000H       ; SET reflection
  529 855C C30000                  JP       0000H       ; RESET reflection
  530 855F 5D06                    DW       STLOOK      ; Temp string space
  531 8561 FEFF                    DW       -2          ; Current line number (
  532 8563 FA05                    DW       PROGST+1    ; Start of program text
  533 8565              INITBE:
  534                   ;
  535                   ; END OF INITIALISATION TABLE -------------------------
  536                   ;
  537 8565 204572726F72 ERRMSG:    DB       " Error",0
           00           
  538 856C 20696E2000   INMSG:     DB       " in ",0
  539 8570              ZERBYT     EQU      $-1         ; A zero byte
  540 8571 4F6B0D0A0000 OKMSG:     DB       "Ok",CR,LF,0,0
  541 8577 427265616B00 BRKMSG:    DB       "Break",0
  542                   ;
  543 857D 210400       BAKSTK:    LD       HL,4        ; Look for "FOR" block 
  544 8580 39                      ADD      HL,SP       ; same index as specifi
  545 8581 7E           LOKFOR:    LD       A,(HL)      ; Get block ID
  546 8582 23                      INC      HL          ; Point to index addres
  547 8583 FE81                    CP       ZFOR        ; Is it a "FOR" token
  548 8585 C0                      RET      NZ          ; No - exit
  549 8586 4E                      LD       C,(HL)      ; BC = Address of "FOR"
  550 8587 23                      INC      HL
  551 8588 46                      LD       B,(HL)
  552 8589 23                      INC      HL          ; Point to sign of STEP
  553 858A E5                      PUSH     HL          ; Save pointer to sign
  554 858B 69                      LD       L,C         ; HL = address of "FOR"
  555 858C 60                      LD       H,B
  556 858D 7A                      LD       A,D         ; See if an index was s
  557 858E B3                      OR       E           ; DE = 0 if no index sp
  558 858F EB                      EX       DE,HL       ; Specified index into 
  559 8590 CA9785                  JP       Z,INDFND    ; Skip if no index give
  560 8593 EB                      EX       DE,HL       ; Index back into DE
  561 8594 CD9C88                  CALL     CPDEHL      ; Compare index with on
  562 8597 010D00       INDFND:    LD       BC,16-3     ; Offset to next block
  563 859A E1                      POP      HL          ; Restore pointer to si
  564 859B C8                      RET      Z           ; Return if block found
  565 859C 09                      ADD      HL,BC       ; Point to next block
  566 859D C38185                  JP       LOKFOR      ; Keep on looking
  567                   ;
  568 85A0 CDBA85       MOVUP:     CALL     ENFMEM      ; See if enough memory
  569 85A3 C5           MOVSTR:    PUSH     BC          ; Save end of source
  570 85A4 E3                      EX       (SP),HL     ; Swap source and dest"
  571 85A5 C1                      POP      BC          ; Get end of destinatio
  572 85A6 CD9C88       MOVLP:     CALL     CPDEHL      ; See if list moved
  573 85A9 7E                      LD       A,(HL)      ; Get byte
  574 85AA 02                      LD       (BC),A      ; Move it
  575 85AB C8                      RET      Z           ; Exit if all done
  576 85AC 0B                      DEC      BC          ; Next byte to move to
  577 85AD 2B                      DEC      HL          ; Next byte to move
  578 85AE C3A685                  JP       MOVLP       ; Loop until all bytes 
  579                   ;
  580 85B1 E5           CHKSTK:    PUSH     HL          ; Save code string addr
  581 85B2 2ADA05                  LD       HL,(ARREND) ; Lowest free memory
  582 85B5 0600                    LD       B,0         ; BC = Number of levels
  583 85B7 09                      ADD      HL,BC       ; 2 Bytes for each leve
  584 85B8 09                      ADD      HL,BC
  585 85B9 3E                      DB       3EH         ; Skip "PUSH HL"
  586 85BA E5           ENFMEM:    PUSH     HL          ; Save code string addr
  587 85BB 3ED0                    LD       A,0D0H      ; LOW -48; 48 Bytes min
  588 85BD 95                      SUB      L
  589 85BE 6F                      LD       L,A
  590 85BF 3EFF                    LD       A,0FFH      ; HIGH (-48); 48 Bytes 
  591 85C1 9C                      SBC      A,H
  592 85C2 DAC985                  JP       C,OMERR     ; Not enough - ?OM Erro
  593 85C5 67                      LD       H,A
  594 85C6 39                      ADD      HL,SP       ; Test if stack is over
  595 85C7 E1                      POP      HL          ; Restore code string a
  596 85C8 D8                      RET      C           ; Return if enough mmor
  597 85C9 1E0C         OMERR:     LD       E,OM        ; ?OM Error
  598 85CB C3E885                  JP       ERROR
  599                   ;
  600 85CE 2AC905       DATSNR:    LD       HL,(DATLIN) ; Get line of current D
  601 85D1 225C05                  LD       (LINEAT),HL ; Save as current line
  602 85D4 1E02         SNERR:     LD       E,SN        ; ?SN Error
  603 85D6 01                      DB       01H         ; Skip "LD E,DZ"
  604 85D7 1E14         DZERR:     LD       E,DZ        ; ?/0 Error
  605 85D9 01                      DB       01H         ; Skip "LD E,NF"
  606 85DA 1E00         NFERR:     LD       E,NF        ; ?NF Error
  607 85DC 01                      DB       01H         ; Skip "LD E,RD"
  608 85DD 1E12         DDERR:     LD       E,RD        ; ?DD Error
  609 85DF 01                      DB       01H         ; Skip "LD E,UF"
  610 85E0 1E22         UFERR:     LD       E,UF        ; ?UF Error
  611 85E2 01                      DB       01H         ; Skip "LD E,OV
  612 85E3 1E0A         OVERR:     LD       E,OV        ; ?OV Error
  613 85E5 01                      DB       01H         ; Skip "LD E,TM"
  614 85E6 1E18         TMERR:     LD       E,TM        ; ?TM Error
  615                   ;
  616 85E8 CD0687       ERROR:     CALL     CLREG       ; Clear registers and s
  617 85EB 324505                  LD       (CTLOFG),A  ; Enable output (A is 0
  618 85EE CDD58C                  CALL     STTLIN      ; Start new line
  619 85F1 21DB84                  LD       HL,ERRORS   ; Point to error codes
  620 85F4 57                      LD       D,A         ; D = 0 (A is 0)
  621 85F5 3E3F                    LD       A,'?'
  622 85F7 CDAD88                  CALL     OUTC        ; Output '?'
  623 85FA 19                      ADD      HL,DE       ; Offset to correct err
  624 85FB 7E                      LD       A,(HL)      ; First character
  625 85FC CDAD88                  CALL     OUTC        ; Output it
  626 85FF CD308A                  CALL     GETCHR      ; Get next character
  627 8602 CDAD88                  CALL     OUTC        ; Output it
  628 8605 216585                  LD       HL,ERRMSG   ; "Error" message
  629 8608 CD8193       ERRIN:     CALL     PRS         ; Output message
  630 860B 2A5C05                  LD       HL,(LINEAT) ; Get line of error
  631 860E 11FEFF                  LD       DE,-2       ; Cold start error if -
  632 8611 CD9C88                  CALL     CPDEHL      ; See if cold start err
  633 8614 CA2782                  JP       Z,CSTART    ; Cold start error - Re
  634 8617 7C                      LD       A,H         ; Was it a direct error
  635 8618 A5                      AND      L           ; Line = -1 if direct e
  636 8619 3C                      INC      A
  637 861A C41E9A                  CALL     NZ,LINEIN   ; No - output line of e
  638 861D 3E                      DB       3EH         ; Skip "POP BC"
  639 861E C1           POPNOK:    POP      BC          ; Drop address in input
  640                   ;
  641 861F AF           PRNTOK:    XOR      A           ; Output "Ok" and get c
  642 8620 324505                  LD       (CTLOFG),A  ; Enable output
  643 8623 CDD58C                  CALL     STTLIN      ; Start new line
  644 8626 217185                  LD       HL,OKMSG    ; "Ok" message
  645 8629 CD8193                  CALL     PRS         ; Output "Ok"
  646 862C 21FFFF       GETCMD:    LD       HL,-1       ; Flag direct mode
  647 862F 225C05                  LD       (LINEAT),HL ; Save as current line
  648 8632 CD1988                  CALL     GETLIN      ; Get an input line
  649 8635 DA2C86                  JP       C,GETCMD    ; Get line again if bre
  650 8638 CD308A                  CALL     GETCHR      ; Get first character
  651 863B 3C                      INC      A           ; Test if end of line
  652 863C 3D                      DEC      A           ; Without affecting Car
  653 863D CA2C86                  JP       Z,GETCMD    ; Nothing entered - Get
  654 8640 F5                      PUSH     AF          ; Save Carry status
  655 8641 CD068B                  CALL     ATOH        ; Get line number into 
  656 8644 D5                      PUSH     DE          ; Save line number
  657 8645 CD3087                  CALL     CRUNCH      ; Tokenise rest of line
  658 8648 47                      LD       B,A         ; Length of tokenised l
  659 8649 D1                      POP      DE          ; Restore line number
  660 864A F1                      POP      AF          ; Restore Carry
  661 864B D2108A                  JP       NC,EXCUTE   ; No line number - Dire
  662 864E D5                      PUSH     DE          ; Save line number
  663 864F C5                      PUSH     BC          ; Save length of tokeni
  664 8650 AF                      XOR      A
  665 8651 32CC05                  LD       (LSTBIN),A  ; Clear last byte input
  666 8654 CD308A                  CALL     GETCHR      ; Get next character
  667 8657 B7                      OR       A           ; Set flags
  668 8658 F5                      PUSH     AF          ; And save them
  669 8659 CDC086                  CALL     SRCHLN      ; Search for line numbe
  670 865C DA6586                  JP       C,LINFND    ; Jump if line found
  671 865F F1                      POP      AF          ; Get status
  672 8660 F5                      PUSH     AF          ; And re-save
  673 8661 CAA78B                  JP       Z,ULERR     ; Nothing after number 
  674 8664 B7                      OR       A           ; Clear Carry
  675 8665 C5           LINFND:    PUSH     BC          ; Save address of line 
  676 8666 D27C86                  JP       NC,INEWLN   ; Line not found - Inse
  677 8669 EB                      EX       DE,HL       ; Next line address in 
  678 866A 2AD605                  LD       HL,(PROGND) ; End of program
  679 866D 1A           SFTPRG:    LD       A,(DE)      ; Shift rest of program
  680 866E 02                      LD       (BC),A
  681 866F 03                      INC      BC          ; Next destination
  682 8670 13                      INC      DE          ; Next source
  683 8671 CD9C88                  CALL     CPDEHL      ; All done?
  684 8674 C26D86                  JP       NZ,SFTPRG   ; More to do
  685 8677 60                      LD       H,B         ; HL - New end of progr
  686 8678 69                      LD       L,C
  687 8679 22D605                  LD       (PROGND),HL ; Update end of program
  688                   ;
  689 867C D1           INEWLN:    POP      DE          ; Get address of line,
  690 867D F1                      POP      AF          ; Get status
  691 867E CAA386                  JP       Z,SETPTR    ; No text - Set up poin
  692 8681 2AD605                  LD       HL,(PROGND) ; Get end of program
  693 8684 E3                      EX       (SP),HL     ; Get length of input l
  694 8685 C1                      POP      BC          ; End of program to BC
  695 8686 09                      ADD      HL,BC       ; Find new end
  696 8687 E5                      PUSH     HL          ; Save new end
  697 8688 CDA085                  CALL     MOVUP       ; Make space for line
  698 868B E1                      POP      HL          ; Restore new end
  699 868C 22D605                  LD       (PROGND),HL ; Update end of program
  700 868F EB                      EX       DE,HL       ; Get line to move up i
  701 8690 74                      LD       (HL),H      ; Save MSB
  702 8691 D1                      POP      DE          ; Get new line number
  703 8692 23                      INC      HL          ; Skip pointer
  704 8693 23                      INC      HL
  705 8694 73                      LD       (HL),E      ; Save LSB of line numb
  706 8695 23                      INC      HL
  707 8696 72                      LD       (HL),D      ; Save MSB of line numb
  708 8697 23                      INC      HL          ; To first byte in line
  709 8698 116105                  LD       DE,BUFFER   ; Copy buffer to progra
  710 869B 1A           MOVBUF:    LD       A,(DE)      ; Get source
  711 869C 77                      LD       (HL),A      ; Save destinations
  712 869D 23                      INC      HL          ; Next source
  713 869E 13                      INC      DE          ; Next destination
  714 869F B7                      OR       A           ; Done?
  715 86A0 C29B86                  JP       NZ,MOVBUF   ; No - Repeat
  716 86A3 CDEC86       SETPTR:    CALL     RUNFST      ; Set line pointers
  717 86A6 23                      INC      HL          ; To LSB of pointer
  718 86A7 EB                      EX       DE,HL       ; Address to DE
  719 86A8 62           PTRLP:     LD       H,D         ; Address to HL
  720 86A9 6B                      LD       L,E
  721 86AA 7E                      LD       A,(HL)      ; Get LSB of pointer
  722 86AB 23                      INC      HL          ; To MSB of pointer
  723 86AC B6                      OR       (HL)        ; Compare with MSB poin
  724 86AD CA2C86                  JP       Z,GETCMD    ; Get command line if e
  725 86B0 23                      INC      HL          ; To LSB of line number
  726 86B1 23                      INC      HL          ; Skip line number
  727 86B2 23                      INC      HL          ; Point to first byte i
  728 86B3 AF                      XOR      A           ; Looking for 00 byte
  729 86B4 BE           FNDEND:    CP       (HL)        ; Found end of line?
  730 86B5 23                      INC      HL          ; Move to next byte
  731 86B6 C2B486                  JP       NZ,FNDEND   ; No - Keep looking
  732 86B9 EB                      EX       DE,HL       ; Next line address to 
  733 86BA 73                      LD       (HL),E      ; Save LSB of pointer
  734 86BB 23                      INC      HL
  735 86BC 72                      LD       (HL),D      ; Save MSB of pointer
  736 86BD C3A886                  JP       PTRLP       ; Do next line
  737                   ;
  738 86C0 2A5E05       SRCHLN:    LD       HL,(BASTXT) ; Start of program text
  739 86C3 44           SRCHLP:    LD       B,H         ; BC = Address to look 
  740 86C4 4D                      LD       C,L
  741 86C5 7E                      LD       A,(HL)      ; Get address of next l
  742 86C6 23                      INC      HL
  743 86C7 B6                      OR       (HL)        ; End of program found?
  744 86C8 2B                      DEC      HL
  745 86C9 C8                      RET      Z           ; Yes - Line not found
  746 86CA 23                      INC      HL
  747 86CB 23                      INC      HL
  748 86CC 7E                      LD       A,(HL)      ; Get LSB of line numbe
  749 86CD 23                      INC      HL
  750 86CE 66                      LD       H,(HL)      ; Get MSB of line numbe
  751 86CF 6F                      LD       L,A
  752 86D0 CD9C88                  CALL     CPDEHL      ; Compare with line in 
  753 86D3 60                      LD       H,B         ; HL = Start of this li
  754 86D4 69                      LD       L,C
  755 86D5 7E                      LD       A,(HL)      ; Get LSB of next line 
  756 86D6 23                      INC      HL
  757 86D7 66                      LD       H,(HL)      ; Get MSB of next line 
  758 86D8 6F                      LD       L,A         ; Next line to HL
  759 86D9 3F                      CCF
  760 86DA C8                      RET      Z           ; Lines found - Exit
  761 86DB 3F                      CCF
  762 86DC D0                      RET      NC          ; Line not found,at lin
  763 86DD C3C386                  JP       SRCHLP      ; Keep looking
  764                   ;
  765 86E0 C0           NEW:       RET      NZ          ; Return if any more on
  766 86E1 2A5E05       CLRPTR:    LD       HL,(BASTXT) ; Point to start of pro
  767 86E4 AF                      XOR      A           ; Set program area to e
  768 86E5 77                      LD       (HL),A      ; Save LSB = 00
  769 86E6 23                      INC      HL
  770 86E7 77                      LD       (HL),A      ; Save MSB = 00
  771 86E8 23                      INC      HL
  772 86E9 22D605                  LD       (PROGND),HL ; Set program end
  773                   ;
  774 86EC 2A5E05       RUNFST:    LD       HL,(BASTXT) ; Clear all variables
  775 86EF 2B                      DEC      HL
  776                   ;
  777 86F0 22CE05       INTVAR:    LD       (BRKLIN),HL ; Initialise RUN variab
  778 86F3 2AAF05                  LD       HL,(LSTRAM) ; Get end of RAM
  779 86F6 22C305                  LD       (STRBOT),HL ; Clear string space
  780 86F9 AF                      XOR      A
  781 86FA CD408A                  CALL     RESTOR      ; Reset DATA pointers
  782 86FD 2AD605                  LD       HL,(PROGND) ; Get end of program
  783 8700 22D805                  LD       (VAREND),HL ; Clear variables
  784 8703 22DA05                  LD       (ARREND),HL ; Clear arrays
  785                   ;
  786 8706 C1           CLREG:     POP      BC          ; Save return address
  787 8707 2A5A05                  LD       HL,(STRSPC) ; Get end of working RA
  788 870A F9                      LD       SP,HL       ; Set stack
  789 870B 21B305                  LD       HL,TMSTPL   ; Temporary string pool
  790 870E 22B105                  LD       (TMSTPT),HL ; Reset temporary strin
  791 8711 AF                      XOR      A           ; A = 00
  792 8712 6F                      LD       L,A         ; HL = 0000
  793 8713 67                      LD       H,A
  794 8714 22D405                  LD       (CONTAD),HL ; No CONTinue
  795 8717 32CB05                  LD       (FORFLG),A  ; Clear FOR flag
  796 871A 22DE05                  LD       (FNRGNM),HL ; Clear FN argument
  797 871D E5                      PUSH     HL          ; HL = 0000
  798 871E C5                      PUSH     BC          ; Put back return
  799 871F 2ACE05       DOAGN:     LD       HL,(BRKLIN) ; Get address of code t
  800 8722 C9                      RET                  ; Return to execution d
  801                   ;
  802 8723 3E3F         PROMPT:    LD       A,'?'       ; '?'
  803 8725 CDAD88                  CALL     OUTC        ; Output character
  804 8728 3E20                    LD       A,' '       ; Space
  805 872A CDAD88                  CALL     OUTC        ; Output character
  806 872D C34E05                  JP       RINPUT      ; Get input line
  807                   ;
  808 8730 AF           CRUNCH:    XOR      A           ; Tokenise line @ HL to
  809 8731 32AE05                  LD       (DATFLG),A  ; Reset literal flag
  810 8734 0E05                    LD       C,2+3       ; 2 byte number and 3 n
  811 8736 116105                  LD       DE,BUFFER   ; Start of input buffer
  812 8739 7E           CRNCLP:    LD       A,(HL)      ; Get byte
  813 873A FE20                    CP       ' '         ; Is it a space?
  814 873C CAB887                  JP       Z,MOVDIR    ; Yes - Copy direct
  815 873F 47                      LD       B,A         ; Save character
  816 8740 FE22                    CP       '"'         ; Is it a quote?
  817 8742 CAD887                  JP       Z,CPYLIT    ; Yes - Copy literal st
  818 8745 B7                      OR       A           ; Is it end of buffer?
  819 8746 CADF87                  JP       Z,ENDBUF    ; Yes - End buffer
  820 8749 3AAE05                  LD       A,(DATFLG)  ; Get data type
  821 874C B7                      OR       A           ; Literal?
  822 874D 7E                      LD       A,(HL)      ; Get byte to copy
  823 874E C2B887                  JP       NZ,MOVDIR   ; Literal - Copy direct
  824 8751 FE3F                    CP       '?'         ; Is it '?' short for P
  825 8753 3E9E                    LD       A,ZPRINT    ; "PRINT" token
  826 8755 CAB887                  JP       Z,MOVDIR    ; Yes - replace it
  827 8758 7E                      LD       A,(HL)      ; Get byte again
  828 8759 FE30                    CP       '0'         ; Is it less than '0'
  829 875B DA6387                  JP       C,FNDWRD    ; Yes - Look for reserv
  830 875E FE3C                    CP       60          ; ";"+1; Is it "0123456
  831 8760 DAB887                  JP       C,MOVDIR    ; Yes - copy it direct
  832 8763 D5           FNDWRD:    PUSH     DE          ; Look for reserved wor
  833 8764 115C83                  LD       DE,WORDS-1  ; Point to table
  834 8767 C5                      PUSH     BC          ; Save count
  835 8768 01B487                  LD       BC,RETNAD   ; Where to return to
  836 876B C5                      PUSH     BC          ; Save return address
  837 876C 067F                    LD       B,ZEND-1    ; First token value -1
  838 876E 7E                      LD       A,(HL)      ; Get byte
  839 876F FE61                    CP       'a'         ; Less than 'a' ?
  840 8771 DA7C87                  JP       C,SEARCH    ; Yes - search for word
  841 8774 FE7B                    CP       'z'+1       ; Greater than 'z' ?
  842 8776 D27C87                  JP       NC,SEARCH   ; Yes - search for word
  843 8779 E65F                    AND      01011111B   ; Force upper case
  844 877B 77                      LD       (HL),A      ; Replace byte
  845 877C 4E           SEARCH:    LD       C,(HL)      ; Search for a word
  846 877D EB                      EX       DE,HL
  847 877E 23           GETNXT:    INC      HL          ; Get next reserved wor
  848 877F B6                      OR       (HL)        ; Start of word?
  849 8780 F27E87                  JP       P,GETNXT    ; No - move on
  850 8783 04                      INC      B           ; Increment token value
  851 8784 7E                      LD       A, (HL)     ; Get byte from table
  852 8785 E67F                    AND      01111111B   ; Strip bit 7
  853 8787 C8                      RET      Z           ; Return if end of list
  854 8788 B9                      CP       C           ; Same character as in 
  855 8789 C27E87                  JP       NZ,GETNXT   ; No - get next word
  856 878C EB                      EX       DE,HL
  857 878D E5                      PUSH     HL          ; Save start of word
  858                   ;
  859 878E 13           NXTBYT:    INC      DE          ; Look through rest of 
  860 878F 1A                      LD       A,(DE)      ; Get byte from table
  861 8790 B7                      OR       A           ; End of word ?
  862 8791 FAB087                  JP       M,MATCH     ; Yes - Match found
  863 8794 4F                      LD       C,A         ; Save it
  864 8795 78                      LD       A,B         ; Get token value
  865 8796 FE88                    CP       ZGOTO       ; Is it "GOTO" token ?
  866 8798 C29F87                  JP       NZ,NOSPC    ; No - Don't allow spac
  867 879B CD308A                  CALL     GETCHR      ; Get next character
  868 879E 2B                      DEC      HL          ; Cancel increment from
  869 879F 23           NOSPC:     INC      HL          ; Next byte
  870 87A0 7E                      LD       A,(HL)      ; Get byte
  871 87A1 FE61                    CP       'a'         ; Less than 'a' ?
  872 87A3 DAA887                  JP       C,NOCHNG    ; Yes - don't change
  873 87A6 E65F                    AND      01011111B   ; Make upper case
  874 87A8 B9           NOCHNG:    CP       C           ; Same as in buffer ?
  875 87A9 CA8E87                  JP       Z,NXTBYT    ; Yes - keep testing
  876 87AC E1                      POP      HL          ; Get back start of wor
  877 87AD C37C87                  JP       SEARCH      ; Look at next word
  878                   ;
  879 87B0 48           MATCH:     LD       C,B         ; Word found - Save tok
  880 87B1 F1                      POP      AF          ; Throw away return
  881 87B2 EB                      EX       DE,HL
  882 87B3 C9                      RET                  ; Return to "RETNAD"
  883 87B4 EB           RETNAD:    EX       DE,HL       ; Get address in string
  884 87B5 79                      LD       A,C         ; Get token value
  885 87B6 C1                      POP      BC          ; Restore buffer length
  886 87B7 D1                      POP      DE          ; Get destination addre
  887 87B8 23           MOVDIR:    INC      HL          ; Next source in buffer
  888 87B9 12                      LD       (DE),A      ; Put byte in buffer
  889 87BA 13                      INC      DE          ; Move up buffer
  890 87BB 0C                      INC      C           ; Increment length of b
  891 87BC D63A                    SUB      ':'         ; End of statement?
  892 87BE CAC687                  JP       Z,SETLIT    ; Jump if multi-stateme
  893 87C1 FE49                    CP       ZDATA-3AH   ; Is it DATA statement 
  894 87C3 C2C987                  JP       NZ,TSTREM   ; No - see if REM
  895 87C6 32AE05       SETLIT:    LD       (DATFLG),A  ; Set literal flag
  896 87C9 D654         TSTREM:    SUB      ZREM-3AH    ; Is it REM?
  897 87CB C23987                  JP       NZ,CRNCLP   ; No - Leave flag
  898 87CE 47                      LD       B,A         ; Copy rest of buffer
  899 87CF 7E           NXTCHR:    LD       A,(HL)      ; Get byte
  900 87D0 B7                      OR       A           ; End of line ?
  901 87D1 CADF87                  JP       Z,ENDBUF    ; Yes - Terminate buffe
  902 87D4 B8                      CP       B           ; End of statement ?
  903 87D5 CAB887                  JP       Z,MOVDIR    ; Yes - Get next one
  904 87D8 23           CPYLIT:    INC      HL          ; Move up source string
  905 87D9 12                      LD       (DE),A      ; Save in destination
  906 87DA 0C                      INC      C           ; Increment length
  907 87DB 13                      INC      DE          ; Move up destination
  908 87DC C3CF87                  JP       NXTCHR      ; Repeat
  909                   ;
  910 87DF 216005       ENDBUF:    LD       HL,BUFFER-1 ; Point to start of buf
  911 87E2 12                      LD       (DE),A      ; Mark end of buffer (A
  912 87E3 13                      INC      DE
  913 87E4 12                      LD       (DE),A      ; A = 00
  914 87E5 13                      INC      DE
  915 87E6 12                      LD       (DE),A      ; A = 00
  916 87E7 C9                      RET
  917                   ;
  918 87E8 3A4405       DODEL:     LD       A,(NULFLG)  ; Get null flag status
  919 87EB B7                      OR       A           ; Is it zero?
  920 87EC 3E00                    LD       A,0         ; Zero A - Leave flags
  921 87EE 324405                  LD       (NULFLG),A  ; Zero null flag
  922 87F1 C2FC87                  JP       NZ,ECHDEL   ; Set - Echo it
  923 87F4 05                      DEC      B           ; Decrement length
  924 87F5 CA1988                  JP       Z,GETLIN    ; Get line again if emp
  925 87F8 CDAD88                  CALL     OUTC        ; Output null character
  926 87FB 3E                      DB       3EH         ; Skip "DEC B"
  927 87FC 05           ECHDEL:    DEC      B           ; Count bytes in buffer
  928 87FD 2B                      DEC      HL          ; Back space buffer
  929 87FE CA1088                  JP       Z,OTKLN     ; No buffer - Try again
  930 8801 7E                      LD       A,(HL)      ; Get deleted byte
  931 8802 CDAD88                  CALL     OUTC        ; Echo it
  932 8805 C32288                  JP       MORINP      ; Get more input
  933                   ;
  934 8808 05           DELCHR:    DEC      B           ; Count bytes in buffer
  935 8809 2B                      DEC      HL          ; Back space buffer
  936 880A CDAD88                  CALL     OUTC        ; Output character in A
  937 880D C22288                  JP       NZ,MORINP   ; Not end - Get more
  938 8810 CDAD88       OTKLN:     CALL     OUTC        ; Output character in A
  939 8813 CDE28C       KILIN:     CALL     PRCRLF      ; Output CRLF
  940 8816 C31988                  JP       TTYLIN      ; Get line again
  941                   ;
  942 8819              GETLIN:
  943 8819 216105       TTYLIN:    LD       HL,BUFFER   ; Get a line by charact
  944 881C 0601                    LD       B,1         ; Set buffer as empty
  945 881E AF                      XOR      A
  946 881F 324405                  LD       (NULFLG),A  ; Clear null flag
  947 8822 CDD788       MORINP:    CALL     CLOTST      ; Get character and tes
  948 8825 4F                      LD       C,A         ; Save character in C
  949 8826 FE7F                    CP       DEL         ; Delete character?
  950 8828 CAE887                  JP       Z,DODEL     ; Yes - Process it
  951 882B 3A4405                  LD       A,(NULFLG)  ; Get null flag
  952 882E B7                      OR       A           ; Test null flag status
  953 882F CA3B88                  JP       Z,PROCES    ; Reset - Process chara
  954 8832 3E00                    LD       A,0         ; Set a null
  955 8834 CDAD88                  CALL     OUTC        ; Output null
  956 8837 AF                      XOR      A           ; Clear A
  957 8838 324405                  LD       (NULFLG),A  ; Reset null flag
  958 883B 79           PROCES:    LD       A,C         ; Get character
  959 883C FE07                    CP       CTRLG       ; Bell?
  960 883E CA7F88                  JP       Z,PUTCTL    ; Yes - Save it
  961 8841 FE03                    CP       CTRLC       ; Is it control "C"?
  962 8843 CCE28C                  CALL     Z,PRCRLF    ; Yes - Output CRLF
  963 8846 37                      SCF                  ; Flag break
  964 8847 C8                      RET      Z           ; Return if control "C"
  965 8848 FE0D                    CP       CR          ; Is it enter?
  966 884A CADD8C                  JP       Z,ENDINP    ; Yes - Terminate input
  967 884D FE15                    CP       CTRLU       ; Is it control "U"?
  968 884F CA1388                  JP       Z,KILIN     ; Yes - Get another lin
  969 8852 FE40                    CP       '@'         ; Is it "kill line"?
  970 8854 CA1088                  JP       Z,OTKLN     ; Yes - Kill line
  971 8857 FE5F                    CP       '_'         ; Is it delete?
  972 8859 CA0888                  JP       Z,DELCHR    ; Yes - Delete characte
  973 885C FE08                    CP       BKSP        ; Is it backspace?
  974 885E CA0888                  JP       Z,DELCHR    ; Yes - Delete characte
  975 8861 FE12                    CP       CTRLR       ; Is it control "R"?
  976 8863 C27A88                  JP       NZ,PUTBUF   ; No - Put in buffer
  977 8866 C5                      PUSH     BC          ; Save buffer length
  978 8867 D5                      PUSH     DE          ; Save DE
  979 8868 E5                      PUSH     HL          ; Save buffer address
  980 8869 3600                    LD       (HL),0      ; Mark end of buffer
  981 886B CD9C9E                  CALL     OUTNCR      ; Output and do CRLF
  982 886E 216105                  LD       HL,BUFFER   ; Point to buffer start
  983 8871 CD8193                  CALL     PRS         ; Output buffer
  984 8874 E1                      POP      HL          ; Restore buffer addres
  985 8875 D1                      POP      DE          ; Restore DE
  986 8876 C1                      POP      BC          ; Restore buffer length
  987 8877 C32288                  JP       MORINP      ; Get another character
  988                   ;
  989 887A FE20         PUTBUF:    CP       ' '         ; Is it a control code?
  990 887C DA2288                  JP       C,MORINP    ; Yes - Ignore
  991 887F 78           PUTCTL:    LD       A,B         ; Get number of bytes i
  992 8880 FE49                    CP       72+1        ; Test for line overflo
  993 8882 3E07                    LD       A,CTRLG     ; Set a bell
  994 8884 D29488                  JP       NC,OUTNBS   ; Ring bell if buffer f
  995 8887 79                      LD       A,C         ; Get character
  996 8888 71                      LD       (HL),C      ; Save in buffer
  997 8889 32CC05                  LD       (LSTBIN),A  ; Save last input byte
  998 888C 23                      INC      HL          ; Move up buffer
  999 888D 04                      INC      B           ; Increment length
 1000 888E CDAD88       OUTIT:     CALL     OUTC        ; Output the character 
 1001 8891 C32288                  JP       MORINP      ; Get another character
 1002                   ;
 1003 8894 CDAD88       OUTNBS:    CALL     OUTC        ; Output bell and back 
 1004 8897 3E08                    LD       A,BKSP      ; Set back space
 1005 8899 C38E88                  JP       OUTIT       ; Output it and get mor
 1006                   ;
 1007 889C 7C           CPDEHL:    LD       A,H         ; Get H
 1008 889D 92                      SUB      D           ; Compare with D
 1009 889E C0                      RET      NZ          ; Different - Exit
 1010 889F 7D                      LD       A,L         ; Get L
 1011 88A0 93                      SUB      E           ; Compare with E
 1012 88A1 C9                      RET                  ; Return status
 1013                   ;
 1014 88A2 7E           CHKSYN:    LD       A,(HL)      ; Check syntax of chara
 1015 88A3 E3                      EX       (SP),HL     ; Address of test byte
 1016 88A4 BE                      CP       (HL)        ; Same as in code strin
 1017 88A5 23                      INC      HL          ; Return address
 1018 88A6 E3                      EX       (SP),HL     ; Put it back
 1019 88A7 CA308A                  JP       Z,GETCHR    ; Yes - Get next charac
 1020 88AA C3D485                  JP       SNERR       ; Different - ?SN Error
 1021                   ;
 1022 88AD F5           OUTC:      PUSH     AF          ; Save character
 1023 88AE 3A4505                  LD       A,(CTLOFG)  ; Get control "O" flag
 1024 88B1 B7                      OR       A           ; Is it set?
 1025 88B2 C2B693                  JP       NZ,POPAF    ; Yes - don't output
 1026 88B5 F1                      POP      AF          ; Restore character
 1027 88B6 C5                      PUSH     BC          ; Save buffer length
 1028 88B7 F5                      PUSH     AF          ; Save character
 1029 88B8 FE20                    CP       ' '         ; Is it a control code?
 1030 88BA DAD188                  JP       C,DINPOS    ; Yes - Don't INC POS(X
 1031 88BD 3A4205                  LD       A,(LWIDTH)  ; Get line width
 1032 88C0 47                      LD       B,A         ; To B
 1033 88C1 3AAB05                  LD       A,(CURPOS)  ; Get cursor position
 1034 88C4 04                      INC      B           ; Width 255?
 1035 88C5 CACD88                  JP       Z,INCLEN    ; Yes - No width limit
 1036 88C8 05                      DEC      B           ; Restore width
 1037 88C9 B8                      CP       B           ; At end of line?
 1038 88CA CCE28C                  CALL     Z,PRCRLF    ; Yes - output CRLF
 1039 88CD 3C           INCLEN:    INC      A           ; Move on one character
 1040 88CE 32AB05                  LD       (CURPOS),A  ; Save new position
 1041 88D1 F1           DINPOS:    POP      AF          ; Restore character
 1042 88D2 C1                      POP      BC          ; Restore buffer length
 1043 88D3 CD0782                  CALL     TXA         ; Send it
 1044 88D6 C9                      RET
 1045                   ;
 1046 88D7 CD0382       CLOTST:    CALL     RXA         ; Get input character
 1047 88DA E67F                    AND      01111111B   ; Strip bit 7
 1048 88DC FE0F                    CP       CTRLO       ; Is it control "O"?
 1049 88DE C0                      RET      NZ          ; No don't flip flag
 1050 88DF 3A4505                  LD       A,(CTLOFG)  ; Get flag
 1051 88E2 2F                      CPL                  ; Flip it
 1052 88E3 324505                  LD       (CTLOFG),A  ; Put it back
 1053 88E6 AF                      XOR      A           ; Null character
 1054 88E7 C9                      RET
 1055                   ;
 1056 88E8 CD068B       LIST:      CALL     ATOH        ; ASCII number to DE
 1057 88EB C0                      RET      NZ          ; Return if anything ex
 1058 88EC C1                      POP      BC          ; Rubbish - Not needed
 1059 88ED CDC086                  CALL     SRCHLN      ; Search for line numbe
 1060 88F0 C5                      PUSH     BC          ; Save address of line
 1061 88F1 CD3E89                  CALL     SETLIN      ; Set up lines counter
 1062 88F4 E1           LISTLP:    POP      HL          ; Restore address of li
 1063 88F5 4E                      LD       C,(HL)      ; Get LSB of next line
 1064 88F6 23                      INC      HL
 1065 88F7 46                      LD       B,(HL)      ; Get MSB of next line
 1066 88F8 23                      INC      HL
 1067 88F9 78                      LD       A,B         ; BC = 0 (End of progra
 1068 88FA B1                      OR       C
 1069 88FB CA1F86                  JP       Z,PRNTOK    ; Yes - Go to command m
 1070 88FE CD4789                  CALL     COUNT       ; Count lines
 1071 8901 CD5B8A                  CALL     TSTBRK      ; Test for break key
 1072 8904 C5                      PUSH     BC          ; Save address of next 
 1073 8905 CDE28C                  CALL     PRCRLF      ; Output CRLF
 1074 8908 5E                      LD       E,(HL)      ; Get LSB of line numbe
 1075 8909 23                      INC      HL
 1076 890A 56                      LD       D,(HL)      ; Get MSB of line numbe
 1077 890B 23                      INC      HL
 1078 890C E5                      PUSH     HL          ; Save address of line 
 1079 890D EB                      EX       DE,HL       ; Line number to HL
 1080 890E CD269A                  CALL     PRNTHL      ; Output line number in
 1081 8911 3E20                    LD       A,' '       ; Space after line numb
 1082 8913 E1                      POP      HL          ; Restore start of line
 1083 8914 CDAD88       LSTLP2:    CALL     OUTC        ; Output character in A
 1084 8917 7E           LSTLP3:    LD       A,(HL)      ; Get next byte in line
 1085 8918 B7                      OR       A           ; End of line?
 1086 8919 23                      INC      HL          ; To next byte in line
 1087 891A CAF488                  JP       Z,LISTLP    ; Yes - get next line
 1088 891D F21489                  JP       P,LSTLP2    ; No token - output it
 1089 8920 D67F                    SUB      ZEND-1      ; Find and output word
 1090 8922 4F                      LD       C,A         ; Token offset+1 to C
 1091 8923 115D83                  LD       DE,WORDS    ; Reserved word list
 1092 8926 1A           FNDTOK:    LD       A,(DE)      ; Get character in list
 1093 8927 13                      INC      DE          ; Move on to next
 1094 8928 B7                      OR       A           ; Is it start of word?
 1095 8929 F22689                  JP       P,FNDTOK    ; No - Keep looking for
 1096 892C 0D                      DEC      C           ; Count words
 1097 892D C22689                  JP       NZ,FNDTOK   ; Not there - keep look
 1098 8930 E67F         OUTWRD:    AND      01111111B   ; Strip bit 7
 1099 8932 CDAD88                  CALL     OUTC        ; Output first characte
 1100 8935 1A                      LD       A,(DE)      ; Get next character
 1101 8936 13                      INC      DE          ; Move on to next
 1102 8937 B7                      OR       A           ; Is it end of word?
 1103 8938 F23089                  JP       P,OUTWRD    ; No - output the rest
 1104 893B C31789                  JP       LSTLP3      ; Next byte in line
 1105                   ;
 1106 893E E5           SETLIN:    PUSH     HL          ; Set up LINES counter
 1107 893F 2A4805                  LD       HL,(LINESN) ; Get LINES number
 1108 8942 224605                  LD       (LINESC),HL ; Save in LINES counter
 1109 8945 E1                      POP      HL
 1110 8946 C9                      RET
 1111                   ;
 1112 8947 E5           COUNT:     PUSH     HL          ; Save code string addr
 1113 8948 D5                      PUSH     DE
 1114 8949 2A4605                  LD       HL,(LINESC) ; Get LINES counter
 1115 894C 11FFFF                  LD       DE,-1
 1116                   ;       ADC     HL,DE           ; Decrement
 1117 894F 7B                      LD       A,E         ;REPLACE Z80 CODE
 1118 8950 8D                      ADC      A,L         ;REPLACE Z80 CODE
 1119 8951 6F                      LD       L,A         ;REPLACE Z80 CODE
 1120 8952 7A                      LD       A,D         ;REPLACE Z80 CODE
 1121 8953 8C                      ADC      A,H         ;REPLACE Z80 CODE
 1122 8954 67                      LD       H,A         ;REPLACE Z80 CODE
 1123                   ;
 1124 8955 224605                  LD       (LINESC),HL ; Put it back
 1125 8958 D1                      POP      DE
 1126 8959 E1                      POP      HL          ; Restore code string a
 1127 895A F0                      RET      P           ; Return if more lines 
 1128 895B E5                      PUSH     HL          ; Save code string addr
 1129 895C 2A4805                  LD       HL,(LINESN) ; Get LINES number
 1130 895F 224605                  LD       (LINESC),HL ; Reset LINES counter
 1131 8962 CD0382                  CALL     RXA         ; Get input character
 1132 8965 FE03                    CP       CTRLC       ; Is it control "C"?
 1133 8967 CA6E89                  JP       Z,RSLNBK    ; Yes - Reset LINES and
 1134 896A E1                      POP      HL          ; Restore code string a
 1135 896B C34789                  JP       COUNT       ; Keep on counting
 1136                   ;
 1137 896E 2A4805       RSLNBK:    LD       HL,(LINESN) ; Get LINES number
 1138 8971 224605                  LD       (LINESC),HL ; Reset LINES counter
 1139 8974 C39882                  JP       BRKRET      ; Go and output "Break"
 1140                   ;
 1141 8977 3E64         FOR:       LD       A,64H       ; Flag "FOR" assignment
 1142 8979 32CB05                  LD       (FORFLG),A  ; Save "FOR" flag
 1143 897C CDE88B                  CALL     LET         ; Set up initial index
 1144 897F C1                      POP      BC          ; Drop RETurn address
 1145 8980 E5                      PUSH     HL          ; Save code string addr
 1146 8981 CDD18B                  CALL     DATA        ; Get next statement ad
 1147 8984 22C705                  LD       (LOOPST),HL ; Save it for start of 
 1148 8987 210200                  LD       HL,2        ; Offset for "FOR" bloc
 1149 898A 39                      ADD      HL,SP       ; Point to it
 1150 898B CD8185       FORSLP:    CALL     LOKFOR      ; Look for existing "FO
 1151 898E D1                      POP      DE          ; Get code string addre
 1152 898F C2A789                  JP       NZ,FORFND   ; No nesting found
 1153 8992 09                      ADD      HL,BC       ; Move into "FOR" block
 1154 8993 D5                      PUSH     DE          ; Save code string addr
 1155 8994 2B                      DEC      HL
 1156 8995 56                      LD       D,(HL)      ; Get MSB of loop state
 1157 8996 2B                      DEC      HL
 1158 8997 5E                      LD       E,(HL)      ; Get LSB of loop state
 1159 8998 23                      INC      HL
 1160 8999 23                      INC      HL
 1161 899A E5                      PUSH     HL          ; Save block address
 1162 899B 2AC705                  LD       HL,(LOOPST) ; Get address of loop s
 1163 899E CD9C88                  CALL     CPDEHL      ; Compare the FOR loops
 1164 89A1 E1                      POP      HL          ; Restore block address
 1165 89A2 C28B89                  JP       NZ,FORSLP   ; Different FORs - Find
 1166 89A5 D1                      POP      DE          ; Restore code string a
 1167 89A6 F9                      LD       SP,HL       ; Remove all nested loo
 1168                   ;
 1169 89A7 EB           FORFND:    EX       DE,HL       ; Code string address t
 1170 89A8 0E08                    LD       C,8
 1171 89AA CDB185                  CALL     CHKSTK      ; Check for 8 levels of
 1172 89AD E5                      PUSH     HL          ; Save code string addr
 1173 89AE 2AC705                  LD       HL,(LOOPST) ; Get first statement o
 1174 89B1 E3                      EX       (SP),HL     ; Save and restore code
 1175 89B2 E5                      PUSH     HL          ; Re-save code string a
 1176 89B3 2A5C05                  LD       HL,(LINEAT) ; Get current line numb
 1177 89B6 E3                      EX       (SP),HL     ; Save and restore code
 1178 89B7 CDAA8E                  CALL     TSTNUM      ; Make sure it's a numb
 1179 89BA CDA288                  CALL     CHKSYN      ; Make sure "TO" is nex
 1180 89BD A6                      DB       ZTO         ; "TO" token
 1181 89BE CDA78E                  CALL     GETNUM      ; Get "TO" expression v
 1182 89C1 E5                      PUSH     HL          ; Save code string addr
 1183 89C2 CDD898                  CALL     BCDEFP      ; Move "TO" value to BC
 1184 89C5 E1                      POP      HL          ; Restore code string a
 1185 89C6 C5                      PUSH     BC          ; Save "TO" value in bl
 1186 89C7 D5                      PUSH     DE
 1187 89C8 010081                  LD       BC,8100H    ; BCDE - 1 (default STE
 1188 89CB 51                      LD       D,C         ; C=0
 1189 89CC 5A                      LD       E,D         ; D=0
 1190 89CD 7E                      LD       A,(HL)      ; Get next byte in code
 1191 89CE FEAB                    CP       ZSTEP       ; See if "STEP" is stat
 1192 89D0 3E01                    LD       A,1         ; Sign of step = 1
 1193 89D2 C2E389                  JP       NZ,SAVSTP   ; No STEP given - Defau
 1194 89D5 CD308A                  CALL     GETCHR      ; Jump over "STEP" toke
 1195 89D8 CDA78E                  CALL     GETNUM      ; Get step value
 1196 89DB E5                      PUSH     HL          ; Save code string addr
 1197 89DC CDD898                  CALL     BCDEFP      ; Move STEP to BCDE
 1198 89DF CD8C98                  CALL     TSTSGN      ; Test sign of FPREG
 1199 89E2 E1                      POP      HL          ; Restore code string a
 1200 89E3 C5           SAVSTP:    PUSH     BC          ; Save the STEP value i
 1201 89E4 D5                      PUSH     DE
 1202 89E5 F5                      PUSH     AF          ; Save sign of STEP
 1203 89E6 33                      INC      SP          ; Don't save flags
 1204 89E7 E5                      PUSH     HL          ; Save code string addr
 1205 89E8 2ACE05                  LD       HL,(BRKLIN) ; Get address of index 
 1206 89EB E3                      EX       (SP),HL     ; Save and restore code
 1207 89EC 0681         PUTFID:    LD       B,ZFOR      ; "FOR" block marker
 1208 89EE C5                      PUSH     BC          ; Save it
 1209 89EF 33                      INC      SP          ; Don't save C
 1210                   ;
 1211 89F0 CD5B8A       RUNCNT:    CALL     TSTBRK      ; Execution driver - Te
 1212 89F3 22CE05                  LD       (BRKLIN),HL ; Save code address for
 1213 89F6 7E                      LD       A,(HL)      ; Get next byte in code
 1214 89F7 FE3A                    CP       ':'         ; Multi statement line?
 1215 89F9 CA108A                  JP       Z,EXCUTE    ; Yes - Execute it
 1216 89FC B7                      OR       A           ; End of line?
 1217 89FD C2D485                  JP       NZ,SNERR    ; No - Syntax error
 1218 8A00 23                      INC      HL          ; Point to address of n
 1219 8A01 7E                      LD       A,(HL)      ; Get LSB of line point
 1220 8A02 23                      INC      HL
 1221 8A03 B6                      OR       (HL)        ; Is it zero (End of pr
 1222 8A04 CA8C8A                  JP       Z,ENDPRG    ; Yes - Terminate execu
 1223 8A07 23                      INC      HL          ; Point to line number
 1224 8A08 5E                      LD       E,(HL)      ; Get LSB of line numbe
 1225 8A09 23                      INC      HL
 1226 8A0A 56                      LD       D,(HL)      ; Get MSB of line numbe
 1227 8A0B EB                      EX       DE,HL       ; Line number to HL
 1228 8A0C 225C05                  LD       (LINEAT),HL ; Save as current line 
 1229 8A0F EB                      EX       DE,HL       ; Line number back to D
 1230 8A10 CD308A       EXCUTE:    CALL     GETCHR      ; Get key word
 1231 8A13 11F089                  LD       DE,RUNCNT   ; Where to RETurn to
 1232 8A16 D5                      PUSH     DE          ; Save for RETurn
 1233 8A17 C8           IFJMP:     RET      Z           ; Go to RUNCNT if end o
 1234 8A18 D680         ONJMP:     SUB      ZEND        ; Is it a token?
 1235 8A1A DAE88B                  JP       C,LET       ; No - try to assign it
 1236 8A1D FE25                    CP       ZNEW+1-ZEND ; END to NEW ?
 1237 8A1F D2D485                  JP       NC,SNERR    ; Not a key word - ?SN 
 1238 8A22 07                      RLCA                 ; Double it
 1239 8A23 4F                      LD       C,A         ; BC = Offset into tabl
 1240 8A24 0600                    LD       B,0
 1241 8A26 EB                      EX       DE,HL       ; Save code string addr
 1242 8A27 217C84                  LD       HL,WORDTB   ; Keyword address table
 1243 8A2A 09                      ADD      HL,BC       ; Point to routine addr
 1244 8A2B 4E                      LD       C,(HL)      ; Get LSB of routine ad
 1245 8A2C 23                      INC      HL
 1246 8A2D 46                      LD       B,(HL)      ; Get MSB of routine ad
 1247 8A2E C5                      PUSH     BC          ; Save routine address
 1248 8A2F EB                      EX       DE,HL       ; Restore code string a
 1249                   ;
 1250 8A30 23           GETCHR:    INC      HL          ; Point to next charact
 1251 8A31 7E                      LD       A,(HL)      ; Get next code string 
 1252 8A32 FE3A                    CP       ':'         ; Z if ':'
 1253 8A34 D0                      RET      NC          ; NC if > "9"
 1254 8A35 FE20                    CP       ' '
 1255 8A37 CA308A                  JP       Z,GETCHR    ; Skip over spaces
 1256 8A3A FE30                    CP       '0'
 1257 8A3C 3F                      CCF                  ; NC if < '0'
 1258 8A3D 3C                      INC      A           ; Test for zero - Leave
 1259 8A3E 3D                      DEC      A           ; Z if Null
 1260 8A3F C9                      RET
 1261                   ;
 1262 8A40 EB           RESTOR:    EX       DE,HL       ; Save code string addr
 1263 8A41 2A5E05                  LD       HL,(BASTXT) ; Point to start of pro
 1264 8A44 CA558A                  JP       Z,RESTNL    ; Just RESTORE - reset 
 1265 8A47 EB                      EX       DE,HL       ; Restore code string a
 1266 8A48 CD068B                  CALL     ATOH        ; Get line number to DE
 1267 8A4B E5                      PUSH     HL          ; Save code string addr
 1268 8A4C CDC086                  CALL     SRCHLN      ; Search for line numbe
 1269 8A4F 60                      LD       H,B         ; HL = Address of line
 1270 8A50 69                      LD       L,C
 1271 8A51 D1                      POP      DE          ; Restore code string a
 1272 8A52 D2A78B                  JP       NC,ULERR    ; ?UL Error if not foun
 1273 8A55 2B           RESTNL:    DEC      HL          ; Byte before DATA stat
 1274 8A56 22DC05       UPDATA:    LD       (NXTDAT),HL ; Update DATA pointer
 1275 8A59 EB                      EX       DE,HL       ; Restore code string a
 1276 8A5A C9                      RET
 1277                   ;
 1278                   
 1279 8A5B CD0B82       TSTBRK:    CALL     CHKCHR      ; Check input status
 1280 8A5E C8                      RET      Z           ; No key, go back
 1281 8A5F CD0382                  CALL     RXA         ; Get the key into A
 1282 8A62 FE1B                    CP       ESC         ; Escape key?
 1283 8A64 CA7D8A                  JP       Z,BRK       ; Yes, break
 1284 8A67 FE03                    CP       CTRLC       ; <Ctrl-C>
 1285 8A69 CA7D8A                  JP       Z,BRK       ; Yes, break
 1286 8A6C FE13                    CP       CTRLS       ; Stop scrolling?
 1287 8A6E C0                      RET      NZ          ; Other key, ignore
 1288                   ;
 1289                   
 1290 8A6F CD0382       STALL:     CALL     RXA         ; Wait for key
 1291 8A72 FE11                    CP       CTRLQ       ; Resume scrolling?
 1292 8A74 C8                      RET      Z           ; Release the chokehold
 1293 8A75 FE03                    CP       CTRLC       ; Second break?
 1294 8A77 CA828A                  JP       Z,STOP      ; Break during hold exi
 1295 8A7A C36F8A                  JP       STALL       ; Loop until <Ctrl-Q> o
 1296                   ;
 1297 8A7D 3EFF         BRK        LD       A,0FFH      ; Set BRKFLG
 1298 8A7F 324D05                  LD       (BRKFLG),A  ; Store it
 1299                   ;
 1300                   
 1301 8A82 C0           STOP:      RET      NZ          ; Exit if anything else
 1302 8A83 F6                      DB       0F6H        ; Flag "STOP"
 1303 8A84 C0           PEND:      RET      NZ          ; Exit if anything else
 1304 8A85 22CE05                  LD       (BRKLIN),HL ; Save point of break
 1305 8A88 21                      DB       21H         ; Skip "OR 11111111B"
 1306 8A89 F6FF         INPBRK:    OR       11111111B   ; Flag "Break" wanted
 1307 8A8B C1                      POP      BC          ; Return not needed and
 1308 8A8C 2A5C05       ENDPRG:    LD       HL,(LINEAT) ; Get current line numb
 1309 8A8F F5                      PUSH     AF          ; Save STOP / END statu
 1310 8A90 7D                      LD       A,L         ; Is it direct break?
 1311 8A91 A4                      AND      H
 1312 8A92 3C                      INC      A           ; Line is -1 if direct 
 1313 8A93 CA9F8A                  JP       Z,NOLIN     ; Yes - No line number
 1314 8A96 22D205                  LD       (ERRLIN),HL ; Save line of break
 1315 8A99 2ACE05                  LD       HL,(BRKLIN) ; Get point of break
 1316 8A9C 22D405                  LD       (CONTAD),HL ; Save point to CONTinu
 1317 8A9F AF           NOLIN:     XOR      A
 1318 8AA0 324505                  LD       (CTLOFG),A  ; Enable output
 1319 8AA3 CDD58C                  CALL     STTLIN      ; Start a new line
 1320 8AA6 F1                      POP      AF          ; Restore STOP / END st
 1321 8AA7 217785                  LD       HL,BRKMSG   ; "Break" message
 1322 8AAA C20886                  JP       NZ,ERRIN    ; "in line" wanted?
 1323 8AAD C31F86                  JP       PRNTOK      ; Go to command mode
 1324                   ;
 1325 8AB0 2AD405       CONT:      LD       HL,(CONTAD) ; Get CONTinue address
 1326 8AB3 7C                      LD       A,H         ; Is it zero?
 1327 8AB4 B5                      OR       L
 1328 8AB5 1E20                    LD       E,CN        ; ?CN Error
 1329 8AB7 CAE885                  JP       Z,ERROR     ; Yes - output "?CN Err
 1330 8ABA EB                      EX       DE,HL       ; Save code string addr
 1331 8ABB 2AD205                  LD       HL,(ERRLIN) ; Get line of last brea
 1332 8ABE 225C05                  LD       (LINEAT),HL ; Set up current line n
 1333 8AC1 EB                      EX       DE,HL       ; Restore code string a
 1334 8AC2 C9                      RET                  ; CONTinue where left o
 1335                   ;
 1336 8AC3 CD0B96       NULL:      CALL     GETINT      ; Get integer 0-255
 1337 8AC6 C0                      RET      NZ          ; Return if bad value
 1338 8AC7 324105                  LD       (NULLS),A   ; Set nulls number
 1339 8ACA C9                      RET
 1340                   ;
 1341                   
 1342 8ACB E5           ACCSUM:    PUSH     HL          ; Save address in array
 1343 8ACC 2A4A05                  LD       HL,(CHKSUM) ; Get check sum
 1344 8ACF 0600                    LD       B,0         ; BC - Value of byte
 1345 8AD1 4F                      LD       C,A
 1346 8AD2 09                      ADD      HL,BC       ; Add byte to check sum
 1347 8AD3 224A05                  LD       (CHKSUM),HL ; Re-save check sum
 1348 8AD6 E1                      POP      HL          ; Restore address in ar
 1349 8AD7 C9                      RET
 1350                   ;
 1351 8AD8 7E           CHKLTR:    LD       A,(HL)      ; Get byte
 1352 8AD9 FE41                    CP       'A'         ; < 'a' ?
 1353 8ADB D8                      RET      C           ; Carry set if not lett
 1354 8ADC FE5B                    CP       'Z'+1       ; > 'z' ?
 1355 8ADE 3F                      CCF
 1356 8ADF C9                      RET                  ; Carry set if not lett
 1357                   ;
 1358 8AE0 CD308A       FPSINT:    CALL     GETCHR      ; Get next character
 1359 8AE3 CDA78E       POSINT:    CALL     GETNUM      ; Get integer 0 to 3276
 1360 8AE6 CD8C98       DEPINT:    CALL     TSTSGN      ; Test sign of FPREG
 1361 8AE9 FA018B                  JP       M,FCERR     ; Negative - ?FC Error
 1362 8AEC 3AE705       DEINT:     LD       A,(FPEXP)   ; Get integer value to 
 1363 8AEF FE90                    CP       80H+16      ; Exponent in range (16
 1364 8AF1 DA3499                  JP       C,FPINT     ; Yes - convert it
 1365 8AF4 018090                  LD       BC,9080H    ; BCDE = -32768
 1366 8AF7 110000                  LD       DE,0000
 1367 8AFA E5                      PUSH     HL          ; Save code string addr
 1368 8AFB CD0799                  CALL     CMPNUM      ; Compare FPREG with BC
 1369 8AFE E1                      POP      HL          ; Restore code string a
 1370 8AFF 51                      LD       D,C         ; MSB to D
 1371 8B00 C8                      RET      Z           ; Return if in range
 1372 8B01 1E08         FCERR:     LD       E,FC        ; ?FC Error
 1373 8B03 C3E885                  JP       ERROR       ; Output error-
 1374                   ;
 1375 8B06 2B           ATOH:      DEC      HL          ; ASCII number to DE bi
 1376 8B07 110000       GETLN:     LD       DE,0        ; Get number to DE
 1377 8B0A CD308A       GTLNLP:    CALL     GETCHR      ; Get next character
 1378 8B0D D0                      RET      NC          ; Exit if not a digit
 1379 8B0E E5                      PUSH     HL          ; Save code string addr
 1380 8B0F F5                      PUSH     AF          ; Save digit
 1381 8B10 219819                  LD       HL,65529/10 ; Largest number 65529
 1382 8B13 CD9C88                  CALL     CPDEHL      ; Number in range?
 1383 8B16 DAD485                  JP       C,SNERR     ; No - ?SN Error
 1384 8B19 62                      LD       H,D         ; HL = Number
 1385 8B1A 6B                      LD       L,E
 1386 8B1B 19                      ADD      HL,DE       ; Times 2
 1387 8B1C 29                      ADD      HL,HL       ; Times 4
 1388 8B1D 19                      ADD      HL,DE       ; Times 5
 1389 8B1E 29                      ADD      HL,HL       ; Times 10
 1390 8B1F F1                      POP      AF          ; Restore digit
 1391 8B20 D630                    SUB      '0'         ; Make it 0 to 9
 1392 8B22 5F                      LD       E,A         ; DE = Value of digit
 1393 8B23 1600                    LD       D,0
 1394 8B25 19                      ADD      HL,DE       ; Add to number
 1395 8B26 EB                      EX       DE,HL       ; Number to DE
 1396 8B27 E1                      POP      HL          ; Restore code string a
 1397 8B28 C30A8B                  JP       GTLNLP      ; Go to next character
 1398                   ;
 1399 8B2B CAF086       CLEAR:     JP       Z,INTVAR    ; Just "CLEAR" Keep par
 1400 8B2E CDE38A                  CALL     POSINT      ; Get integer 0 to 3276
 1401 8B31 2B                      DEC      HL          ; Cancel increment
 1402 8B32 CD308A                  CALL     GETCHR      ; Get next character
 1403 8B35 E5                      PUSH     HL          ; Save code string addr
 1404 8B36 2AAF05                  LD       HL,(LSTRAM) ; Get end of RAM
 1405 8B39 CA4E8B                  JP       Z,STORED    ; No value given - Use 
 1406 8B3C E1                      POP      HL          ; Restore code string a
 1407 8B3D CDA288                  CALL     CHKSYN      ; Check for comma
 1408 8B40 2C                      DB       ','
 1409 8B41 D5                      PUSH     DE          ; Save number
 1410 8B42 CDE38A                  CALL     POSINT      ; Get integer 0 to 3276
 1411 8B45 2B                      DEC      HL          ; Cancel increment
 1412 8B46 CD308A                  CALL     GETCHR      ; Get next character
 1413 8B49 C2D485                  JP       NZ,SNERR    ; ?SN Error if more on 
 1414 8B4C E3                      EX       (SP),HL     ; Save code string addr
 1415 8B4D EB                      EX       DE,HL       ; Number to DE
 1416 8B4E 7D           STORED:    LD       A,L         ; Get LSB of new RAM to
 1417 8B4F 93                      SUB      E           ; Subtract LSB of strin
 1418 8B50 5F                      LD       E,A         ; Save LSB
 1419 8B51 7C                      LD       A,H         ; Get MSB of new RAM to
 1420 8B52 9A                      SBC      A,D         ; Subtract MSB of strin
 1421 8B53 57                      LD       D,A         ; Save MSB
 1422 8B54 DAC985                  JP       C,OMERR     ; ?OM Error if not enou
 1423 8B57 E5                      PUSH     HL          ; Save RAM top
 1424 8B58 2AD605                  LD       HL,(PROGND) ; Get program end
 1425 8B5B 012800                  LD       BC,40       ; 40 Bytes minimum work
 1426 8B5E 09                      ADD      HL,BC       ; Get lowest address
 1427 8B5F CD9C88                  CALL     CPDEHL      ; Enough memory?
 1428 8B62 D2C985                  JP       NC,OMERR    ; No - ?OM Error
 1429 8B65 EB                      EX       DE,HL       ; RAM top to HL
 1430 8B66 225A05                  LD       (STRSPC),HL ; Set new string space
 1431 8B69 E1                      POP      HL          ; End of memory to use
 1432 8B6A 22AF05                  LD       (LSTRAM),HL ; Set new top of RAM
 1433 8B6D E1                      POP      HL          ; Restore code string a
 1434 8B6E C3F086                  JP       INTVAR      ; Initialise variables
 1435                   ;
 1436 8B71 CAEC86       RUN:       JP       Z,RUNFST    ; RUN from start if jus
 1437 8B74 CDF086                  CALL     INTVAR      ; Initialise variables
 1438 8B77 01F089                  LD       BC,RUNCNT   ; Execution driver loop
 1439 8B7A C38D8B                  JP       RUNLIN      ; RUN from line number
 1440                   ;
 1441 8B7D 0E03         GOSUB:     LD       C,3         ; 3 Levels of stack nee
 1442 8B7F CDB185                  CALL     CHKSTK      ; Check for 3 levels of
 1443 8B82 C1                      POP      BC          ; Get return address
 1444 8B83 E5                      PUSH     HL          ; Save code string for 
 1445 8B84 E5                      PUSH     HL          ; And for GOSUB routine
 1446 8B85 2A5C05                  LD       HL,(LINEAT) ; Get current line
 1447 8B88 E3                      EX       (SP),HL     ; Into stack - Code str
 1448 8B89 3E8C                    LD       A,ZGOSUB    ; "GOSUB" token
 1449 8B8B F5                      PUSH     AF          ; Save token
 1450 8B8C 33                      INC      SP          ; Don't save flags
 1451                   ;
 1452 8B8D C5           RUNLIN:    PUSH     BC          ; Save return address
 1453 8B8E CD068B       GOTO:      CALL     ATOH        ; ASCII number to DE bi
 1454 8B91 CDD38B                  CALL     REM         ; Get end of line
 1455 8B94 E5                      PUSH     HL          ; Save end of line
 1456 8B95 2A5C05                  LD       HL,(LINEAT) ; Get current line
 1457 8B98 CD9C88                  CALL     CPDEHL      ; Line after current?
 1458 8B9B E1                      POP      HL          ; Restore end of line
 1459 8B9C 23                      INC      HL          ; Start of next line
 1460 8B9D DCC386                  CALL     C,SRCHLP    ; Line is after current
 1461 8BA0 D4C086                  CALL     NC,SRCHLN   ; Line is before curren
 1462 8BA3 60                      LD       H,B         ; Set up code string ad
 1463 8BA4 69                      LD       L,C
 1464 8BA5 2B                      DEC      HL          ; Incremented after
 1465 8BA6 D8                      RET      C           ; Line found
 1466 8BA7 1E0E         ULERR:     LD       E,UL        ; ?UL Error
 1467 8BA9 C3E885                  JP       ERROR       ; Output error message
 1468                   ;
 1469 8BAC C0           RETURN:    RET      NZ          ; Return if not just RE
 1470 8BAD 16FF                    LD       D,-1        ; Flag "GOSUB" search
 1471 8BAF CD7D85                  CALL     BAKSTK      ; Look "GOSUB" block
 1472 8BB2 F9                      LD       SP,HL       ; Kill all FORs in subr
 1473 8BB3 FE8C                    CP       ZGOSUB      ; Test for "GOSUB" toke
 1474 8BB5 1E04                    LD       E,RG        ; ?RG Error
 1475 8BB7 C2E885                  JP       NZ,ERROR    ; Error if no "GOSUB" f
 1476 8BBA E1                      POP      HL          ; Get RETURN line numbe
 1477 8BBB 225C05                  LD       (LINEAT),HL ; Save as current
 1478 8BBE 23                      INC      HL          ; Was it from direct st
 1479 8BBF 7C                      LD       A,H
 1480 8BC0 B5                      OR       L           ; Return to line
 1481 8BC1 C2CB8B                  JP       NZ,RETLIN   ; No - Return to line
 1482 8BC4 3ACC05                  LD       A,(LSTBIN)  ; Any INPUT in subrouti
 1483 8BC7 B7                      OR       A           ; If so buffer is corru
 1484 8BC8 C21E86                  JP       NZ,POPNOK   ; Yes - Go to command m
 1485 8BCB 21F089       RETLIN:    LD       HL,RUNCNT   ; Execution driver loop
 1486 8BCE E3                      EX       (SP),HL     ; Into stack - Code str
 1487 8BCF 3E                      DB       3EH         ; Skip "POP HL"
 1488 8BD0 E1           NXTDTA:    POP      HL          ; Restore code string a
 1489                   ;
 1490 8BD1 013A         DATA:      DB       01H,3AH     ; ':' End of statement
 1491 8BD3 0E00         REM:       LD       C,0         ; 00    End of statemen
 1492 8BD5 0600                    LD       B,0
 1493 8BD7 79           NXTSTL:    LD       A,C         ; Statement and byte
 1494 8BD8 48                      LD       C,B
 1495 8BD9 47                      LD       B,A         ; Statement end byte
 1496 8BDA 7E           NXTSTT:    LD       A,(HL)      ; Get byte
 1497 8BDB B7                      OR       A           ; End of line?
 1498 8BDC C8                      RET      Z           ; Yes - Exit
 1499 8BDD B8                      CP       B           ; End of statement?
 1500 8BDE C8                      RET      Z           ; Yes - Exit
 1501 8BDF 23                      INC      HL          ; Next byte
 1502 8BE0 FE22                    CP       '"'         ; Literal string?
 1503 8BE2 CAD78B                  JP       Z,NXTSTL    ; Yes - Look for anothe
 1504 8BE5 C3DA8B                  JP       NXTSTT      ; Keep looking
 1505                   ;
 1506 8BE8 CD9E90       LET:       CALL     GETVAR      ; Get variable name
 1507 8BEB CDA288                  CALL     CHKSYN      ; Make sure "=" follows
 1508 8BEE B4                      DB       ZEQUAL      ; "=" token
 1509 8BEF D5                      PUSH     DE          ; Save address of varia
 1510 8BF0 3AAD05                  LD       A,(TYPE)    ; Get data type
 1511 8BF3 F5                      PUSH     AF          ; Save type
 1512 8BF4 CDB98E                  CALL     EVAL        ; Evaluate expression
 1513 8BF7 F1                      POP      AF          ; Restore type
 1514 8BF8 E3                      EX       (SP),HL     ; Save code - Get var a
 1515 8BF9 22CE05                  LD       (BRKLIN),HL ; Save address of varia
 1516 8BFC 1F                      RRA                  ; Adjust type
 1517 8BFD CDAC8E                  CALL     CHKTYP      ; Check types are the s
 1518 8C00 CA3B8C                  JP       Z,LETNUM    ; Numeric - Move value
 1519 8C03 E5           LETSTR:    PUSH     HL          ; Save address of strin
 1520 8C04 2AE405                  LD       HL,(FPREG)  ; Pointer to string ent
 1521 8C07 E5                      PUSH     HL          ; Save it on stack
 1522 8C08 23                      INC      HL          ; Skip over length
 1523 8C09 23                      INC      HL
 1524 8C0A 5E                      LD       E,(HL)      ; LSB of string address
 1525 8C0B 23                      INC      HL
 1526 8C0C 56                      LD       D,(HL)      ; MSB of string address
 1527 8C0D 2A5E05                  LD       HL,(BASTXT) ; Point to start of pro
 1528 8C10 CD9C88                  CALL     CPDEHL      ; Is string before prog
 1529 8C13 D22A8C                  JP       NC,CRESTR   ; Yes - Create string e
 1530 8C16 2A5A05                  LD       HL,(STRSPC) ; Point to string space
 1531 8C19 CD9C88                  CALL     CPDEHL      ; Is string literal in 
 1532 8C1C D1                      POP      DE          ; Restore address of st
 1533 8C1D D2328C                  JP       NC,MVSTPT   ; Yes - Set up pointer
 1534 8C20 21BF05                  LD       HL,TMPSTR   ; Temporary string pool
 1535 8C23 CD9C88                  CALL     CPDEHL      ; Is string in temporar
 1536 8C26 D2328C                  JP       NC,MVSTPT   ; No - Set up pointer
 1537 8C29 3E                      DB       3EH         ; Skip "POP DE"
 1538 8C2A D1           CRESTR:    POP      DE          ; Restore address of st
 1539 8C2B CDE294                  CALL     BAKTMP      ; Back to last tmp-str 
 1540 8C2E EB                      EX       DE,HL       ; Address of string ent
 1541 8C2F CD1B93                  CALL     SAVSTR      ; Save string in string
 1542 8C32 CDE294       MVSTPT:    CALL     BAKTMP      ; Back to last tmp-str 
 1543 8C35 E1                      POP      HL          ; Get string pointer
 1544 8C36 CDE798                  CALL     DETHL4      ; Move string pointer t
 1545 8C39 E1                      POP      HL          ; Restore code string a
 1546 8C3A C9                      RET
 1547                   ;
 1548 8C3B E5           LETNUM:    PUSH     HL          ; Save address of varia
 1549 8C3C CDE498                  CALL     FPTHL       ; Move value to variabl
 1550 8C3F D1                      POP      DE          ; Restore address of va
 1551 8C40 E1                      POP      HL          ; Restore code string a
 1552 8C41 C9                      RET
 1553                   ;
 1554 8C42 CD0B96       ON:        CALL     GETINT      ; Get integer 0-255
 1555 8C45 7E                      LD       A,(HL)      ; Get "GOTO" or "GOSUB"
 1556 8C46 47                      LD       B,A         ; Save in B
 1557 8C47 FE8C                    CP       ZGOSUB      ; "GOSUB" token?
 1558 8C49 CA518C                  JP       Z,ONGO      ; Yes - Find line numbe
 1559 8C4C CDA288                  CALL     CHKSYN      ; Make sure it's "GOTO"
 1560 8C4F 88                      DB       ZGOTO       ; "GOTO" token
 1561 8C50 2B                      DEC      HL          ; Cancel increment
 1562 8C51 4B           ONGO:      LD       C,E         ; Integer of branch val
 1563 8C52 0D           ONGOLP:    DEC      C           ; Count branches
 1564 8C53 78                      LD       A,B         ; Get "GOTO" or "GOSUB"
 1565 8C54 CA188A                  JP       Z,ONJMP     ; Go to that line if ri
 1566 8C57 CD078B                  CALL     GETLN       ; Get line number to DE
 1567 8C5A FE2C                    CP       ','         ; Another line number?
 1568 8C5C C0                      RET      NZ          ; No - Drop through
 1569 8C5D C3528C                  JP       ONGOLP      ; Yes - loop
 1570                   ;
 1571 8C60 CDB98E       IF:        CALL     EVAL        ; Evaluate expression
 1572 8C63 7E                      LD       A,(HL)      ; Get token
 1573 8C64 FE88                    CP       ZGOTO       ; "GOTO" token?
 1574 8C66 CA6E8C                  JP       Z,IFGO      ; Yes - Get line
 1575 8C69 CDA288                  CALL     CHKSYN      ; Make sure it's "THEN"
 1576 8C6C A9                      DB       ZTHEN       ; "THEN" token
 1577 8C6D 2B                      DEC      HL          ; Cancel increment
 1578 8C6E CDAA8E       IFGO:      CALL     TSTNUM      ; Make sure it's numeri
 1579 8C71 CD8C98                  CALL     TSTSGN      ; Test state of express
 1580 8C74 CAD38B                  JP       Z,REM       ; False - Drop through
 1581 8C77 CD308A                  CALL     GETCHR      ; Get next character
 1582 8C7A DA8E8B                  JP       C,GOTO      ; Number - GOTO that li
 1583 8C7D C3178A                  JP       IFJMP       ; Otherwise do statemen
 1584                   ;
 1585 8C80 2B           MRPRNT:    DEC      HL          ; DEC 'cos GETCHR INCs
 1586 8C81 CD308A                  CALL     GETCHR      ; Get next character
 1587 8C84 CAE28C       PRINT:     JP       Z,PRCRLF    ; CRLF if just PRINT
 1588 8C87 C8           PRNTLP:    RET      Z           ; End of list - Exit
 1589 8C88 FEA5                    CP       ZTAB        ; "TAB(" token?
 1590 8C8A CA158D                  JP       Z,DOTAB     ; Yes - Do TAB routine
 1591 8C8D FEA8                    CP       ZSPC        ; "SPC(" token?
 1592 8C8F CA158D                  JP       Z,DOTAB     ; Yes - Do SPC routine
 1593 8C92 E5                      PUSH     HL          ; Save code string addr
 1594 8C93 FE2C                    CP       ','         ; Comma?
 1595 8C95 CAFE8C                  JP       Z,DOCOM     ; Yes - Move to next zo
 1596 8C98 FE3B                    CP       59          ;";"          ; Semi-co
 1597 8C9A CA388D                  JP       Z,NEXITM    ; Do semi-colon routine
 1598 8C9D C1                      POP      BC          ; Code string address t
 1599 8C9E CDB98E                  CALL     EVAL        ; Evaluate expression
 1600 8CA1 E5                      PUSH     HL          ; Save code string addr
 1601 8CA2 3AAD05                  LD       A,(TYPE)    ; Get variable type
 1602 8CA5 B7                      OR       A           ; Is it a string variab
 1603 8CA6 C2CE8C                  JP       NZ,PRNTST   ; Yes - Output string c
 1604 8CA9 CD319A                  CALL     NUMASC      ; Convert number to tex
 1605 8CAC CD3F93                  CALL     CRTST       ; Create temporary stri
 1606 8CAF 3620                    LD       (HL),' '    ; Followed by a space
 1607 8CB1 2AE405                  LD       HL,(FPREG)  ; Get length of output
 1608 8CB4 34                      INC      (HL)        ; Plus 1 for the space
 1609 8CB5 2AE405                  LD       HL,(FPREG)  ; < Not needed >
 1610 8CB8 3A4205                  LD       A,(LWIDTH)  ; Get width of line
 1611 8CBB 47                      LD       B,A         ; To B
 1612 8CBC 04                      INC      B           ; Width 255 (No limit)?
 1613 8CBD CACA8C                  JP       Z,PRNTNB    ; Yes - Output number s
 1614 8CC0 04                      INC      B           ; Adjust it
 1615 8CC1 3AAB05                  LD       A,(CURPOS)  ; Get cursor position
 1616 8CC4 86                      ADD      A,(HL)      ; Add length of string
 1617 8CC5 3D                      DEC      A           ; Adjust it
 1618 8CC6 B8                      CP       B           ; Will output fit on th
 1619 8CC7 D4E28C                  CALL     NC,PRCRLF   ; No - CRLF first
 1620 8CCA CD8493       PRNTNB:    CALL     PRS1        ; Output string at (HL)
 1621 8CCD AF                      XOR      A           ; Skip CALL by setting 
 1622 8CCE C48493       PRNTST:    CALL     NZ,PRS1     ; Output string at (HL)
 1623 8CD1 E1                      POP      HL          ; Restore code string a
 1624 8CD2 C3808C                  JP       MRPRNT      ; See if more to PRINT
 1625                   ;
 1626 8CD5 3AAB05       STTLIN:    LD       A,(CURPOS)  ; Make sure on new line
 1627 8CD8 B7                      OR       A           ; Already at start?
 1628 8CD9 C8                      RET      Z           ; Yes - Do nothing
 1629 8CDA C3E28C                  JP       PRCRLF      ; Start a new line
 1630                   ;
 1631 8CDD 3600         ENDINP:    LD       (HL),0      ; Mark end of buffer
 1632 8CDF 216005                  LD       HL,BUFFER-1 ; Point to buffer
 1633 8CE2 3E0D         PRCRLF:    LD       A,CR        ; Load a CR
 1634 8CE4 CDAD88                  CALL     OUTC        ; Output character
 1635 8CE7 3E0A                    LD       A,LF        ; Load a LF
 1636 8CE9 CDAD88                  CALL     OUTC        ; Output character
 1637 8CEC AF           DONULL:    XOR      A           ; Set to position 0
 1638 8CED 32AB05                  LD       (CURPOS),A  ; Store it
 1639 8CF0 3A4105                  LD       A,(NULLS)   ; Get number of nulls
 1640 8CF3 3D           NULLP:     DEC      A           ; Count them
 1641 8CF4 C8                      RET      Z           ; Return if done
 1642 8CF5 F5                      PUSH     AF          ; Save count
 1643 8CF6 AF                      XOR      A           ; Load a null
 1644 8CF7 CDAD88                  CALL     OUTC        ; Output it
 1645 8CFA F1                      POP      AF          ; Restore count
 1646 8CFB C3F38C                  JP       NULLP       ; Keep counting
 1647                   ;
 1648 8CFE 3A4305       DOCOM:     LD       A,(COMMAN)  ; Get comma width
 1649 8D01 47                      LD       B,A         ; Save in B
 1650 8D02 3AAB05                  LD       A,(CURPOS)  ; Get current position
 1651 8D05 B8                      CP       B           ; Within the limit?
 1652 8D06 D4E28C                  CALL     NC,PRCRLF   ; No - output CRLF
 1653 8D09 D2388D                  JP       NC,NEXITM   ; Get next item
 1654 8D0C D60E         ZONELP:    SUB      14          ; Next zone of 14 chara
 1655 8D0E D20C8D                  JP       NC,ZONELP   ; Repeat if more zones
 1656 8D11 2F                      CPL                  ; Number of spaces to o
 1657 8D12 C32D8D                  JP       ASPCS       ; Output them
 1658                   ;
 1659 8D15 F5           DOTAB:     PUSH     AF          ; Save token
 1660 8D16 CD0896                  CALL     FNDNUM      ; Evaluate expression
 1661 8D19 CDA288                  CALL     CHKSYN      ; Make sure ")" follows
 1662 8D1C 29                      DB       ")"
 1663 8D1D 2B                      DEC      HL          ; Back space on to ")"
 1664 8D1E F1                      POP      AF          ; Restore token
 1665 8D1F D6A8                    SUB      ZSPC        ; Was it "SPC(" ?
 1666 8D21 E5                      PUSH     HL          ; Save code string addr
 1667 8D22 CA288D                  JP       Z,DOSPC     ; Yes - Do 'E' spaces
 1668 8D25 3AAB05                  LD       A,(CURPOS)  ; Get current position
 1669 8D28 2F           DOSPC:     CPL                  ; Number of spaces to p
 1670 8D29 83                      ADD      A,E         ; Total number to print
 1671 8D2A D2388D                  JP       NC,NEXITM   ; TAB < Current POS(X)
 1672 8D2D 3C           ASPCS:     INC      A           ; Output A spaces
 1673 8D2E 47                      LD       B,A         ; Save number to print
 1674 8D2F 3E20                    LD       A,' '       ; Space
 1675 8D31 CDAD88       SPCLP:     CALL     OUTC        ; Output character in A
 1676 8D34 05                      DEC      B           ; Count them
 1677 8D35 C2318D                  JP       NZ,SPCLP    ; Repeat if more
 1678 8D38 E1           NEXITM:    POP      HL          ; Restore code string a
 1679 8D39 CD308A                  CALL     GETCHR      ; Get next character
 1680 8D3C C3878C                  JP       PRNTLP      ; More to print
 1681                   ;
 1682 8D3F 3F5265646F20 REDO:      DB       "?Redo from start",CR,LF,0
           66726F6D2073 
           746172740D0A 
           00           
 1683                   ;
 1684 8D52 3ACD05       BADINP:    LD       A,(READFG)  ; READ or INPUT?
 1685 8D55 B7                      OR       A
 1686 8D56 C2CE85                  JP       NZ,DATSNR   ; READ - ?SN Error
 1687 8D59 C1                      POP      BC          ; Throw away code strin
 1688 8D5A 213F8D                  LD       HL,REDO     ; "Redo from start" mes
 1689 8D5D CD8193                  CALL     PRS         ; Output string
 1690 8D60 C31F87                  JP       DOAGN       ; Do last INPUT again
 1691                   ;
 1692 8D63 CDEC92       INPUT:     CALL     IDTEST      ; Test for illegal dire
 1693 8D66 7E                      LD       A,(HL)      ; Get character after "
 1694 8D67 FE22                    CP       '"'         ; Is there a prompt str
 1695 8D69 3E00                    LD       A,0         ; Clear A and leave fla
 1696 8D6B 324505                  LD       (CTLOFG),A  ; Enable output
 1697 8D6E C27D8D                  JP       NZ,NOPMPT   ; No prompt - get input
 1698 8D71 CD4093                  CALL     QTSTR       ; Get string terminated
 1699 8D74 CDA288                  CALL     CHKSYN      ; Check for ';' after p
 1700 8D77 3B                      DB       ';'
 1701 8D78 E5                      PUSH     HL          ; Save code string addr
 1702 8D79 CD8493                  CALL     PRS1        ; Output prompt string
 1703 8D7C 3E                      DB       3EH         ; Skip "PUSH HL"
 1704 8D7D E5           NOPMPT:    PUSH     HL          ; Save code string addr
 1705 8D7E CD2387                  CALL     PROMPT      ; Get input with "? " p
 1706 8D81 C1                      POP      BC          ; Restore code string a
 1707 8D82 DA898A                  JP       C,INPBRK    ; Break pressed - Exit
 1708 8D85 23                      INC      HL          ; Next byte
 1709 8D86 7E                      LD       A,(HL)      ; Get it
 1710 8D87 B7                      OR       A           ; End of line?
 1711 8D88 2B                      DEC      HL          ; Back again
 1712 8D89 C5                      PUSH     BC          ; Re-save code string a
 1713 8D8A CAD08B                  JP       Z,NXTDTA    ; Yes - Find next DATA 
 1714 8D8D 362C                    LD       (HL),','    ; Store comma as separa
 1715 8D8F C3978D                  JP       NXTITM      ; Get next item
 1716                   ;
 1717 8D92 E5           READ:      PUSH     HL          ; Save code string addr
 1718 8D93 2ADC05                  LD       HL,(NXTDAT) ; Next DATA statement
 1719 8D96 F6                      DB       0F6H        ; Flag "READ"
 1720 8D97 AF           NXTITM:    XOR      A           ; Flag "INPUT"
 1721 8D98 32CD05                  LD       (READFG),A  ; Save "READ"/"INPUT" f
 1722 8D9B E3                      EX       (SP),HL     ; Get code str' , Save 
 1723 8D9C C3A38D                  JP       GTVLUS      ; Get values
 1724                   ;
 1725 8D9F CDA288       NEDMOR:    CALL     CHKSYN      ; Check for comma betwe
 1726 8DA2 2C                      DB       ','
 1727 8DA3 CD9E90       GTVLUS:    CALL     GETVAR      ; Get variable name
 1728 8DA6 E3                      EX       (SP),HL     ; Save code str" , Get 
 1729 8DA7 D5                      PUSH     DE          ; Save variable address
 1730 8DA8 7E                      LD       A,(HL)      ; Get next "INPUT"/"DAT
 1731 8DA9 FE2C                    CP       ','         ; Comma?
 1732 8DAB CACB8D                  JP       Z,ANTVLU    ; Yes - Get another val
 1733 8DAE 3ACD05                  LD       A,(READFG)  ; Is it READ?
 1734 8DB1 B7                      OR       A
 1735 8DB2 C2388E                  JP       NZ,FDTLP    ; Yes - Find next DATA 
 1736 8DB5 3E3F                    LD       A,'?'       ; More INPUT needed
 1737 8DB7 CDAD88                  CALL     OUTC        ; Output character
 1738 8DBA CD2387                  CALL     PROMPT      ; Get INPUT with prompt
 1739 8DBD D1                      POP      DE          ; Variable address
 1740 8DBE C1                      POP      BC          ; Code string address
 1741 8DBF DA898A                  JP       C,INPBRK    ; Break pressed
 1742 8DC2 23                      INC      HL          ; Point to next DATA by
 1743 8DC3 7E                      LD       A,(HL)      ; Get byte
 1744 8DC4 B7                      OR       A           ; Is it zero (No input)
 1745 8DC5 2B                      DEC      HL          ; Back space INPUT poin
 1746 8DC6 C5                      PUSH     BC          ; Save code string addr
 1747 8DC7 CAD08B                  JP       Z,NXTDTA    ; Find end of buffer
 1748 8DCA D5                      PUSH     DE          ; Save variable address
 1749 8DCB 3AAD05       ANTVLU:    LD       A,(TYPE)    ; Check data type
 1750 8DCE B7                      OR       A           ; Is it numeric?
 1751 8DCF CAF58D                  JP       Z,INPBIN    ; Yes - Convert to bina
 1752 8DD2 CD308A                  CALL     GETCHR      ; Get next character
 1753 8DD5 57                      LD       D,A         ; Save input character
 1754 8DD6 47                      LD       B,A         ; Again
 1755 8DD7 FE22                    CP       '"'         ; Start of literal stin
 1756 8DD9 CAE98D                  JP       Z,STRENT    ; Yes - Create string e
 1757 8DDC 3ACD05                  LD       A,(READFG)  ; "READ" or "INPUT" ?
 1758 8DDF B7                      OR       A
 1759 8DE0 57                      LD       D,A         ; Save 00 if "INPUT"
 1760 8DE1 CAE68D                  JP       Z,ITMSEP    ; "INPUT" - End with 00
 1761 8DE4 163A                    LD       D,':'       ; "DATA" - End with 00 
 1762 8DE6 062C         ITMSEP:    LD       B,','       ; Item separator
 1763 8DE8 2B                      DEC      HL          ; Back space for DTSTR
 1764 8DE9 CD4393       STRENT:    CALL     DTSTR       ; Get string terminated
 1765 8DEC EB                      EX       DE,HL       ; String address to DE
 1766 8DED 21008E                  LD       HL,LTSTND   ; Where to go after LET
 1767 8DF0 E3                      EX       (SP),HL     ; Save HL , get input p
 1768 8DF1 D5                      PUSH     DE          ; Save address of strin
 1769 8DF2 C3038C                  JP       LETSTR      ; Assign string to vari
 1770                   ;
 1771 8DF5 CD308A       INPBIN:    CALL     GETCHR      ; Get next character
 1772 8DF8 CD9399                  CALL     ASCTFP      ; Convert ASCII to FP n
 1773 8DFB E3                      EX       (SP),HL     ; Save input ptr, Get v
 1774 8DFC CDE498                  CALL     FPTHL       ; Move FPREG to variabl
 1775 8DFF E1                      POP      HL          ; Restore input pointer
 1776 8E00 2B           LTSTND:    DEC      HL          ; DEC 'cos GETCHR INCs
 1777 8E01 CD308A                  CALL     GETCHR      ; Get next character
 1778 8E04 CA0C8E                  JP       Z,MORDT     ; End of line - More ne
 1779 8E07 FE2C                    CP       ','         ; Another value?
 1780 8E09 C2528D                  JP       NZ,BADINP   ; No - Bad input
 1781 8E0C E3           MORDT:     EX       (SP),HL     ; Get code string addre
 1782 8E0D 2B                      DEC      HL          ; DEC 'cos GETCHR INCs
 1783 8E0E CD308A                  CALL     GETCHR      ; Get next character
 1784 8E11 C29F8D                  JP       NZ,NEDMOR   ; More needed - Get it
 1785 8E14 D1                      POP      DE          ; Restore DATA pointer
 1786 8E15 3ACD05                  LD       A,(READFG)  ; "READ" or "INPUT" ?
 1787 8E18 B7                      OR       A
 1788 8E19 EB                      EX       DE,HL       ; DATA pointer to HL
 1789 8E1A C2568A                  JP       NZ,UPDATA   ; Update DATA pointer i
 1790 8E1D D5                      PUSH     DE          ; Save code string addr
 1791 8E1E B6                      OR       (HL)        ; More input given?
 1792 8E1F 21278E                  LD       HL,EXTIG    ; "?Extra ignored" mess
 1793 8E22 C48193                  CALL     NZ,PRS      ; Output string if extr
 1794 8E25 E1                      POP      HL          ; Restore code string a
 1795 8E26 C9                      RET
 1796                   ;
 1797 8E27 3F4578747261 EXTIG:     DB       "?Extra ignored",CR,LF,0
           2069676E6F72 
           65640D0A00   
 1798                   ;
 1799 8E38 CDD18B       FDTLP:     CALL     DATA        ; Get next statement
 1800 8E3B B7                      OR       A           ; End of line?
 1801 8E3C C2518E                  JP       NZ,FANDT    ; No - See if DATA stat
 1802 8E3F 23                      INC      HL
 1803 8E40 7E                      LD       A,(HL)      ; End of program?
 1804 8E41 23                      INC      HL
 1805 8E42 B6                      OR       (HL)        ; 00 00 Ends program
 1806 8E43 1E06                    LD       E,OD        ; ?OD Error
 1807 8E45 CAE885                  JP       Z,ERROR     ; Yes - Out of DATA
 1808 8E48 23                      INC      HL
 1809 8E49 5E                      LD       E,(HL)      ; LSB of line number
 1810 8E4A 23                      INC      HL
 1811 8E4B 56                      LD       D,(HL)      ; MSB of line number
 1812 8E4C EB                      EX       DE,HL
 1813 8E4D 22C905                  LD       (DATLIN),HL ; Set line of current D
 1814 8E50 EB                      EX       DE,HL
 1815 8E51 CD308A       FANDT:     CALL     GETCHR      ; Get next character
 1816 8E54 FE83                    CP       ZDATA       ; "DATA" token
 1817 8E56 C2388E                  JP       NZ,FDTLP    ; No "DATA" - Keep look
 1818 8E59 C3CB8D                  JP       ANTVLU      ; Found - Convert input
 1819                   ;
 1820 8E5C 110000       NEXT:      LD       DE,0        ; In case no index give
 1821 8E5F C49E90       NEXT1:     CALL     NZ,GETVAR   ; Get index address
 1822 8E62 22CE05                  LD       (BRKLIN),HL ; Save code string addr
 1823 8E65 CD7D85                  CALL     BAKSTK      ; Look for "FOR" block
 1824 8E68 C2DA85                  JP       NZ,NFERR    ; No "FOR" - ?NF Error
 1825 8E6B F9                      LD       SP,HL       ; Clear nested loops
 1826 8E6C D5                      PUSH     DE          ; Save index address
 1827 8E6D 7E                      LD       A,(HL)      ; Get sign of STEP
 1828 8E6E 23                      INC      HL
 1829 8E6F F5                      PUSH     AF          ; Save sign of STEP
 1830 8E70 D5                      PUSH     DE          ; Save index address
 1831 8E71 CDCA98                  CALL     PHLTFP      ; Move index value to F
 1832 8E74 E3                      EX       (SP),HL     ; Save address of TO va
 1833 8E75 E5                      PUSH     HL          ; Save address of index
 1834 8E76 CD3796                  CALL     ADDPHL      ; Add STEP to index val
 1835 8E79 E1                      POP      HL          ; Restore address of in
 1836 8E7A CDE498                  CALL     FPTHL       ; Move value to index v
 1837 8E7D E1                      POP      HL          ; Restore address of TO
 1838 8E7E CDDB98                  CALL     LOADFP      ; Move TO value to BCDE
 1839 8E81 E5                      PUSH     HL          ; Save address of line 
 1840 8E82 CD0799                  CALL     CMPNUM      ; Compare index with TO
 1841 8E85 E1                      POP      HL          ; Restore address of li
 1842 8E86 C1                      POP      BC          ; Address of sign of ST
 1843 8E87 90                      SUB      B           ; Compare with expected
 1844 8E88 CDDB98                  CALL     LOADFP      ; BC = Loop stmt,DE = L
 1845 8E8B CA978E                  JP       Z,KILFOR    ; Loop finished - Termi
 1846 8E8E EB                      EX       DE,HL       ; Loop statement line n
 1847 8E8F 225C05                  LD       (LINEAT),HL ; Set loop line number
 1848 8E92 69                      LD       L,C         ; Set code string to lo
 1849 8E93 60                      LD       H,B
 1850 8E94 C3EC89                  JP       PUTFID      ; Put back "FOR" and co
 1851                   ;
 1852 8E97 F9           KILFOR:    LD       SP,HL       ; Remove "FOR" block
 1853 8E98 2ACE05                  LD       HL,(BRKLIN) ; Code string after "NE
 1854 8E9B 7E                      LD       A,(HL)      ; Get next byte in code
 1855 8E9C FE2C                    CP       ','         ; More NEXTs ?
 1856 8E9E C2F089                  JP       NZ,RUNCNT   ; No - Do next statemen
 1857 8EA1 CD308A                  CALL     GETCHR      ; Position to index nam
 1858 8EA4 CD5F8E                  CALL     NEXT1       ; Re-enter NEXT routine
 1859                   ; < will not RETurn to here , Exit to RUNCNT or Loop >
 1860                   ;
 1861 8EA7 CDB98E       GETNUM:    CALL     EVAL        ; Get a numeric express
 1862 8EAA F6           TSTNUM:    DB       0F6H        ; Clear carry (numeric)
 1863 8EAB 37           TSTSTR:    SCF                  ; Set carry (string)
 1864 8EAC 3AAD05       CHKTYP:    LD       A,(TYPE)    ; Check types match
 1865 8EAF 8F                      ADC      A,A         ; Expected + actual
 1866 8EB0 B7                      OR       A           ; Clear carry , set par
 1867 8EB1 E8                      RET      PE          ; Even parity - Types m
 1868 8EB2 C3E685                  JP       TMERR       ; Different types - Err
 1869                   ;
 1870 8EB5 CDA288       OPNPAR:    CALL     CHKSYN      ; Make sure "(" follows
 1871 8EB8 28                      DB       "("
 1872 8EB9 2B           EVAL:      DEC      HL          ; Evaluate expression &
 1873 8EBA 1600                    LD       D,0         ; Precedence value
 1874 8EBC D5           EVAL1:     PUSH     DE          ; Save precedence
 1875 8EBD 0E01                    LD       C,1
 1876 8EBF CDB185                  CALL     CHKSTK      ; Check for 1 level of 
 1877 8EC2 CD308F                  CALL     OPRND       ; Get next expression v
 1878 8EC5 22D005       EVAL2:     LD       (NXTOPR),HL ; Save address of next 
 1879 8EC8 2AD005       EVAL3:     LD       HL,(NXTOPR) ; Restore address of ne
 1880 8ECB C1                      POP      BC          ; Precedence value and 
 1881 8ECC 78                      LD       A,B         ; Get precedence value
 1882 8ECD FE78                    CP       78H         ; "AND" or "OR" ?
 1883 8ECF D4AA8E                  CALL     NC,TSTNUM   ; No - Make sure it's a
 1884 8ED2 7E                      LD       A,(HL)      ; Get next operator / f
 1885 8ED3 1600                    LD       D,0         ; Clear Last relation
 1886 8ED5 D6B3         RLTLP:     SUB      ZGTR        ; ">" Token
 1887 8ED7 DAF18E                  JP       C,FOPRND    ; + - * / ^ AND OR - Te
 1888 8EDA FE03                    CP       ZLTH+1-ZGTR ; < = >
 1889 8EDC D2F18E                  JP       NC,FOPRND   ; Function - Call it
 1890 8EDF FE01                    CP       ZEQUAL-ZGTR ; "="
 1891 8EE1 17                      RLA                  ; <- Test for legal
 1892 8EE2 AA                      XOR      D           ; <- combinations of < 
 1893 8EE3 BA                      CP       D           ; <- by combining last 
 1894 8EE4 57                      LD       D,A         ; <- with current one
 1895 8EE5 DAD485                  JP       C,SNERR     ; Error if "<<' '==" or
 1896 8EE8 22C505                  LD       (CUROPR),HL ; Save address of curre
 1897 8EEB CD308A                  CALL     GETCHR      ; Get next character
 1898 8EEE C3D58E                  JP       RLTLP       ; Treat the two as one
 1899                   ;
 1900 8EF1 7A           FOPRND:    LD       A,D         ; < = > found ?
 1901 8EF2 B7                      OR       A
 1902 8EF3 C21990                  JP       NZ,TSTRED   ; Yes - Test for reduct
 1903 8EF6 7E                      LD       A,(HL)      ; Get operator token
 1904 8EF7 22C505                  LD       (CUROPR),HL ; Save operator address
 1905 8EFA D6AC                    SUB      ZPLUS       ; Operator or function?
 1906 8EFC D8                      RET      C           ; Neither - Exit
 1907 8EFD FE07                    CP       ZOR+1-ZPLUS ; Is it + - * / ^ AND O
 1908 8EFF D0                      RET      NC          ; No - Exit
 1909 8F00 5F                      LD       E,A         ; Coded operator
 1910 8F01 3AAD05                  LD       A,(TYPE)    ; Get data type
 1911 8F04 3D                      DEC      A           ; FF = numeric , 00 = s
 1912 8F05 B3                      OR       E           ; Combine with coded op
 1913 8F06 7B                      LD       A,E         ; Get coded operator
 1914 8F07 CA7794                  JP       Z,CONCAT    ; String concatenation
 1915 8F0A 07                      RLCA                 ; Times 2
 1916 8F0B 83                      ADD      A,E         ; Times 3
 1917 8F0C 5F                      LD       E,A         ; To DE (D is 0)
 1918 8F0D 21C684                  LD       HL,PRITAB   ; Precedence table
 1919 8F10 19                      ADD      HL,DE       ; To the operator conce
 1920 8F11 78                      LD       A,B         ; Last operator precede
 1921 8F12 56                      LD       D,(HL)      ; Get evaluation preced
 1922 8F13 BA                      CP       D           ; Compare with eval pre
 1923 8F14 D0                      RET      NC          ; Exit if higher preced
 1924 8F15 23                      INC      HL          ; Point to routine addr
 1925 8F16 CDAA8E                  CALL     TSTNUM      ; Make sure it's a numb
 1926                   ;
 1927 8F19 C5           STKTHS:    PUSH     BC          ; Save last precedence 
 1928 8F1A 01C88E                  LD       BC,EVAL3    ; Where to go on prec' 
 1929 8F1D C5                      PUSH     BC          ; Save on stack for ret
 1930 8F1E 43                      LD       B,E         ; Save operator
 1931 8F1F 4A                      LD       C,D         ; Save precedence
 1932 8F20 CDBD98                  CALL     STAKFP      ; Move value to stack
 1933 8F23 58                      LD       E,B         ; Restore operator
 1934 8F24 51                      LD       D,C         ; Restore precedence
 1935 8F25 4E                      LD       C,(HL)      ; Get LSB of routine ad
 1936 8F26 23                      INC      HL
 1937 8F27 46                      LD       B,(HL)      ; Get MSB of routine ad
 1938 8F28 23                      INC      HL
 1939 8F29 C5                      PUSH     BC          ; Save routine address
 1940 8F2A 2AC505                  LD       HL,(CUROPR) ; Address of current op
 1941 8F2D C3BC8E                  JP       EVAL1       ; Loop until prec' brea
 1942                   ;
 1943 8F30 AF           OPRND:     XOR      A           ; Get operand routine
 1944 8F31 32AD05                  LD       (TYPE),A    ; Set numeric expected
 1945 8F34 CD308A                  CALL     GETCHR      ; Get next character
 1946 8F37 1E24                    LD       E,MO        ; ?MO Error
 1947 8F39 CAE885                  JP       Z,ERROR     ; No operand - Error
 1948 8F3C DA9399                  JP       C,ASCTFP    ; Number - Get value
 1949 8F3F CDD88A                  CALL     CHKLTR      ; See if a letter
 1950 8F42 D2988F                  JP       NC,CONVAR   ; Letter - Find variabl
 1951 8F45 FE26                    CP       '&'         ; &H = HEX, &B = BINARY
 1952 8F47 C25C8F                  JP       NZ, NOTAMP
 1953 8F4A CD308A                  CALL     GETCHR      ; Get next character
 1954 8F4D FE48                    CP       'H'         ; Hex number indicated?
 1955 8F4F CADD9D                  JP       Z,HEXTFP    ; Convert Hex to FPREG
 1956 8F52 FE42                    CP       'B'         ; Binary number indicat
 1957 8F54 CA599E                  JP       Z,BINTFP    ; Convert Bin to FPREG
 1958 8F57 1E02                    LD       E,SN        ; If neither then a ?SN
 1959 8F59 CAE885                  JP       Z,ERROR
 1960 8F5C FEAC         NOTAMP:    CP       ZPLUS       ; '+' Token ?
 1961 8F5E CA308F                  JP       Z,OPRND     ; Yes - Look for operan
 1962 8F61 FE2E                    CP       '.'         ; '.' ?
 1963 8F63 CA9399                  JP       Z,ASCTFP    ; Yes - Create FP numbe
 1964 8F66 FEAD                    CP       ZMINUS      ; '-' Token ?
 1965 8F68 CA878F                  JP       Z,MINUS     ; Yes - Do minus
 1966 8F6B FE22                    CP       '"'         ; Literal string ?
 1967 8F6D CA4093                  JP       Z,QTSTR     ; Get string terminated
 1968 8F70 FEAA                    CP       ZNOT        ; "NOT" Token ?
 1969 8F72 CA7990                  JP       Z,EVNOT     ; Yes - Eval NOT expres
 1970 8F75 FEA7                    CP       ZFN         ; "FN" Token ?
 1971 8F77 CAA492                  JP       Z,DOFN      ; Yes - Do FN routine
 1972 8F7A D6B6                    SUB      ZSGN        ; Is it a function?
 1973 8F7C D2A98F                  JP       NC,FNOFST   ; Yes - Evaluate functi
 1974 8F7F CDB58E       EVLPAR:    CALL     OPNPAR      ; Evaluate expression i
 1975 8F82 CDA288                  CALL     CHKSYN      ; Make sure ")" follows
 1976 8F85 29                      DB       ")"
 1977 8F86 C9                      RET
 1978                   ;
 1979 8F87 167D         MINUS:     LD       D,7DH       ; '-' precedence
 1980 8F89 CDBC8E                  CALL     EVAL1       ; Evaluate until prec' 
 1981 8F8C 2AD005                  LD       HL,(NXTOPR) ; Get next operator add
 1982 8F8F E5                      PUSH     HL          ; Save next operator ad
 1983 8F90 CDB598                  CALL     INVSGN      ; Negate value
 1984 8F93 CDAA8E       RETNUM:    CALL     TSTNUM      ; Make sure it's a numb
 1985 8F96 E1                      POP      HL          ; Restore next operator
 1986 8F97 C9                      RET
 1987                   ;
 1988 8F98 CD9E90       CONVAR:    CALL     GETVAR      ; Get variable address 
 1989 8F9B E5           FRMEVL:    PUSH     HL          ; Save code string addr
 1990 8F9C EB                      EX       DE,HL       ; Variable address to H
 1991 8F9D 22E405                  LD       (FPREG),HL  ; Save address of varia
 1992 8FA0 3AAD05                  LD       A,(TYPE)    ; Get type
 1993 8FA3 B7                      OR       A           ; Numeric?
 1994 8FA4 CCCA98                  CALL     Z,PHLTFP    ; Yes - Move contents t
 1995 8FA7 E1                      POP      HL          ; Restore code string a
 1996 8FA8 C9                      RET
 1997                   ;
 1998 8FA9 0600         FNOFST:    LD       B,0         ; Get address of functi
 1999 8FAB 07                      RLCA                 ; Double function offse
 2000 8FAC 4F                      LD       C,A         ; BC = Offset in functi
 2001 8FAD C5                      PUSH     BC          ; Save adjusted token v
 2002 8FAE CD308A                  CALL     GETCHR      ; Get next character
 2003 8FB1 79                      LD       A,C         ; Get adjusted token va
 2004 8FB2 FE31                    CP       2*(ZLEFT-ZSGN)-1 ; Adj' LEFT$,RIGHT
 2005 8FB4 DAD08F                  JP       C,FNVAL     ; No - Do function
 2006 8FB7 CDB58E                  CALL     OPNPAR      ; Evaluate expression  
 2007 8FBA CDA288                  CALL     CHKSYN      ; Make sure ',' follows
 2008 8FBD 2C                      DB       ','
 2009 8FBE CDAB8E                  CALL     TSTSTR      ; Make sure it's a stri
 2010 8FC1 EB                      EX       DE,HL       ; Save code string addr
 2011 8FC2 2AE405                  LD       HL,(FPREG)  ; Get address of string
 2012 8FC5 E3                      EX       (SP),HL     ; Save address of strin
 2013 8FC6 E5                      PUSH     HL          ; Save adjusted token v
 2014 8FC7 EB                      EX       DE,HL       ; Restore code string a
 2015 8FC8 CD0B96                  CALL     GETINT      ; Get integer 0-255
 2016 8FCB EB                      EX       DE,HL       ; Save code string addr
 2017 8FCC E3                      EX       (SP),HL     ; Save integer,HL = adj
 2018 8FCD C3D88F                  JP       GOFUNC      ; Jump to string functi
 2019                   ;
 2020 8FD0 CD7F8F       FNVAL:     CALL     EVLPAR      ; Evaluate expression
 2021 8FD3 E3                      EX       (SP),HL     ; HL = Adjusted token v
 2022 8FD4 11938F                  LD       DE,RETNUM   ; Return number from fu
 2023 8FD7 D5                      PUSH     DE          ; Save on stack
 2024 8FD8 012583       GOFUNC:    LD       BC,FNCTAB   ; Function routine addr
 2025 8FDB 09                      ADD      HL,BC       ; Point to right addres
 2026 8FDC 4E                      LD       C,(HL)      ; Get LSB of address
 2027 8FDD 23                      INC      HL          ;
 2028 8FDE 66                      LD       H,(HL)      ; Get MSB of address
 2029 8FDF 69                      LD       L,C         ; Address to HL
 2030 8FE0 E9                      JP       (HL)        ; Jump to function
 2031                   ;
 2032 8FE1 15           SGNEXP:    DEC      D           ; Dee to flag negative 
 2033 8FE2 FEAD                    CP       ZMINUS      ; '-' token ?
 2034 8FE4 C8                      RET      Z           ; Yes - Return
 2035 8FE5 FE2D                    CP       '-'         ; '-' ASCII ?
 2036 8FE7 C8                      RET      Z           ; Yes - Return
 2037 8FE8 14                      INC      D           ; Inc to flag positive 
 2038 8FE9 FE2B                    CP       '+'         ; '+' ASCII ?
 2039 8FEB C8                      RET      Z           ; Yes - Return
 2040 8FEC FEAC                    CP       ZPLUS       ; '+' token ?
 2041 8FEE C8                      RET      Z           ; Yes - Return
 2042 8FEF 2B                      DEC      HL          ; DEC 'cos GETCHR INCs
 2043 8FF0 C9                      RET                  ; Return "NZ"
 2044                   ;
 2045 8FF1 F6           POR:       DB       0F6H        ; Flag "OR"
 2046 8FF2 AF           PAND:      XOR      A           ; Flag "AND"
 2047 8FF3 F5                      PUSH     AF          ; Save "AND" / "OR" fla
 2048 8FF4 CDAA8E                  CALL     TSTNUM      ; Make sure it's a numb
 2049 8FF7 CDEC8A                  CALL     DEINT       ; Get integer -32768 to
 2050 8FFA F1                      POP      AF          ; Restore "AND" / "OR" 
 2051 8FFB EB                      EX       DE,HL       ; <- Get last
 2052 8FFC C1                      POP      BC          ; <- value
 2053 8FFD E3                      EX       (SP),HL     ; <- from
 2054 8FFE EB                      EX       DE,HL       ; <- stack
 2055 8FFF CDCD98                  CALL     FPBCDE      ; Move last value to FP
 2056 9002 F5                      PUSH     AF          ; Save "AND" / "OR" fla
 2057 9003 CDEC8A                  CALL     DEINT       ; Get integer -32768 to
 2058 9006 F1                      POP      AF          ; Restore "AND" / "OR" 
 2059 9007 C1                      POP      BC          ; Get value
 2060 9008 79                      LD       A,C         ; Get LSB
 2061 9009 216292                  LD       HL,ACPASS   ; Address of save AC as
 2062 900C C21490                  JP       NZ,POR1     ; Jump if OR
 2063 900F A3                      AND      E           ; "AND" LSBs
 2064 9010 4F                      LD       C,A         ; Save LSB
 2065 9011 78                      LD       A,B         ; Get MBS
 2066 9012 A2                      AND      D           ; "AND" MSBs
 2067 9013 E9                      JP       (HL)        ; Save AC as current (A
 2068                   ;
 2069 9014 B3           POR1:      OR       E           ; "OR" LSBs
 2070 9015 4F                      LD       C,A         ; Save LSB
 2071 9016 78                      LD       A,B         ; Get MSB
 2072 9017 B2                      OR       D           ; "OR" MSBs
 2073 9018 E9                      JP       (HL)        ; Save AC as current (A
 2074                   ;
 2075 9019 212B90       TSTRED:    LD       HL,CMPLOG   ; Logical compare routi
 2076 901C 3AAD05                  LD       A,(TYPE)    ; Get data type
 2077 901F 1F                      RRA                  ; Carry set = string
 2078 9020 7A                      LD       A,D         ; Get last precedence v
 2079 9021 17                      RLA                  ; Times 2 plus carry
 2080 9022 5F                      LD       E,A         ; To E
 2081 9023 1664                    LD       D,64H       ; Relational precedence
 2082 9025 78                      LD       A,B         ; Get current precedenc
 2083 9026 BA                      CP       D           ; Compare with last
 2084 9027 D0                      RET      NC          ; Eval if last was rel'
 2085 9028 C3198F                  JP       STKTHS      ; Stack this one and ge
 2086                   ;
 2087 902B 2D90         CMPLOG:    DW       CMPLG1      ; Compare two values / 
 2088 902D 79           CMPLG1:    LD       A,C         ; Get data type
 2089 902E B7                      OR       A
 2090 902F 1F                      RRA
 2091 9030 C1                      POP      BC          ; Get last expression t
 2092 9031 D1                      POP      DE
 2093 9032 F5                      PUSH     AF          ; Save status
 2094 9033 CDAC8E                  CALL     CHKTYP      ; Check that types matc
 2095 9036 216F90                  LD       HL,CMPRES   ; Result to comparison
 2096 9039 E5                      PUSH     HL          ; Save for RETurn
 2097 903A CA0799                  JP       Z,CMPNUM    ; Compare values if num
 2098 903D AF                      XOR      A           ; Compare two strings
 2099 903E 32AD05                  LD       (TYPE),A    ; Set type to numeric
 2100 9041 D5                      PUSH     DE          ; Save string name
 2101 9042 CDC494                  CALL     GSTRCU      ; Get current string
 2102 9045 7E                      LD       A,(HL)      ; Get length of string
 2103 9046 23                      INC      HL
 2104 9047 23                      INC      HL
 2105 9048 4E                      LD       C,(HL)      ; Get LSB of address
 2106 9049 23                      INC      HL
 2107 904A 46                      LD       B,(HL)      ; Get MSB of address
 2108 904B D1                      POP      DE          ; Restore string name
 2109 904C C5                      PUSH     BC          ; Save address of strin
 2110 904D F5                      PUSH     AF          ; Save length of string
 2111 904E CDC894                  CALL     GSTRDE      ; Get second string
 2112 9051 CDDB98                  CALL     LOADFP      ; Get address of second
 2113 9054 F1                      POP      AF          ; Restore length of str
 2114 9055 57                      LD       D,A         ; Length to D
 2115 9056 E1                      POP      HL          ; Restore address of st
 2116 9057 7B           CMPSTR:    LD       A,E         ; Bytes of string 2 to 
 2117 9058 B2                      OR       D           ; Bytes of string 1 to 
 2118 9059 C8                      RET      Z           ; Exit if all bytes com
 2119 905A 7A                      LD       A,D         ; Get bytes of string 1
 2120 905B D601                    SUB      1
 2121 905D D8                      RET      C           ; Exit if end of string
 2122 905E AF                      XOR      A
 2123 905F BB                      CP       E           ; Bytes of string 2 to 
 2124 9060 3C                      INC      A
 2125 9061 D0                      RET      NC          ; Exit if end of string
 2126 9062 15                      DEC      D           ; Count bytes in string
 2127 9063 1D                      DEC      E           ; Count bytes in string
 2128 9064 0A                      LD       A,(BC)      ; Byte in string 2
 2129 9065 BE                      CP       (HL)        ; Compare to byte in st
 2130 9066 23                      INC      HL          ; Move up string 1
 2131 9067 03                      INC      BC          ; Move up string 2
 2132 9068 CA5790                  JP       Z,CMPSTR    ; Same - Try next bytes
 2133 906B 3F                      CCF                  ; Flag difference (">" 
 2134 906C C39798                  JP       FLGDIF      ; "<" gives -1 , ">" gi
 2135                   ;
 2136 906F 3C           CMPRES:    INC      A           ; Increment current val
 2137 9070 8F                      ADC      A,A         ; Double plus carry
 2138 9071 C1                      POP      BC          ; Get other value
 2139 9072 A0                      AND      B           ; Combine them
 2140 9073 C6FF                    ADD      A,-1        ; Carry set if differen
 2141 9075 9F                      SBC      A,A         ; 00 - Equal , FF - Dif
 2142 9076 C39E98                  JP       FLGREL      ; Set current value & c
 2143                   ;
 2144 9079 165A         EVNOT:     LD       D,5AH       ; Precedence value for 
 2145 907B CDBC8E                  CALL     EVAL1       ; Eval until precedence
 2146 907E CDAA8E                  CALL     TSTNUM      ; Make sure it's a numb
 2147 9081 CDEC8A                  CALL     DEINT       ; Get integer -32768 - 
 2148 9084 7B                      LD       A,E         ; Get LSB
 2149 9085 2F                      CPL                  ; Invert LSB
 2150 9086 4F                      LD       C,A         ; Save "NOT" of LSB
 2151 9087 7A                      LD       A,D         ; Get MSB
 2152 9088 2F                      CPL                  ; Invert MSB
 2153 9089 CD6292                  CALL     ACPASS      ; Save AC as current
 2154 908C C1                      POP      BC          ; Clean up stack
 2155 908D C3C88E                  JP       EVAL3       ; Continue evaluation
 2156                   ;
 2157 9090 2B           DIMRET:    DEC      HL          ; DEC 'cos GETCHR INCs
 2158 9091 CD308A                  CALL     GETCHR      ; Get next character
 2159 9094 C8                      RET      Z           ; End of DIM statement
 2160 9095 CDA288                  CALL     CHKSYN      ; Make sure ',' follows
 2161 9098 2C                      DB       ','
 2162 9099 019090       DIM:       LD       BC,DIMRET   ; Return to "DIMRET"
 2163 909C C5                      PUSH     BC          ; Save on stack
 2164 909D F6                      DB       0F6H        ; Flag "Create" variabl
 2165 909E AF           GETVAR:    XOR      A           ; Find variable address
 2166 909F 32AC05                  LD       (LCRFLG),A  ; Set locate / create f
 2167 90A2 46                      LD       B,(HL)      ; Get First byte of nam
 2168 90A3 CDD88A       GTFNAM:    CALL     CHKLTR      ; See if a letter
 2169 90A6 DAD485                  JP       C,SNERR     ; ?SN Error if not a le
 2170 90A9 AF                      XOR      A
 2171 90AA 4F                      LD       C,A         ; Clear second byte of 
 2172 90AB 32AD05                  LD       (TYPE),A    ; Set type to numeric
 2173 90AE CD308A                  CALL     GETCHR      ; Get next character
 2174 90B1 DABA90                  JP       C,SVNAM2    ; Numeric - Save in nam
 2175 90B4 CDD88A                  CALL     CHKLTR      ; See if a letter
 2176 90B7 DAC790                  JP       C,CHARTY    ; Not a letter - Check 
 2177 90BA 4F           SVNAM2:    LD       C,A         ; Save second byte of n
 2178 90BB CD308A       ENDNAM:    CALL     GETCHR      ; Get next character
 2179 90BE DABB90                  JP       C,ENDNAM    ; Numeric - Get another
 2180 90C1 CDD88A                  CALL     CHKLTR      ; See if a letter
 2181 90C4 D2BB90                  JP       NC,ENDNAM   ; Letter - Get another
 2182 90C7 D624         CHARTY:    SUB      '$'         ; String variable?
 2183 90C9 C2D690                  JP       NZ,NOTSTR   ; No - Numeric variable
 2184 90CC 3C                      INC      A           ; A = 1 (string type)
 2185 90CD 32AD05                  LD       (TYPE),A    ; Set type to string
 2186 90D0 0F                      RRCA                 ; A = 80H , Flag for st
 2187 90D1 81                      ADD      A,C         ; 2nd byte of name has 
 2188 90D2 4F                      LD       C,A         ; Resave second byte on
 2189 90D3 CD308A                  CALL     GETCHR      ; Get next character
 2190 90D6 3ACB05       NOTSTR:    LD       A,(FORFLG)  ; Array name needed ?
 2191 90D9 3D                      DEC      A
 2192 90DA CA8391                  JP       Z,ARLDSV    ; Yes - Get array name
 2193 90DD F2E690                  JP       P,NSCFOR    ; No array with "FOR" o
 2194 90E0 7E                      LD       A,(HL)      ; Get byte again
 2195 90E1 D628                    SUB      '('         ; Subscripted variable?
 2196 90E3 CA5B91                  JP       Z,SBSCPT    ; Yes - Sort out subscr
 2197                   ;
 2198 90E6 AF           NSCFOR:    XOR      A           ; Simple variable
 2199 90E7 32CB05                  LD       (FORFLG),A  ; Clear "FOR" flag
 2200 90EA E5                      PUSH     HL          ; Save code string addr
 2201 90EB 50                      LD       D,B         ; DE = Variable name to
 2202 90EC 59                      LD       E,C
 2203 90ED 2ADE05                  LD       HL,(FNRGNM) ; FN argument name
 2204 90F0 CD9C88                  CALL     CPDEHL      ; Is it the FN argument
 2205 90F3 11E005                  LD       DE,FNARG    ; Point to argument val
 2206 90F6 CACD97                  JP       Z,POPHRT    ; Yes - Return FN argum
 2207 90F9 2AD805                  LD       HL,(VAREND) ; End of variables
 2208 90FC EB                      EX       DE,HL       ; Address of end of sea
 2209 90FD 2AD605                  LD       HL,(PROGND) ; Start of variables ad
 2210 9100 CD9C88       FNDVAR:    CALL     CPDEHL      ; End of variable list 
 2211 9103 CA1991                  JP       Z,CFEVAL    ; Yes - Called from EVA
 2212 9106 79                      LD       A,C         ; Get second byte of na
 2213 9107 96                      SUB      (HL)        ; Compare with name in 
 2214 9108 23                      INC      HL          ; Move on to first byte
 2215 9109 C20E91                  JP       NZ,FNTHR    ; Different - Find anot
 2216 910C 78                      LD       A,B         ; Get first byte of nam
 2217 910D 96                      SUB      (HL)        ; Compare with name in 
 2218 910E 23           FNTHR:     INC      HL          ; Move on to LSB of val
 2219 910F CA4D91                  JP       Z,RETADR    ; Found - Return addres
 2220 9112 23                      INC      HL          ; <- Skip
 2221 9113 23                      INC      HL          ; <- over
 2222 9114 23                      INC      HL          ; <- F.P.
 2223 9115 23                      INC      HL          ; <- value
 2224 9116 C30091                  JP       FNDVAR      ; Keep looking
 2225                   ;
 2226 9119 E1           CFEVAL:    POP      HL          ; Restore code string a
 2227 911A E3                      EX       (SP),HL     ; Get return address
 2228 911B D5                      PUSH     DE          ; Save address of varia
 2229 911C 119B8F                  LD       DE,FRMEVL   ; Return address in EVA
 2230 911F CD9C88                  CALL     CPDEHL      ; Called from EVAL ?
 2231 9122 D1                      POP      DE          ; Restore address of va
 2232 9123 CA5091                  JP       Z,RETNUL    ; Yes - Return null var
 2233 9126 E3                      EX       (SP),HL     ; Put back return
 2234 9127 E5                      PUSH     HL          ; Save code string addr
 2235 9128 C5                      PUSH     BC          ; Save variable name
 2236 9129 010600                  LD       BC,6        ; 2 byte name plus 4 by
 2237 912C 2ADA05                  LD       HL,(ARREND) ; End of arrays
 2238 912F E5                      PUSH     HL          ; Save end of arrays
 2239 9130 09                      ADD      HL,BC       ; Move up 6 bytes
 2240 9131 C1                      POP      BC          ; Source address in BC
 2241 9132 E5                      PUSH     HL          ; Save new end address
 2242 9133 CDA085                  CALL     MOVUP       ; Move arrays up
 2243 9136 E1                      POP      HL          ; Restore new end addre
 2244 9137 22DA05                  LD       (ARREND),HL ; Set new end address
 2245 913A 60                      LD       H,B         ; End of variables to H
 2246 913B 69                      LD       L,C
 2247 913C 22D805                  LD       (VAREND),HL ; Set new end address
 2248                   ;
 2249 913F 2B           ZEROLP:    DEC      HL          ; Back through to zero 
 2250 9140 3600                    LD       (HL),0      ; Zero byte in variable
 2251 9142 CD9C88                  CALL     CPDEHL      ; Done them all?
 2252 9145 C23F91                  JP       NZ,ZEROLP   ; No - Keep on going
 2253 9148 D1                      POP      DE          ; Get variable name
 2254 9149 73                      LD       (HL),E      ; Store second characte
 2255 914A 23                      INC      HL
 2256 914B 72                      LD       (HL),D      ; Store first character
 2257 914C 23                      INC      HL
 2258 914D EB           RETADR:    EX       DE,HL       ; Address of variable i
 2259 914E E1                      POP      HL          ; Restore code string a
 2260 914F C9                      RET
 2261                   ;
 2262 9150 32E705       RETNUL:    LD       (FPEXP),A   ; Set result to zero
 2263 9153 217085                  LD       HL,ZERBYT   ; Also set a null strin
 2264 9156 22E405                  LD       (FPREG),HL  ; Save for EVAL
 2265 9159 E1                      POP      HL          ; Restore code string a
 2266 915A C9                      RET
 2267                   ;
 2268 915B E5           SBSCPT:    PUSH     HL          ; Save code string addr
 2269 915C 2AAC05                  LD       HL,(LCRFLG) ; Locate/Create and Typ
 2270 915F E3                      EX       (SP),HL     ; Save and get code str
 2271 9160 57                      LD       D,A         ; Zero number of dimens
 2272 9161 D5           SCPTLP:    PUSH     DE          ; Save number of dimens
 2273 9162 C5                      PUSH     BC          ; Save array name
 2274 9163 CDE08A                  CALL     FPSINT      ; Get subscript (0-3276
 2275 9166 C1                      POP      BC          ; Restore array name
 2276 9167 F1                      POP      AF          ; Get number of dimensi
 2277 9168 EB                      EX       DE,HL
 2278 9169 E3                      EX       (SP),HL     ; Save subscript value
 2279 916A E5                      PUSH     HL          ; Save LCRFLG and TYPE
 2280 916B EB                      EX       DE,HL
 2281 916C 3C                      INC      A           ; Count dimensions
 2282 916D 57                      LD       D,A         ; Save in D
 2283 916E 7E                      LD       A,(HL)      ; Get next byte in code
 2284 916F FE2C                    CP       ','         ; Comma (more to come)?
 2285 9171 CA6191                  JP       Z,SCPTLP    ; Yes - More subscripts
 2286 9174 CDA288                  CALL     CHKSYN      ; Make sure ")" follows
 2287 9177 29                      DB       ")"
 2288 9178 22D005                  LD       (NXTOPR),HL ; Save code string addr
 2289 917B E1                      POP      HL          ; Get LCRFLG and TYPE
 2290 917C 22AC05                  LD       (LCRFLG),HL ; Restore Locate/create
 2291 917F 1E00                    LD       E,0         ; Flag not CSAVE* or CL
 2292 9181 D5                      PUSH     DE          ; Save number of dimens
 2293 9182 11                      DB       11H         ; Skip "PUSH HL" and "P
 2294                   ;
 2295 9183 E5           ARLDSV:    PUSH     HL          ; Save code string addr
 2296 9184 F5                      PUSH     AF          ; A = 00 , Flags set = 
 2297 9185 2AD805                  LD       HL,(VAREND) ; Start of arrays
 2298 9188 3E                      DB       3EH         ; Skip "ADD HL,DE"
 2299 9189 19           FNDARY:    ADD      HL,DE       ; Move to next array st
 2300 918A EB                      EX       DE,HL
 2301 918B 2ADA05                  LD       HL,(ARREND) ; End of arrays
 2302 918E EB                      EX       DE,HL       ; Current array pointer
 2303 918F CD9C88                  CALL     CPDEHL      ; End of arrays found?
 2304 9192 CABB91                  JP       Z,CREARY    ; Yes - Create array
 2305 9195 7E                      LD       A,(HL)      ; Get second byte of na
 2306 9196 B9                      CP       C           ; Compare with name giv
 2307 9197 23                      INC      HL          ; Move on
 2308 9198 C29D91                  JP       NZ,NXTARY   ; Different - Find next
 2309 919B 7E                      LD       A,(HL)      ; Get first byte of nam
 2310 919C B8                      CP       B           ; Compare with name giv
 2311 919D 23           NXTARY:    INC      HL          ; Move on
 2312 919E 5E                      LD       E,(HL)      ; Get LSB of next array
 2313 919F 23                      INC      HL
 2314 91A0 56                      LD       D,(HL)      ; Get MSB of next array
 2315 91A1 23                      INC      HL
 2316 91A2 C28991                  JP       NZ,FNDARY   ; Not found - Keep look
 2317 91A5 3AAC05                  LD       A,(LCRFLG)  ; Found Locate or Creat
 2318 91A8 B7                      OR       A
 2319 91A9 C2DD85                  JP       NZ,DDERR    ; Create - ?DD Error
 2320 91AC F1                      POP      AF          ; Locate - Get number o
 2321 91AD 44                      LD       B,H         ; BC Points to array di
 2322 91AE 4D                      LD       C,L
 2323 91AF CACD97                  JP       Z,POPHRT    ; Jump if array load/sa
 2324 91B2 96                      SUB      (HL)        ; Same number of dimens
 2325 91B3 CA1992                  JP       Z,FINDEL    ; Yes - Find element
 2326 91B6 1E10         BSERR:     LD       E,BS        ; ?BS Error
 2327 91B8 C3E885                  JP       ERROR       ; Output error
 2328                   ;
 2329 91BB 110400       CREARY:    LD       DE,4        ; 4 Bytes per entry
 2330 91BE F1                      POP      AF          ; Array to save or 0 di
 2331 91BF CA018B                  JP       Z,FCERR     ; Yes - ?FC Error
 2332 91C2 71                      LD       (HL),C      ; Save second byte of n
 2333 91C3 23                      INC      HL
 2334 91C4 70                      LD       (HL),B      ; Save first byte of na
 2335 91C5 23                      INC      HL
 2336 91C6 4F                      LD       C,A         ; Number of dimensions 
 2337 91C7 CDB185                  CALL     CHKSTK      ; Check if enough memor
 2338 91CA 23                      INC      HL          ; Point to number of di
 2339 91CB 23                      INC      HL
 2340 91CC 22C505                  LD       (CUROPR),HL ; Save address of point
 2341 91CF 71                      LD       (HL),C      ; Set number of dimensi
 2342 91D0 23                      INC      HL
 2343 91D1 3AAC05                  LD       A,(LCRFLG)  ; Locate of Create?
 2344 91D4 17                      RLA                  ; Carry set = Create
 2345 91D5 79                      LD       A,C         ; Get number of dimensi
 2346 91D6 010B00       CRARLP:    LD       BC,10+1     ; Default dimension siz
 2347 91D9 D2DE91                  JP       NC,DEFSIZ   ; Locate - Set default 
 2348 91DC C1                      POP      BC          ; Get specified dimensi
 2349 91DD 03                      INC      BC          ; Include zero element
 2350 91DE 71           DEFSIZ:    LD       (HL),C      ; Save LSB of dimension
 2351 91DF 23                      INC      HL
 2352 91E0 70                      LD       (HL),B      ; Save MSB of dimension
 2353 91E1 23                      INC      HL
 2354 91E2 F5                      PUSH     AF          ; Save num' of dim'ns a
 2355 91E3 E5                      PUSH     HL          ; Save address of dim'n
 2356 91E4 CD7899                  CALL     MLDEBC      ; Multiply DE by BC to 
 2357 91E7 EB                      EX       DE,HL       ; amount of mem needed 
 2358 91E8 E1                      POP      HL          ; Restore address of di
 2359 91E9 F1                      POP      AF          ; Restore number of dim
 2360 91EA 3D                      DEC      A           ; Count them
 2361 91EB C2D691                  JP       NZ,CRARLP   ; Do next dimension if 
 2362 91EE F5                      PUSH     AF          ; Save locate/create fl
 2363 91EF 42                      LD       B,D         ; MSB of memory needed
 2364 91F0 4B                      LD       C,E         ; LSB of memory needed
 2365 91F1 EB                      EX       DE,HL
 2366 91F2 19                      ADD      HL,DE       ; Add bytes to array st
 2367 91F3 DAC985                  JP       C,OMERR     ; Too big - Error
 2368 91F6 CDBA85                  CALL     ENFMEM      ; See if enough memory
 2369 91F9 22DA05                  LD       (ARREND),HL ; Save new end of array
 2370                   ;
 2371 91FC 2B           ZERARY:    DEC      HL          ; Back through array da
 2372 91FD 3600                    LD       (HL),0      ; Set array element to 
 2373 91FF CD9C88                  CALL     CPDEHL      ; All elements zeroed?
 2374 9202 C2FC91                  JP       NZ,ZERARY   ; No - Keep on going
 2375 9205 03                      INC      BC          ; Number of bytes + 1
 2376 9206 57                      LD       D,A         ; A=0
 2377 9207 2AC505                  LD       HL,(CUROPR) ; Get address of array
 2378 920A 5E                      LD       E,(HL)      ; Number of dimensions
 2379 920B EB                      EX       DE,HL       ; To HL
 2380 920C 29                      ADD      HL,HL       ; Two bytes per dimensi
 2381 920D 09                      ADD      HL,BC       ; Add number of bytes
 2382 920E EB                      EX       DE,HL       ; Bytes needed to DE
 2383 920F 2B                      DEC      HL
 2384 9210 2B                      DEC      HL
 2385 9211 73                      LD       (HL),E      ; Save LSB of bytes nee
 2386 9212 23                      INC      HL
 2387 9213 72                      LD       (HL),D      ; Save MSB of bytes nee
 2388 9214 23                      INC      HL
 2389 9215 F1                      POP      AF          ; Locate / Create?
 2390 9216 DA3D92                  JP       C,ENDDIM    ; A is 0 , End if creat
 2391 9219 47           FINDEL:    LD       B,A         ; Find array element
 2392 921A 4F                      LD       C,A
 2393 921B 7E                      LD       A,(HL)      ; Number of dimensions
 2394 921C 23                      INC      HL
 2395 921D 16                      DB       16H         ; Skip "POP HL"
 2396 921E E1           FNDELP:    POP      HL          ; Address of next dim' 
 2397 921F 5E                      LD       E,(HL)      ; Get LSB of dim'n size
 2398 9220 23                      INC      HL
 2399 9221 56                      LD       D,(HL)      ; Get MSB of dim'n size
 2400 9222 23                      INC      HL
 2401 9223 E3                      EX       (SP),HL     ; Save address - Get in
 2402 9224 F5                      PUSH     AF          ; Save number of dim'ns
 2403 9225 CD9C88                  CALL     CPDEHL      ; Dimension too large?
 2404 9228 D2B691                  JP       NC,BSERR    ; Yes - ?BS Error
 2405 922B E5                      PUSH     HL          ; Save index
 2406 922C CD7899                  CALL     MLDEBC      ; Multiply previous by 
 2407 922F D1                      POP      DE          ; Index supplied to DE
 2408 9230 19                      ADD      HL,DE       ; Add index to pointer
 2409 9231 F1                      POP      AF          ; Number of dimensions
 2410 9232 3D                      DEC      A           ; Count them
 2411 9233 44                      LD       B,H         ; MSB of pointer
 2412 9234 4D                      LD       C,L         ; LSB of pointer
 2413 9235 C21E92                  JP       NZ,FNDELP   ; More - Keep going
 2414 9238 29                      ADD      HL,HL       ; 4 Bytes per element
 2415 9239 29                      ADD      HL,HL
 2416 923A C1                      POP      BC          ; Start of array
 2417 923B 09                      ADD      HL,BC       ; Point to element
 2418 923C EB                      EX       DE,HL       ; Address of element to
 2419 923D 2AD005       ENDDIM:    LD       HL,(NXTOPR) ; Got code string addre
 2420 9240 C9                      RET
 2421                   ;
 2422 9241 2ADA05       FRE:       LD       HL,(ARREND) ; Start of free memory
 2423 9244 EB                      EX       DE,HL       ; To DE
 2424 9245 210000                  LD       HL,0        ; End of free memory
 2425 9248 39                      ADD      HL,SP       ; Current stack value
 2426 9249 3AAD05                  LD       A,(TYPE)    ; Dummy argument type
 2427 924C B7                      OR       A
 2428 924D CA5D92                  JP       Z,FRENUM    ; Numeric - Free variab
 2429 9250 CDC494                  CALL     GSTRCU      ; Current string to poo
 2430 9253 CDC493                  CALL     GARBGE      ; Garbage collection
 2431 9256 2A5A05                  LD       HL,(STRSPC) ; Bottom of string spac
 2432 9259 EB                      EX       DE,HL       ; To DE
 2433 925A 2AC305                  LD       HL,(STRBOT) ; Bottom of string spac
 2434 925D 7D           FRENUM:    LD       A,L         ; Get LSB of end
 2435 925E 93                      SUB      E           ; Subtract LSB of begin
 2436 925F 4F                      LD       C,A         ; Save difference if C
 2437 9260 7C                      LD       A,H         ; Get MSB of end
 2438 9261 9A                      SBC      A,D         ; Subtract MSB of begin
 2439 9262 41           ACPASS:    LD       B,C         ; Return integer AC
 2440 9263 50           ABPASS:    LD       D,B         ; Return integer AB
 2441 9264 1E00                    LD       E,0
 2442 9266 21AD05                  LD       HL,TYPE     ; Point to type
 2443 9269 73                      LD       (HL),E      ; Set type to numeric
 2444 926A 0690                    LD       B,80H+16    ; 16 bit integer
 2445 926C C3A398                  JP       RETINT      ; Return the integr
 2446                   ;
 2447 926F 3AAB05       POS:       LD       A,(CURPOS)  ; Get cursor position
 2448 9272 47           PASSA:     LD       B,A         ; Put A into AB
 2449 9273 AF                      XOR      A           ; Zero A
 2450 9274 C36392                  JP       ABPASS      ; Return integer AB
 2451                   ;
 2452 9277 CDFA92       DEF:       CALL     CHEKFN      ; Get "FN" and name
 2453 927A CDEC92                  CALL     IDTEST      ; Test for illegal dire
 2454 927D 01D18B                  LD       BC,DATA     ; To get next statement
 2455 9280 C5                      PUSH     BC          ; Save address for RETu
 2456 9281 D5                      PUSH     DE          ; Save address of funct
 2457 9282 CDA288                  CALL     CHKSYN      ; Make sure "(" follows
 2458 9285 28                      DB       "("
 2459 9286 CD9E90                  CALL     GETVAR      ; Get argument variable
 2460 9289 E5                      PUSH     HL          ; Save code string addr
 2461 928A EB                      EX       DE,HL       ; Argument address to H
 2462 928B 2B                      DEC      HL
 2463 928C 56                      LD       D,(HL)      ; Get first byte of arg
 2464 928D 2B                      DEC      HL
 2465 928E 5E                      LD       E,(HL)      ; Get second byte of ar
 2466 928F E1                      POP      HL          ; Restore code string a
 2467 9290 CDAA8E                  CALL     TSTNUM      ; Make sure numeric arg
 2468 9293 CDA288                  CALL     CHKSYN      ; Make sure ")" follows
 2469 9296 29                      DB       ")"
 2470 9297 CDA288                  CALL     CHKSYN      ; Make sure "=" follows
 2471 929A B4                      DB       ZEQUAL      ; "=" token
 2472 929B 44                      LD       B,H         ; Code string address t
 2473 929C 4D                      LD       C,L
 2474 929D E3                      EX       (SP),HL     ; Save code str , Get F
 2475 929E 71                      LD       (HL),C      ; Save LSB of FN code s
 2476 929F 23                      INC      HL
 2477 92A0 70                      LD       (HL),B      ; Save MSB of FN code s
 2478 92A1 C33993                  JP       SVSTAD      ; Save address and do f
 2479                   ;
 2480 92A4 CDFA92       DOFN:      CALL     CHEKFN      ; Make sure FN follows
 2481 92A7 D5                      PUSH     DE          ; Save function pointer
 2482 92A8 CD7F8F                  CALL     EVLPAR      ; Evaluate expression i
 2483 92AB CDAA8E                  CALL     TSTNUM      ; Make sure numeric res
 2484 92AE E3                      EX       (SP),HL     ; Save code str , Get F
 2485 92AF 5E                      LD       E,(HL)      ; Get LSB of FN code st
 2486 92B0 23                      INC      HL
 2487 92B1 56                      LD       D,(HL)      ; Get MSB of FN code st
 2488 92B2 23                      INC      HL
 2489 92B3 7A                      LD       A,D         ; And function DEFined?
 2490 92B4 B3                      OR       E
 2491 92B5 CAE085                  JP       Z,UFERR     ; No - ?UF Error
 2492 92B8 7E                      LD       A,(HL)      ; Get LSB of argument a
 2493 92B9 23                      INC      HL
 2494 92BA 66                      LD       H,(HL)      ; Get MSB of argument a
 2495 92BB 6F                      LD       L,A         ; HL = Arg variable add
 2496 92BC E5                      PUSH     HL          ; Save it
 2497 92BD 2ADE05                  LD       HL,(FNRGNM) ; Get old argument name
 2498 92C0 E3                      EX       (SP),HL     ;        ; Save old , G
 2499 92C1 22DE05                  LD       (FNRGNM),HL ; Set new argument name
 2500 92C4 2AE205                  LD       HL,(FNARG+2) ; Get LSB,NLSB of old 
 2501 92C7 E5                      PUSH     HL          ; Save it
 2502 92C8 2AE005                  LD       HL,(FNARG)  ; Get MSB,EXP of old ar
 2503 92CB E5                      PUSH     HL          ; Save it
 2504 92CC 21E005                  LD       HL,FNARG    ; HL = Value of argumen
 2505 92CF D5                      PUSH     DE          ; Save FN code string a
 2506 92D0 CDE498                  CALL     FPTHL       ; Move FPREG to argumen
 2507 92D3 E1                      POP      HL          ; Get FN code string ad
 2508 92D4 CDA78E                  CALL     GETNUM      ; Get value from functi
 2509 92D7 2B                      DEC      HL          ; DEC 'cos GETCHR INCs
 2510 92D8 CD308A                  CALL     GETCHR      ; Get next character
 2511 92DB C2D485                  JP       NZ,SNERR    ; Bad character in FN -
 2512 92DE E1                      POP      HL          ; Get MSB,EXP of old ar
 2513 92DF 22E005                  LD       (FNARG),HL  ; Restore it
 2514 92E2 E1                      POP      HL          ; Get LSB,NLSB of old a
 2515 92E3 22E205                  LD       (FNARG+2),HL ; Restore it
 2516 92E6 E1                      POP      HL          ; Get name of old arg
 2517 92E7 22DE05                  LD       (FNRGNM),HL ; Restore it
 2518 92EA E1                      POP      HL          ; Restore code string a
 2519 92EB C9                      RET
 2520                   ;
 2521 92EC E5           IDTEST:    PUSH     HL          ; Save code string addr
 2522 92ED 2A5C05                  LD       HL,(LINEAT) ; Get current line numb
 2523 92F0 23                      INC      HL          ; -1 means direct state
 2524 92F1 7C                      LD       A,H
 2525 92F2 B5                      OR       L
 2526 92F3 E1                      POP      HL          ; Restore code string a
 2527 92F4 C0                      RET      NZ          ; Return if in program
 2528 92F5 1E16                    LD       E,ID        ; ?ID Error
 2529 92F7 C3E885                  JP       ERROR
 2530                   ;
 2531 92FA CDA288       CHEKFN:    CALL     CHKSYN      ; Make sure FN follows
 2532 92FD A7                      DB       ZFN         ; "FN" token
 2533 92FE 3E80                    LD       A,80H
 2534 9300 32CB05                  LD       (FORFLG),A  ; Flag FN name to find
 2535 9303 B6                      OR       (HL)        ; FN name has bit 7 set
 2536 9304 47                      LD       B,A         ; in first byte of name
 2537 9305 CDA390                  CALL     GTFNAM      ; Get FN name
 2538 9308 C3AA8E                  JP       TSTNUM      ; Make sure numeric fun
 2539                   ;
 2540 930B CDAA8E       STR:       CALL     TSTNUM      ; Make sure it's a numb
 2541 930E CD319A                  CALL     NUMASC      ; Turn number into text
 2542 9311 CD3F93       STR1:      CALL     CRTST       ; Create string entry f
 2543 9314 CDC494                  CALL     GSTRCU      ; Current string to poo
 2544 9317 011F95                  LD       BC,TOPOOL   ; Save in string pool
 2545 931A C5                      PUSH     BC          ; Save address on stack
 2546                   ;
 2547 931B 7E           SAVSTR:    LD       A,(HL)      ; Get string length
 2548 931C 23                      INC      HL
 2549 931D 23                      INC      HL
 2550 931E E5                      PUSH     HL          ; Save pointer to strin
 2551 931F CD9A93                  CALL     TESTR       ; See if enough string 
 2552 9322 E1                      POP      HL          ; Restore pointer to st
 2553 9323 4E                      LD       C,(HL)      ; Get LSB of address
 2554 9324 23                      INC      HL
 2555 9325 46                      LD       B,(HL)      ; Get MSB of address
 2556 9326 CD3393                  CALL     CRTMST      ; Create string entry
 2557 9329 E5                      PUSH     HL          ; Save pointer to MSB o
 2558 932A 6F                      LD       L,A         ; Length of string
 2559 932B CDB794                  CALL     TOSTRA      ; Move to string area
 2560 932E D1                      POP      DE          ; Restore pointer to MS
 2561 932F C9                      RET
 2562                   ;
 2563 9330 CD9A93       MKTMST:    CALL     TESTR       ; See if enough string 
 2564 9333 21BF05       CRTMST:    LD       HL,TMPSTR   ; Temporary string
 2565 9336 E5                      PUSH     HL          ; Save it
 2566 9337 77                      LD       (HL),A      ; Save length of string
 2567 9338 23                      INC      HL
 2568 9339 23           SVSTAD:    INC      HL
 2569 933A 73                      LD       (HL),E      ; Save LSB of address
 2570 933B 23                      INC      HL
 2571 933C 72                      LD       (HL),D      ; Save MSB of address
 2572 933D E1                      POP      HL          ; Restore pointer
 2573 933E C9                      RET
 2574                   ;
 2575 933F 2B           CRTST:     DEC      HL          ; DEC - INCed after
 2576 9340 0622         QTSTR:     LD       B,'"'       ; Terminating quote
 2577 9342 50                      LD       D,B         ; Quote to D
 2578 9343 E5           DTSTR:     PUSH     HL          ; Save start
 2579 9344 0EFF                    LD       C,-1        ; Set counter to -1
 2580 9346 23           QTSTLP:    INC      HL          ; Move on
 2581 9347 7E                      LD       A,(HL)      ; Get byte
 2582 9348 0C                      INC      C           ; Count bytes
 2583 9349 B7                      OR       A           ; End of line?
 2584 934A CA5593                  JP       Z,CRTSTE    ; Yes - Create string e
 2585 934D BA                      CP       D           ; Terminator D found?
 2586 934E CA5593                  JP       Z,CRTSTE    ; Yes - Create string e
 2587 9351 B8                      CP       B           ; Terminator B found?
 2588 9352 C24693                  JP       NZ,QTSTLP   ; No - Keep looking
 2589 9355 FE22         CRTSTE:    CP       '"'         ; End with '"'?
 2590 9357 CC308A                  CALL     Z,GETCHR    ; Yes - Get next charac
 2591 935A E3                      EX       (SP),HL     ; Starting quote
 2592 935B 23                      INC      HL          ; First byte of string
 2593 935C EB                      EX       DE,HL       ; To DE
 2594 935D 79                      LD       A,C         ; Get length
 2595 935E CD3393                  CALL     CRTMST      ; Create string entry
 2596 9361 11BF05       TSTOPL:    LD       DE,TMPSTR   ; Temporary string
 2597 9364 2AB105                  LD       HL,(TMSTPT) ; Temporary string pool
 2598 9367 22E405                  LD       (FPREG),HL  ; Save address of strin
 2599 936A 3E01                    LD       A,1
 2600 936C 32AD05                  LD       (TYPE),A    ; Set type to string
 2601 936F CDE798                  CALL     DETHL4      ; Move string to pool
 2602 9372 CD9C88                  CALL     CPDEHL      ; Out of string pool?
 2603 9375 22B105                  LD       (TMSTPT),HL ; Save new pointer
 2604 9378 E1                      POP      HL          ; Restore code string a
 2605 9379 7E                      LD       A,(HL)      ; Get next code byte
 2606 937A C0                      RET      NZ          ; Return if pool OK
 2607 937B 1E1E                    LD       E,ST        ; ?ST Error
 2608 937D C3E885                  JP       ERROR       ; String pool overflow
 2609                   ;
 2610 9380 23           PRNUMS:    INC      HL          ; Skip leading space
 2611 9381 CD3F93       PRS:       CALL     CRTST       ; Create string entry f
 2612 9384 CDC494       PRS1:      CALL     GSTRCU      ; Current string to poo
 2613 9387 CDDB98                  CALL     LOADFP      ; Move string block to 
 2614 938A 1C                      INC      E           ; Length + 1
 2615 938B 1D           PRSLP:     DEC      E           ; Count characters
 2616 938C C8                      RET      Z           ; End of string
 2617 938D 0A                      LD       A,(BC)      ; Get byte to output
 2618 938E CDAD88                  CALL     OUTC        ; Output character in A
 2619 9391 FE0D                    CP       CR          ; Return?
 2620 9393 CCEC8C                  CALL     Z,DONULL    ; Yes - Do nulls
 2621 9396 03                      INC      BC          ; Next byte in string
 2622 9397 C38B93                  JP       PRSLP       ; More characters to ou
 2623                   ;
 2624 939A B7           TESTR:     OR       A           ; Test if enough room
 2625 939B 0E                      DB       0EH         ; No garbage collection
 2626 939C F1           GRBDON:    POP      AF          ; Garbage collection do
 2627 939D F5                      PUSH     AF          ; Save status
 2628 939E 2A5A05                  LD       HL,(STRSPC) ; Bottom of string spac
 2629 93A1 EB                      EX       DE,HL       ; To DE
 2630 93A2 2AC305                  LD       HL,(STRBOT) ; Bottom of string area
 2631 93A5 2F                      CPL                  ; Negate length (Top do
 2632 93A6 4F                      LD       C,A         ; -Length to BC
 2633 93A7 06FF                    LD       B,-1        ; BC = -ve length of st
 2634 93A9 09                      ADD      HL,BC       ; Add to bottom of spac
 2635 93AA 23                      INC      HL          ; Plus one for 2's comp
 2636 93AB CD9C88                  CALL     CPDEHL      ; Below string RAM area
 2637 93AE DAB893                  JP       C,TESTOS    ; Tidy up if not done e
 2638 93B1 22C305                  LD       (STRBOT),HL ; Save new bottom of ar
 2639 93B4 23                      INC      HL          ; Point to first byte o
 2640 93B5 EB                      EX       DE,HL       ; Address to DE
 2641 93B6 F1           POPAF:     POP      AF          ; Throw away status pus
 2642 93B7 C9                      RET
 2643                   ;
 2644 93B8 F1           TESTOS:    POP      AF          ; Garbage collect been 
 2645 93B9 1E1A                    LD       E,OS        ; ?OS Error
 2646 93BB CAE885                  JP       Z,ERROR     ; Yes - Not enough stri
 2647 93BE BF                      CP       A           ; Flag garbage collect 
 2648 93BF F5                      PUSH     AF          ; Save status
 2649 93C0 019C93                  LD       BC,GRBDON   ; Garbage collection do
 2650 93C3 C5                      PUSH     BC          ; Save for RETurn
 2651 93C4 2AAF05       GARBGE:    LD       HL,(LSTRAM) ; Get end of RAM pointe
 2652 93C7 22C305       GARBLP:    LD       (STRBOT),HL ; Reset string pointer
 2653 93CA 210000                  LD       HL,0
 2654 93CD E5                      PUSH     HL          ; Flag no string found
 2655 93CE 2A5A05                  LD       HL,(STRSPC) ; Get bottom of string 
 2656 93D1 E5                      PUSH     HL          ; Save bottom of string
 2657 93D2 21B305                  LD       HL,TMSTPL   ; Temporary string pool
 2658 93D5 EB           GRBLP:     EX       DE,HL
 2659 93D6 2AB105                  LD       HL,(TMSTPT) ; Temporary string pool
 2660 93D9 EB                      EX       DE,HL
 2661 93DA CD9C88                  CALL     CPDEHL      ; Temporary string pool
 2662 93DD 01D593                  LD       BC,GRBLP    ; Loop until string poo
 2663 93E0 C22994                  JP       NZ,STPOOL   ; No - See if in string
 2664 93E3 2AD605                  LD       HL,(PROGND) ; Start of simple varia
 2665 93E6 EB           SMPVAR:    EX       DE,HL
 2666 93E7 2AD805                  LD       HL,(VAREND) ; End of simple variabl
 2667 93EA EB                      EX       DE,HL
 2668 93EB CD9C88                  CALL     CPDEHL      ; All simple strings do
 2669 93EE CAFC93                  JP       Z,ARRLP     ; Yes - Do string array
 2670 93F1 7E                      LD       A,(HL)      ; Get type of variable
 2671 93F2 23                      INC      HL
 2672 93F3 23                      INC      HL
 2673 93F4 B7                      OR       A           ; "S" flag set if strin
 2674 93F5 CD2C94                  CALL     STRADD      ; See if string in stri
 2675 93F8 C3E693                  JP       SMPVAR      ; Loop until simple one
 2676                   ;
 2677 93FB C1           GNXARY:    POP      BC          ; Scrap address of this
 2678 93FC EB           ARRLP:     EX       DE,HL
 2679 93FD 2ADA05                  LD       HL,(ARREND) ; End of string arrays
 2680 9400 EB                      EX       DE,HL
 2681 9401 CD9C88                  CALL     CPDEHL      ; All string arrays don
 2682 9404 CA5294                  JP       Z,SCNEND    ; Yes - Move string if 
 2683 9407 CDDB98                  CALL     LOADFP      ; Get array name to BCD
 2684 940A 7B                      LD       A,E         ; Get type of array
 2685 940B E5                      PUSH     HL          ; Save address of num o
 2686 940C 09                      ADD      HL,BC       ; Start of next array
 2687 940D B7                      OR       A           ; Test type of array
 2688 940E F2FB93                  JP       P,GNXARY    ; Numeric array - Ignor
 2689 9411 22C505                  LD       (CUROPR),HL ; Save address of next 
 2690 9414 E1                      POP      HL          ; Get address of num of
 2691 9415 4E                      LD       C,(HL)      ; BC = Number of dimens
 2692 9416 0600                    LD       B,0
 2693 9418 09                      ADD      HL,BC       ; Two bytes per dimensi
 2694 9419 09                      ADD      HL,BC
 2695 941A 23                      INC      HL          ; Plus one for number o
 2696 941B EB           GRBARY:    EX       DE,HL
 2697 941C 2AC505                  LD       HL,(CUROPR) ; Get address of next a
 2698 941F EB                      EX       DE,HL
 2699 9420 CD9C88                  CALL     CPDEHL      ; Is this array finishe
 2700 9423 CAFC93                  JP       Z,ARRLP     ; Yes - Get next one
 2701 9426 011B94                  LD       BC,GRBARY   ; Loop until array all 
 2702 9429 C5           STPOOL:    PUSH     BC          ; Save return address
 2703 942A F680                    OR       80H         ; Flag string type
 2704 942C 7E           STRADD:    LD       A,(HL)      ; Get string length
 2705 942D 23                      INC      HL
 2706 942E 23                      INC      HL
 2707 942F 5E                      LD       E,(HL)      ; Get LSB of string add
 2708 9430 23                      INC      HL
 2709 9431 56                      LD       D,(HL)      ; Get MSB of string add
 2710 9432 23                      INC      HL
 2711 9433 F0                      RET      P           ; Not a string - Return
 2712 9434 B7                      OR       A           ; Set flags on string l
 2713 9435 C8                      RET      Z           ; Null string - Return
 2714 9436 44                      LD       B,H         ; Save variable pointer
 2715 9437 4D                      LD       C,L
 2716 9438 2AC305                  LD       HL,(STRBOT) ; Bottom of new area
 2717 943B CD9C88                  CALL     CPDEHL      ; String been done?
 2718 943E 60                      LD       H,B         ; Restore variable poin
 2719 943F 69                      LD       L,C
 2720 9440 D8                      RET      C           ; String done - Ignore
 2721 9441 E1                      POP      HL          ; Return address
 2722 9442 E3                      EX       (SP),HL     ; Lowest available stri
 2723 9443 CD9C88                  CALL     CPDEHL      ; String within string 
 2724 9446 E3                      EX       (SP),HL     ; Lowest available stri
 2725 9447 E5                      PUSH     HL          ; Re-save return addres
 2726 9448 60                      LD       H,B         ; Restore variable poin
 2727 9449 69                      LD       L,C
 2728 944A D0                      RET      NC          ; Outside string area -
 2729 944B C1                      POP      BC          ; Get return , Throw 2 
 2730 944C F1                      POP      AF          ;
 2731 944D F1                      POP      AF          ;
 2732 944E E5                      PUSH     HL          ; Save variable pointer
 2733 944F D5                      PUSH     DE          ; Save address of curre
 2734 9450 C5                      PUSH     BC          ; Put back return addre
 2735 9451 C9                      RET                  ; Go to it
 2736                   ;
 2737 9452 D1           SCNEND:    POP      DE          ; Addresses of strings
 2738 9453 E1                      POP      HL          ;
 2739 9454 7D                      LD       A,L         ; HL = 0 if no more to 
 2740 9455 B4                      OR       H
 2741 9456 C8                      RET      Z           ; No more to do - Retur
 2742 9457 2B                      DEC      HL
 2743 9458 46                      LD       B,(HL)      ; MSB of address of str
 2744 9459 2B                      DEC      HL
 2745 945A 4E                      LD       C,(HL)      ; LSB of address of str
 2746 945B E5                      PUSH     HL          ; Save variable address
 2747 945C 2B                      DEC      HL
 2748 945D 2B                      DEC      HL
 2749 945E 6E                      LD       L,(HL)      ; HL = Length of string
 2750 945F 2600                    LD       H,0
 2751 9461 09                      ADD      HL,BC       ; Address of end of str
 2752 9462 50                      LD       D,B         ; String address to DE
 2753 9463 59                      LD       E,C
 2754 9464 2B                      DEC      HL          ; Last byte in string
 2755 9465 44                      LD       B,H         ; Address to BC
 2756 9466 4D                      LD       C,L
 2757 9467 2AC305                  LD       HL,(STRBOT) ; Current bottom of str
 2758 946A CDA385                  CALL     MOVSTR      ; Move string to new ad
 2759 946D E1                      POP      HL          ; Restore variable addr
 2760 946E 71                      LD       (HL),C      ; Save new LSB of addre
 2761 946F 23                      INC      HL
 2762 9470 70                      LD       (HL),B      ; Save new MSB of addre
 2763 9471 69                      LD       L,C         ; Next string area+1 to
 2764 9472 60                      LD       H,B
 2765 9473 2B                      DEC      HL          ; Next string area addr
 2766 9474 C3C793                  JP       GARBLP      ; Look for more strings
 2767                   ;
 2768 9477 C5           CONCAT:    PUSH     BC          ; Save prec' opr & code
 2769 9478 E5                      PUSH     HL          ;
 2770 9479 2AE405                  LD       HL,(FPREG)  ; Get first string
 2771 947C E3                      EX       (SP),HL     ; Save first string
 2772 947D CD308F                  CALL     OPRND       ; Get second string
 2773 9480 E3                      EX       (SP),HL     ; Restore first string
 2774 9481 CDAB8E                  CALL     TSTSTR      ; Make sure it's a stri
 2775 9484 7E                      LD       A,(HL)      ; Get length of second 
 2776 9485 E5                      PUSH     HL          ; Save first string
 2777 9486 2AE405                  LD       HL,(FPREG)  ; Get second string
 2778 9489 E5                      PUSH     HL          ; Save second string
 2779 948A 86                      ADD      A,(HL)      ; Add length of second 
 2780 948B 1E1C                    LD       E,LS        ; ?LS Error
 2781 948D DAE885                  JP       C,ERROR     ; String too long - Err
 2782 9490 CD3093                  CALL     MKTMST      ; Make temporary string
 2783 9493 D1                      POP      DE          ; Get second string to 
 2784 9494 CDC894                  CALL     GSTRDE      ; Move to string pool i
 2785 9497 E3                      EX       (SP),HL     ; Get first string
 2786 9498 CDC794                  CALL     GSTRHL      ; Move to string pool i
 2787 949B E5                      PUSH     HL          ; Save first string
 2788 949C 2AC105                  LD       HL,(TMPSTR+2) ; Temporary string ad
 2789 949F EB                      EX       DE,HL       ; To DE
 2790 94A0 CDAE94                  CALL     SSTSA       ; First string to strin
 2791 94A3 CDAE94                  CALL     SSTSA       ; Second string to stri
 2792 94A6 21C58E                  LD       HL,EVAL2    ; Return to evaluation 
 2793 94A9 E3                      EX       (SP),HL     ; Save return,get code 
 2794 94AA E5                      PUSH     HL          ; Save code string addr
 2795 94AB C36193                  JP       TSTOPL      ; To temporary string t
 2796                   ;
 2797 94AE E1           SSTSA:     POP      HL          ; Return address
 2798 94AF E3                      EX       (SP),HL     ; Get string block,save
 2799 94B0 7E                      LD       A,(HL)      ; Get length of string
 2800 94B1 23                      INC      HL
 2801 94B2 23                      INC      HL
 2802 94B3 4E                      LD       C,(HL)      ; Get LSB of string add
 2803 94B4 23                      INC      HL
 2804 94B5 46                      LD       B,(HL)      ; Get MSB of string add
 2805 94B6 6F                      LD       L,A         ; Length to L
 2806 94B7 2C           TOSTRA:    INC      L           ; INC - DECed after
 2807 94B8 2D           TSALP:     DEC      L           ; Count bytes moved
 2808 94B9 C8                      RET      Z           ; End of string - Retur
 2809 94BA 0A                      LD       A,(BC)      ; Get source
 2810 94BB 12                      LD       (DE),A      ; Save destination
 2811 94BC 03                      INC      BC          ; Next source
 2812 94BD 13                      INC      DE          ; Next destination
 2813 94BE C3B894                  JP       TSALP       ; Loop until string mov
 2814                   ;
 2815 94C1 CDAB8E       GETSTR:    CALL     TSTSTR      ; Make sure it's a stri
 2816 94C4 2AE405       GSTRCU:    LD       HL,(FPREG)  ; Get current string
 2817 94C7 EB           GSTRHL:    EX       DE,HL       ; Save DE
 2818 94C8 CDE294       GSTRDE:    CALL     BAKTMP      ; Was it last tmp-str?
 2819 94CB EB                      EX       DE,HL       ; Restore DE
 2820 94CC C0                      RET      NZ          ; No - Return
 2821 94CD D5                      PUSH     DE          ; Save string
 2822 94CE 50                      LD       D,B         ; String block address 
 2823 94CF 59                      LD       E,C
 2824 94D0 1B                      DEC      DE          ; Point to length
 2825 94D1 4E                      LD       C,(HL)      ; Get string length
 2826 94D2 2AC305                  LD       HL,(STRBOT) ; Current bottom of str
 2827 94D5 CD9C88                  CALL     CPDEHL      ; Last one in string ar
 2828 94D8 C2E094                  JP       NZ,POPHL    ; No - Return
 2829 94DB 47                      LD       B,A         ; Clear B (A=0)
 2830 94DC 09                      ADD      HL,BC       ; Remove string from st
 2831 94DD 22C305                  LD       (STRBOT),HL ; Save new bottom of st
 2832 94E0 E1           POPHL:     POP      HL          ; Restore string
 2833 94E1 C9                      RET
 2834                   ;
 2835 94E2 2AB105       BAKTMP:    LD       HL,(TMSTPT) ; Get temporary string 
 2836 94E5 2B                      DEC      HL          ; Back
 2837 94E6 46                      LD       B,(HL)      ; Get MSB of address
 2838 94E7 2B                      DEC      HL          ; Back
 2839 94E8 4E                      LD       C,(HL)      ; Get LSB of address
 2840 94E9 2B                      DEC      HL          ; Back
 2841 94EA 2B                      DEC      HL          ; Back
 2842 94EB CD9C88                  CALL     CPDEHL      ; String last in string
 2843 94EE C0                      RET      NZ          ; Yes - Leave it
 2844 94EF 22B105                  LD       (TMSTPT),HL ; Save new string pool 
 2845 94F2 C9                      RET
 2846                   ;
 2847 94F3 017292       LEN:       LD       BC,PASSA    ; To return integer A
 2848 94F6 C5                      PUSH     BC          ; Save address
 2849 94F7 CDC194       GETLEN:    CALL     GETSTR      ; Get string and its le
 2850 94FA AF                      XOR      A
 2851 94FB 57                      LD       D,A         ; Clear D
 2852 94FC 32AD05                  LD       (TYPE),A    ; Set type to numeric
 2853 94FF 7E                      LD       A,(HL)      ; Get length of string
 2854 9500 B7                      OR       A           ; Set status flags
 2855 9501 C9                      RET
 2856                   ;
 2857 9502 017292       ASC:       LD       BC,PASSA    ; To return integer A
 2858 9505 C5                      PUSH     BC          ; Save address
 2859 9506 CDF794       GTFLNM:    CALL     GETLEN      ; Get length of string
 2860 9509 CA018B                  JP       Z,FCERR     ; Null string - Error
 2861 950C 23                      INC      HL
 2862 950D 23                      INC      HL
 2863 950E 5E                      LD       E,(HL)      ; Get LSB of address
 2864 950F 23                      INC      HL
 2865 9510 56                      LD       D,(HL)      ; Get MSB of address
 2866 9511 1A                      LD       A,(DE)      ; Get first byte of str
 2867 9512 C9                      RET
 2868                   ;
 2869 9513 3E01         CHR:       LD       A,1         ; One character string
 2870 9515 CD3093                  CALL     MKTMST      ; Make a temporary stri
 2871 9518 CD0E96                  CALL     MAKINT      ; Make it integer A
 2872 951B 2AC105                  LD       HL,(TMPSTR+2) ; Get address of stri
 2873 951E 73                      LD       (HL),E      ; Save character
 2874 951F C1           TOPOOL:    POP      BC          ; Clean up stack
 2875 9520 C36193                  JP       TSTOPL      ; Temporary string to p
 2876                   ;
 2877 9523 CDBE95       LEFT:      CALL     LFRGNM      ; Get number and ending
 2878 9526 AF                      XOR      A           ; Start at first byte i
 2879 9527 E3           RIGHT1:    EX       (SP),HL     ; Save code string,Get 
 2880 9528 4F                      LD       C,A         ; Starting position in 
 2881 9529 E5           MID1:      PUSH     HL          ; Save string block add
 2882 952A 7E                      LD       A,(HL)      ; Get length of string
 2883 952B B8                      CP       B           ; Compare with number g
 2884 952C DA3195                  JP       C,ALLFOL    ; All following bytes r
 2885 952F 78                      LD       A,B         ; Get new length
 2886 9530 11                      DB       11H         ; Skip "LD C,0"
 2887 9531 0E00         ALLFOL:    LD       C,0         ; First byte of string
 2888 9533 C5                      PUSH     BC          ; Save position in stri
 2889 9534 CD9A93                  CALL     TESTR       ; See if enough string 
 2890 9537 C1                      POP      BC          ; Get position in strin
 2891 9538 E1                      POP      HL          ; Restore string block 
 2892 9539 E5                      PUSH     HL          ; And re-save it
 2893 953A 23                      INC      HL
 2894 953B 23                      INC      HL
 2895 953C 46                      LD       B,(HL)      ; Get LSB of address
 2896 953D 23                      INC      HL
 2897 953E 66                      LD       H,(HL)      ; Get MSB of address
 2898 953F 68                      LD       L,B         ; HL = address of strin
 2899 9540 0600                    LD       B,0         ; BC = starting address
 2900 9542 09                      ADD      HL,BC       ; Point to that byte
 2901 9543 44                      LD       B,H         ; BC = source string
 2902 9544 4D                      LD       C,L
 2903 9545 CD3393                  CALL     CRTMST      ; Create a string entry
 2904 9548 6F                      LD       L,A         ; Length of new string
 2905 9549 CDB794                  CALL     TOSTRA      ; Move string to string
 2906 954C D1                      POP      DE          ; Clear stack
 2907 954D CDC894                  CALL     GSTRDE      ; Move to string pool i
 2908 9550 C36193                  JP       TSTOPL      ; Temporary string to p
 2909                   ;
 2910 9553 CDBE95       RIGHT:     CALL     LFRGNM      ; Get number and ending
 2911 9556 D1                      POP      DE          ; Get string length
 2912 9557 D5                      PUSH     DE          ; And re-save
 2913 9558 1A                      LD       A,(DE)      ; Get length
 2914 9559 90                      SUB      B           ; Move back N bytes
 2915 955A C32795                  JP       RIGHT1      ; Go and get sub-string
 2916                   ;
 2917 955D EB           MID:       EX       DE,HL       ; Get code string addre
 2918 955E 7E                      LD       A,(HL)      ; Get next byte ',' or 
 2919 955F CDC395                  CALL     MIDNUM      ; Get number supplied
 2920 9562 04                      INC      B           ; Is it character zero?
 2921 9563 05                      DEC      B
 2922 9564 CA018B                  JP       Z,FCERR     ; Yes - Error
 2923 9567 C5                      PUSH     BC          ; Save starting positio
 2924 9568 1EFF                    LD       E,255       ; All of string
 2925 956A FE29                    CP       ')'         ; Any length given?
 2926 956C CA7695                  JP       Z,RSTSTR    ; No - Rest of string
 2927 956F CDA288                  CALL     CHKSYN      ; Make sure ',' follows
 2928 9572 2C                      DB       ','
 2929 9573 CD0B96                  CALL     GETINT      ; Get integer 0-255
 2930 9576 CDA288       RSTSTR:    CALL     CHKSYN      ; Make sure ")" follows
 2931 9579 29                      DB       ")"
 2932 957A F1                      POP      AF          ; Restore starting posi
 2933 957B E3                      EX       (SP),HL     ; Get string,8ave code 
 2934 957C 012995                  LD       BC,MID1     ; Continuation of MID$ 
 2935 957F C5                      PUSH     BC          ; Save for return
 2936 9580 3D                      DEC      A           ; Starting position-1
 2937 9581 BE                      CP       (HL)        ; Compare with length
 2938 9582 0600                    LD       B,0         ; Zero bytes length
 2939 9584 D0                      RET      NC          ; Null string if start 
 2940 9585 4F                      LD       C,A         ; Save starting positio
 2941 9586 7E                      LD       A,(HL)      ; Get length of string
 2942 9587 91                      SUB      C           ; Subtract start
 2943 9588 BB                      CP       E           ; Enough string for it?
 2944 9589 47                      LD       B,A         ; Save maximum length a
 2945 958A D8                      RET      C           ; Truncate string if ne
 2946 958B 43                      LD       B,E         ; Set specified length
 2947 958C C9                      RET                  ; Go and create string
 2948                   ;
 2949 958D CDF794       VAL:       CALL     GETLEN      ; Get length of string
 2950 9590 CAAC96                  JP       Z,RESZER    ; Result zero
 2951 9593 5F                      LD       E,A         ; Save length
 2952 9594 23                      INC      HL
 2953 9595 23                      INC      HL
 2954 9596 7E                      LD       A,(HL)      ; Get LSB of address
 2955 9597 23                      INC      HL
 2956 9598 66                      LD       H,(HL)      ; Get MSB of address
 2957 9599 6F                      LD       L,A         ; HL = String address
 2958 959A E5                      PUSH     HL          ; Save string address
 2959 959B 19                      ADD      HL,DE
 2960 959C 46                      LD       B,(HL)      ; Get end of string+1 b
 2961 959D 72                      LD       (HL),D      ; Zero it to terminate
 2962 959E E3                      EX       (SP),HL     ; Save string end,get s
 2963 959F C5                      PUSH     BC          ; Save end+1 byte
 2964 95A0 7E                      LD       A,(HL)      ; Get starting byte
 2965 95A1 FE24                    CP       '$'         ; Hex number indicated?
 2966 95A3 C2AC95                  JP       NZ,VAL1
 2967 95A6 CDDD9D                  CALL     HEXTFP      ; Convert Hex to FPREG
 2968 95A9 C3BA95                  JP       VAL3
 2969 95AC FE25         VAL1:      CP       '%'         ; Binary number indicat
 2970 95AE C2B795                  JP       NZ,VAL2
 2971 95B1 CD599E                  CALL     BINTFP      ; Convert Bin to FPREG
 2972 95B4 C3BA95                  JP       VAL3
 2973 95B7 CD9399       VAL2:      CALL     ASCTFP      ; Convert ASCII string 
 2974 95BA C1           VAL3:      POP      BC          ; Restore end+1 byte
 2975 95BB E1                      POP      HL          ; Restore end+1 address
 2976 95BC 70                      LD       (HL),B      ; Put back original byt
 2977 95BD C9                      RET
 2978                   ;
 2979 95BE EB           LFRGNM:    EX       DE,HL       ; Code string address t
 2980 95BF CDA288                  CALL     CHKSYN      ; Make sure ")" follows
 2981 95C2 29                      DB       ")"
 2982 95C3 C1           MIDNUM:    POP      BC          ; Get return address
 2983 95C4 D1                      POP      DE          ; Get number supplied
 2984 95C5 C5                      PUSH     BC          ; Re-save return addres
 2985 95C6 43                      LD       B,E         ; Number to B
 2986 95C7 C9                      RET
 2987                   ;
 2988 95C8 CD0E96       INP:       CALL     MAKINT      ; Make it integer A
 2989 95CB 323F05                  LD       (INPORT),A  ; Set input port
 2990 95CE CD3E05                  CALL     INPSUB      ; Get input from port
 2991 95D1 C37292                  JP       PASSA       ; Return integer A
 2992                   ;
 2993 95D4 CDF895       POUT:      CALL     SETIO       ; Set up port number
 2994 95D7 C30605                  JP       OUTSUB      ; Output data and retur
 2995                   ;
 2996 95DA CDF895       WAIT:      CALL     SETIO       ; Set up port number
 2997 95DD F5                      PUSH     AF          ; Save AND mask
 2998 95DE 1E00                    LD       E,0         ; Assume zero if none g
 2999 95E0 2B                      DEC      HL          ; DEC 'cos GETCHR INCs
 3000 95E1 CD308A                  CALL     GETCHR      ; Get next character
 3001 95E4 CAEE95                  JP       Z,NOXOR     ; No XOR byte given
 3002 95E7 CDA288                  CALL     CHKSYN      ; Make sure ',' follows
 3003 95EA 2C                      DB       ','
 3004 95EB CD0B96                  CALL     GETINT      ; Get integer 0-255 to 
 3005 95EE C1           NOXOR:     POP      BC          ; Restore AND mask
 3006 95EF CD3E05       WAITLP:    CALL     INPSUB      ; Get input
 3007 95F2 AB                      XOR      E           ; Flip selected bits
 3008 95F3 A0                      AND      B           ; Result non-zero?
 3009 95F4 CAEF95                  JP       Z,WAITLP    ; No = keep waiting
 3010 95F7 C9                      RET
 3011                   ;
 3012 95F8 CD0B96       SETIO:     CALL     GETINT      ; Get integer 0-255
 3013 95FB 323F05                  LD       (INPORT),A  ; Set input port
 3014 95FE 320705                  LD       (OTPORT),A  ; Set output port
 3015 9601 CDA288                  CALL     CHKSYN      ; Make sure ',' follows
 3016 9604 2C                      DB       ','
 3017 9605 C30B96                  JP       GETINT      ; Get integer 0-255 and
 3018                   ;
 3019 9608 CD308A       FNDNUM:    CALL     GETCHR      ; Get next character
 3020 960B CDA78E       GETINT:    CALL     GETNUM      ; Get a number from 0 t
 3021 960E CDE68A       MAKINT:    CALL     DEPINT      ; Make sure value 0 - 2
 3022 9611 7A                      LD       A,D         ; Get MSB of number
 3023 9612 B7                      OR       A           ; Zero?
 3024 9613 C2018B                  JP       NZ,FCERR    ; No - Error
 3025 9616 2B                      DEC      HL          ; DEC 'cos GETCHR INCs
 3026 9617 CD308A                  CALL     GETCHR      ; Get next character
 3027 961A 7B                      LD       A,E         ; Get number to A
 3028 961B C9                      RET
 3029                   ;
 3030 961C CDEC8A       PEEK:      CALL     DEINT       ; Get memory address
 3031 961F 1A                      LD       A,(DE)      ; Get byte in memory
 3032 9620 C37292                  JP       PASSA       ; Return integer A
 3033                   ;
 3034 9623 CDA78E       POKE:      CALL     GETNUM      ; Get memory address
 3035 9626 CDEC8A                  CALL     DEINT       ; Get integer -32768 to
 3036 9629 D5                      PUSH     DE          ; Save memory address
 3037 962A CDA288                  CALL     CHKSYN      ; Make sure ',' follows
 3038 962D 2C                      DB       ','
 3039 962E CD0B96                  CALL     GETINT      ; Get integer 0-255
 3040 9631 D1                      POP      DE          ; Restore memory addres
 3041 9632 12                      LD       (DE),A      ; Load it into memory
 3042 9633 C9                      RET
 3043                   ;
 3044 9634 210A9B       ROUND:     LD       HL,HALF     ; Add 0.5 to FPREG
 3045 9637 CDDB98       ADDPHL:    CALL     LOADFP      ; Load FP at (HL) to BC
 3046 963A C34696                  JP       FPADD       ; Add BCDE to FPREG
 3047                   ;
 3048 963D CDDB98       SUBPHL:    CALL     LOADFP      ; FPREG = -FPREG + numb
 3049 9640 21                      DB       21H         ; Skip "POP BC" and "PO
 3050 9641 C1           PSUB:      POP      BC          ; Get FP number from st
 3051 9642 D1                      POP      DE
 3052 9643 CDB598       SUBCDE:    CALL     INVSGN      ; Negate FPREG
 3053 9646 78           FPADD:     LD       A,B         ; Get FP exponent
 3054 9647 B7                      OR       A           ; Is number zero?
 3055 9648 C8                      RET      Z           ; Yes - Nothing to add
 3056 9649 3AE705                  LD       A,(FPEXP)   ; Get FPREG exponent
 3057 964C B7                      OR       A           ; Is this number zero?
 3058 964D CACD98                  JP       Z,FPBCDE    ; Yes - Move BCDE to FP
 3059 9650 90                      SUB      B           ; BCDE number larger?
 3060 9651 D26096                  JP       NC,NOSWAP   ; No - Don't swap them
 3061 9654 2F                      CPL                  ; Two's complement
 3062 9655 3C                      INC      A           ;       FP exponent
 3063 9656 EB                      EX       DE,HL
 3064 9657 CDBD98                  CALL     STAKFP      ; Put FPREG on stack
 3065 965A EB                      EX       DE,HL
 3066 965B CDCD98                  CALL     FPBCDE      ; Move BCDE to FPREG
 3067 965E C1                      POP      BC          ; Restore number from s
 3068 965F D1                      POP      DE
 3069 9660 FE19         NOSWAP:    CP       24+1        ; Second number insigni
 3070 9662 D0                      RET      NC          ; Yes - First number is
 3071 9663 F5                      PUSH     AF          ; Save number of bits t
 3072 9664 CDF298                  CALL     SIGNS       ; Set MSBs & sign of re
 3073 9667 67                      LD       H,A         ; Save sign of result
 3074 9668 F1                      POP      AF          ; Restore scaling facto
 3075 9669 CD0B97                  CALL     SCALE       ; Scale BCDE to same ex
 3076 966C B4                      OR       H           ; Result to be positive
 3077 966D 21E405                  LD       HL,FPREG    ; Point to FPREG
 3078 9670 F28696                  JP       P,MINCDE    ; No - Subtract FPREG f
 3079 9673 CDEB96                  CALL     PLUCDE      ; Add FPREG to CDE
 3080 9676 D2CC96                  JP       NC,RONDUP   ; No overflow - Round i
 3081 9679 23                      INC      HL          ; Point to exponent
 3082 967A 34                      INC      (HL)        ; Increment it
 3083 967B CAE385                  JP       Z,OVERR     ; Number overflowed - E
 3084 967E 2E01                    LD       L,1         ; 1 bit to shift right
 3085 9680 CD2197                  CALL     SHRT1       ; Shift result right
 3086 9683 C3CC96                  JP       RONDUP      ; Round it up
 3087                   ;
 3088 9686 AF           MINCDE:    XOR      A           ; Clear A and carry
 3089 9687 90                      SUB      B           ; Negate exponent
 3090 9688 47                      LD       B,A         ; Re-save exponent
 3091 9689 7E                      LD       A,(HL)      ; Get LSB of FPREG
 3092 968A 9B                      SBC      A, E        ; Subtract LSB of BCDE
 3093 968B 5F                      LD       E,A         ; Save LSB of BCDE
 3094 968C 23                      INC      HL
 3095 968D 7E                      LD       A,(HL)      ; Get NMSB of FPREG
 3096 968E 9A                      SBC      A,D         ; Subtract NMSB of BCDE
 3097 968F 57                      LD       D,A         ; Save NMSB of BCDE
 3098 9690 23                      INC      HL
 3099 9691 7E                      LD       A,(HL)      ; Get MSB of FPREG
 3100 9692 99                      SBC      A,C         ; Subtract MSB of BCDE
 3101 9693 4F                      LD       C,A         ; Save MSB of BCDE
 3102 9694 DCF796       CONPOS:    CALL     C,COMPL     ; Overflow - Make it po
 3103                   ;
 3104 9697 68           BNORM:     LD       L,B         ; L = Exponent
 3105 9698 63                      LD       H,E         ; H = LSB
 3106 9699 AF                      XOR      A
 3107 969A 47           BNRMLP:    LD       B,A         ; Save bit count
 3108 969B 79                      LD       A,C         ; Get MSB
 3109 969C B7                      OR       A           ; Is it zero?
 3110 969D C2B996                  JP       NZ,PNORM    ; No - Do it bit at a t
 3111 96A0 4A                      LD       C,D         ; MSB = NMSB
 3112 96A1 54                      LD       D,H         ; NMSB= LSB
 3113 96A2 65                      LD       H,L         ; LSB = VLSB
 3114 96A3 6F                      LD       L,A         ; VLSB= 0
 3115 96A4 78                      LD       A,B         ; Get exponent
 3116 96A5 D608                    SUB      8           ; Count 8 bits
 3117 96A7 FEE0                    CP       0E0H        ; -24-8 Was number zero
 3118 96A9 C29A96                  JP       NZ,BNRMLP   ; No - Keep normalising
 3119 96AC AF           RESZER:    XOR      A           ; Result is zero
 3120 96AD 32E705       SAVEXP:    LD       (FPEXP),A   ; Save result as zero
 3121 96B0 C9                      RET
 3122                   ;
 3123 96B1 05           NORMAL:    DEC      B           ; Count bits
 3124 96B2 29                      ADD      HL,HL       ; Shift HL left
 3125 96B3 7A                      LD       A,D         ; Get NMSB
 3126 96B4 17                      RLA                  ; Shift left with last 
 3127 96B5 57                      LD       D,A         ; Save NMSB
 3128 96B6 79                      LD       A,C         ; Get MSB
 3129 96B7 8F                      ADC      A,A         ; Shift left with last 
 3130 96B8 4F                      LD       C,A         ; Save MSB
 3131 96B9 F2B196       PNORM:     JP       P,NORMAL    ; Not done - Keep going
 3132 96BC 78                      LD       A,B         ; Number of bits shifte
 3133 96BD 5C                      LD       E,H         ; Save HL in EB
 3134 96BE 45                      LD       B,L
 3135 96BF B7                      OR       A           ; Any shifting done?
 3136 96C0 CACC96                  JP       Z,RONDUP    ; No - Round it up
 3137 96C3 21E705                  LD       HL,FPEXP    ; Point to exponent
 3138 96C6 86                      ADD      A,(HL)      ; Add shifted bits
 3139 96C7 77                      LD       (HL),A      ; Re-save exponent
 3140 96C8 D2AC96                  JP       NC,RESZER   ; Underflow - Result is
 3141 96CB C8                      RET      Z           ; Result is zero
 3142 96CC 78           RONDUP:    LD       A,B         ; Get VLSB of number
 3143 96CD 21E705       RONDB:     LD       HL,FPEXP    ; Point to exponent
 3144 96D0 B7                      OR       A           ; Any rounding?
 3145 96D1 FCDE96                  CALL     M,FPROND    ; Yes - Round number up
 3146 96D4 46                      LD       B,(HL)      ; B = Exponent
 3147 96D5 23                      INC      HL
 3148 96D6 7E                      LD       A,(HL)      ; Get sign of result
 3149 96D7 E680                    AND      10000000B   ; Only bit 7 needed
 3150 96D9 A9                      XOR      C           ; Set correct sign
 3151 96DA 4F                      LD       C,A         ; Save correct sign in 
 3152 96DB C3CD98                  JP       FPBCDE      ; Move BCDE to FPREG
 3153                   ;
 3154 96DE 1C           FPROND:    INC      E           ; Round LSB
 3155 96DF C0                      RET      NZ          ; Return if ok
 3156 96E0 14                      INC      D           ; Round NMSB
 3157 96E1 C0                      RET      NZ          ; Return if ok
 3158 96E2 0C                      INC      C           ; Round MSB
 3159 96E3 C0                      RET      NZ          ; Return if ok
 3160 96E4 0E80                    LD       C,80H       ; Set normal value
 3161 96E6 34                      INC      (HL)        ; Increment exponent
 3162 96E7 C0                      RET      NZ          ; Return if ok
 3163 96E8 C3E385                  JP       OVERR       ; Overflow error
 3164                   ;
 3165 96EB 7E           PLUCDE:    LD       A,(HL)      ; Get LSB of FPREG
 3166 96EC 83                      ADD      A,E         ; Add LSB of BCDE
 3167 96ED 5F                      LD       E,A         ; Save LSB of BCDE
 3168 96EE 23                      INC      HL
 3169 96EF 7E                      LD       A,(HL)      ; Get NMSB of FPREG
 3170 96F0 8A                      ADC      A,D         ; Add NMSB of BCDE
 3171 96F1 57                      LD       D,A         ; Save NMSB of BCDE
 3172 96F2 23                      INC      HL
 3173 96F3 7E                      LD       A,(HL)      ; Get MSB of FPREG
 3174 96F4 89                      ADC      A,C         ; Add MSB of BCDE
 3175 96F5 4F                      LD       C,A         ; Save MSB of BCDE
 3176 96F6 C9                      RET
 3177                   ;
 3178 96F7 21E805       COMPL:     LD       HL,SGNRES   ; Sign of result
 3179 96FA 7E                      LD       A,(HL)      ; Get sign of result
 3180 96FB 2F                      CPL                  ; Negate it
 3181 96FC 77                      LD       (HL),A      ; Put it back
 3182 96FD AF                      XOR      A
 3183 96FE 6F                      LD       L,A         ; Set L to zero
 3184 96FF 90                      SUB      B           ; Negate exponent,set c
 3185 9700 47                      LD       B,A         ; Re-save exponent
 3186 9701 7D                      LD       A,L         ; Load zero
 3187 9702 9B                      SBC      A,E         ; Negate LSB
 3188 9703 5F                      LD       E,A         ; Re-save LSB
 3189 9704 7D                      LD       A,L         ; Load zero
 3190 9705 9A                      SBC      A,D         ; Negate NMSB
 3191 9706 57                      LD       D,A         ; Re-save NMSB
 3192 9707 7D                      LD       A,L         ; Load zero
 3193 9708 99                      SBC      A,C         ; Negate MSB
 3194 9709 4F                      LD       C,A         ; Re-save MSB
 3195 970A C9                      RET
 3196                   ;
 3197 970B 0600         SCALE:     LD       B,0         ; Clear underflow
 3198 970D D608         SCALLP:    SUB      8           ; 8 bits (a whole byte)
 3199 970F DA1A97                  JP       C,SHRITE    ; No - Shift right A bi
 3200 9712 43                      LD       B,E         ; <- Shift
 3201 9713 5A                      LD       E,D         ; <- right
 3202 9714 51                      LD       D,C         ; <- eight
 3203 9715 0E00                    LD       C,0         ; <- bits
 3204 9717 C30D97                  JP       SCALLP      ; More bits to shift
 3205                   ;
 3206 971A C609         SHRITE:    ADD      A,8+1       ; Adjust count
 3207 971C 6F                      LD       L,A         ; Save bits to shift
 3208 971D AF           SHRLP:     XOR      A           ; Flag for all done
 3209 971E 2D                      DEC      L           ; All shifting done?
 3210 971F C8                      RET      Z           ; Yes - Return
 3211 9720 79                      LD       A,C         ; Get MSB
 3212 9721 1F           SHRT1:     RRA                  ; Shift it right
 3213 9722 4F                      LD       C,A         ; Re-save
 3214 9723 7A                      LD       A,D         ; Get NMSB
 3215 9724 1F                      RRA                  ; Shift right with last
 3216 9725 57                      LD       D,A         ; Re-save it
 3217 9726 7B                      LD       A,E         ; Get LSB
 3218 9727 1F                      RRA                  ; Shift right with last
 3219 9728 5F                      LD       E,A         ; Re-save it
 3220 9729 78                      LD       A,B         ; Get underflow
 3221 972A 1F                      RRA                  ; Shift right with last
 3222 972B 47                      LD       B,A         ; Re-save underflow
 3223 972C C31D97                  JP       SHRLP       ; More bits to do
 3224                   ;
 3225 972F 00000081     UNITY:     DB       000H,000H,000H,081H ; 1.00000
 3226                   ;
 3227 9733 03           LOGTAB:    DB       3           ; Table used by LOG
 3228 9734 AA561980                DB       0AAH,056H,019H,080H ; 0.59898
 3229 9738 F1227680                DB       0F1H,022H,076H,080H ; 0.96147
 3230 973C 45AA3882                DB       045H,0AAH,038H,082H ; 2.88539
 3231                   ;
 3232 9740 CD8C98       LOG:       CALL     TSTSGN      ; Test sign of value
 3233 9743 B7                      OR       A
 3234 9744 EA018B                  JP       PE,FCERR    ; ?FC Error if <= zero
 3235 9747 21E705                  LD       HL,FPEXP    ; Point to exponent
 3236 974A 7E                      LD       A,(HL)      ; Get exponent
 3237 974B 013580                  LD       BC,8035H    ; BCDE = SQR(1/2)
 3238 974E 11F304                  LD       DE,04F3H
 3239 9751 90                      SUB      B           ; Scale value to be < 1
 3240 9752 F5                      PUSH     AF          ; Save scale factor
 3241 9753 70                      LD       (HL),B      ; Save new exponent
 3242 9754 D5                      PUSH     DE          ; Save SQR(1/2)
 3243 9755 C5                      PUSH     BC
 3244 9756 CD4696                  CALL     FPADD       ; Add SQR(1/2) to value
 3245 9759 C1                      POP      BC          ; Restore SQR(1/2)
 3246 975A D1                      POP      DE
 3247 975B 04                      INC      B           ; Make it SQR(2)
 3248 975C CDE297                  CALL     DVBCDE      ; Divide by SQR(2)
 3249 975F 212F97                  LD       HL,UNITY    ; Point to 1.
 3250 9762 CD3D96                  CALL     SUBPHL      ; Subtract FPREG from 1
 3251 9765 213397                  LD       HL,LOGTAB   ; Coefficient table
 3252 9768 CDD49B                  CALL     SUMSER      ; Evaluate sum of serie
 3253 976B 018080                  LD       BC,8080H    ; BCDE = -0.5
 3254 976E 110000                  LD       DE,0000H
 3255 9771 CD4696                  CALL     FPADD       ; Subtract 0.5 from FPR
 3256 9774 F1                      POP      AF          ; Restore scale factor
 3257 9775 CD079A                  CALL     RSCALE      ; Re-scale number
 3258 9778 013180       MULLN2:    LD       BC,8031H    ; BCDE = Ln(2)
 3259 977B 111872                  LD       DE,7218H
 3260 977E 21                      DB       21H         ; Skip "POP BC" and "PO
 3261                   ;
 3262 977F C1           MULT:      POP      BC          ; Get number from stack
 3263 9780 D1                      POP      DE
 3264 9781 CD8C98       FPMULT:    CALL     TSTSGN      ; Test sign of FPREG
 3265 9784 C8                      RET      Z           ; Return zero if zero
 3266 9785 2E00                    LD       L,0         ; Flag add exponents
 3267 9787 CD4A98                  CALL     ADDEXP      ; Add exponents
 3268 978A 79                      LD       A,C         ; Get MSB of multiplier
 3269 978B 32F605                  LD       (MULVAL),A  ; Save MSB of multiplie
 3270 978E EB                      EX       DE,HL
 3271 978F 22F705                  LD       (MULVAL+1),HL ; Save rest of multip
 3272 9792 010000                  LD       BC,0        ; Partial product (BCDE
 3273 9795 50                      LD       D,B
 3274 9796 58                      LD       E,B
 3275 9797 219796                  LD       HL,BNORM    ; Address of normalise
 3276 979A E5                      PUSH     HL          ; Save for return
 3277 979B 21A397                  LD       HL,MULT8    ; Address of 8 bit mult
 3278 979E E5                      PUSH     HL          ; Save for NMSB,MSB
 3279 979F E5                      PUSH     HL          ;
 3280 97A0 21E405                  LD       HL,FPREG    ; Point to number
 3281 97A3 7E           MULT8:     LD       A,(HL)      ; Get LSB of number
 3282 97A4 23                      INC      HL          ; Point to NMSB
 3283 97A5 B7                      OR       A           ; Test LSB
 3284 97A6 CACF97                  JP       Z,BYTSFT    ; Zero - shift to next 
 3285 97A9 E5                      PUSH     HL          ; Save address of numbe
 3286 97AA 2E08                    LD       L,8         ; 8 bits to multiply by
 3287 97AC 1F           MUL8LP:    RRA                  ; Shift LSB right
 3288 97AD 67                      LD       H,A         ; Save LSB
 3289 97AE 79                      LD       A,C         ; Get MSB
 3290 97AF D2BD97                  JP       NC,NOMADD   ; Bit was zero - Don't 
 3291 97B2 E5                      PUSH     HL          ; Save LSB and count
 3292 97B3 2AF705                  LD       HL,(MULVAL+1) ; Get LSB and NMSB
 3293 97B6 19                      ADD      HL,DE       ; Add NMSB and LSB
 3294 97B7 EB                      EX       DE,HL       ; Leave sum in DE
 3295 97B8 E1                      POP      HL          ; Restore MSB and count
 3296 97B9 3AF605                  LD       A,(MULVAL)  ; Get MSB of multiplier
 3297 97BC 89                      ADC      A,C         ; Add MSB
 3298 97BD 1F           NOMADD:    RRA                  ; Shift MSB right
 3299 97BE 4F                      LD       C,A         ; Re-save MSB
 3300 97BF 7A                      LD       A,D         ; Get NMSB
 3301 97C0 1F                      RRA                  ; Shift NMSB right
 3302 97C1 57                      LD       D,A         ; Re-save NMSB
 3303 97C2 7B                      LD       A,E         ; Get LSB
 3304 97C3 1F                      RRA                  ; Shift LSB right
 3305 97C4 5F                      LD       E,A         ; Re-save LSB
 3306 97C5 78                      LD       A,B         ; Get VLSB
 3307 97C6 1F                      RRA                  ; Shift VLSB right
 3308 97C7 47                      LD       B,A         ; Re-save VLSB
 3309 97C8 2D                      DEC      L           ; Count bits multiplied
 3310 97C9 7C                      LD       A,H         ; Get LSB of multiplier
 3311 97CA C2AC97                  JP       NZ,MUL8LP   ; More - Do it
 3312 97CD E1           POPHRT:    POP      HL          ; Restore address of nu
 3313 97CE C9                      RET
 3314                   ;
 3315 97CF 43           BYTSFT:    LD       B,E         ; Shift partial product
 3316 97D0 5A                      LD       E,D
 3317 97D1 51                      LD       D,C
 3318 97D2 4F                      LD       C,A
 3319 97D3 C9                      RET
 3320                   ;
 3321 97D4 CDBD98       DIV10:     CALL     STAKFP      ; Save FPREG on stack
 3322 97D7 012084                  LD       BC,8420H    ; BCDE = 10.
 3323 97DA 110000                  LD       DE,0000H
 3324 97DD CDCD98                  CALL     FPBCDE      ; Move 10 to FPREG
 3325                   ;
 3326 97E0 C1           DIV:       POP      BC          ; Get number from stack
 3327 97E1 D1                      POP      DE
 3328 97E2 CD8C98       DVBCDE:    CALL     TSTSGN      ; Test sign of FPREG
 3329 97E5 CAD785                  JP       Z,DZERR     ; Error if division by 
 3330 97E8 2EFF                    LD       L,-1        ; Flag subtract exponen
 3331 97EA CD4A98                  CALL     ADDEXP      ; Subtract exponents
 3332 97ED 34                      INC      (HL)        ; Add 2 to exponent to 
 3333 97EE 34                      INC      (HL)
 3334 97EF 2B                      DEC      HL          ; Point to MSB
 3335 97F0 7E                      LD       A,(HL)      ; Get MSB of dividend
 3336 97F1 321205                  LD       (DIV3),A    ; Save for subtraction
 3337 97F4 2B                      DEC      HL
 3338 97F5 7E                      LD       A,(HL)      ; Get NMSB of dividend
 3339 97F6 320E05                  LD       (DIV2),A    ; Save for subtraction
 3340 97F9 2B                      DEC      HL
 3341 97FA 7E                      LD       A,(HL)      ; Get MSB of dividend
 3342 97FB 320A05                  LD       (DIV1),A    ; Save for subtraction
 3343 97FE 41                      LD       B,C         ; Get MSB
 3344 97FF EB                      EX       DE,HL       ; NMSB,LSB to HL
 3345 9800 AF                      XOR      A
 3346 9801 4F                      LD       C,A         ; Clear MSB of quotient
 3347 9802 57                      LD       D,A         ; Clear NMSB of quotien
 3348 9803 5F                      LD       E,A         ; Clear LSB of quotient
 3349 9804 321505                  LD       (DIV4),A    ; Clear overflow count
 3350 9807 E5           DIVLP:     PUSH     HL          ; Save divisor
 3351 9808 C5                      PUSH     BC
 3352 9809 7D                      LD       A,L         ; Get LSB of number
 3353 980A CD0905                  CALL     DIVSUP      ; Subt' divisor from di
 3354 980D DE00                    SBC      A,0         ; Count for overflows
 3355 980F 3F                      CCF
 3356 9810 D21A98                  JP       NC,RESDIV   ; Restore divisor if bo
 3357 9813 321505                  LD       (DIV4),A    ; Re-save overflow coun
 3358 9816 F1                      POP      AF          ; Scrap divisor
 3359 9817 F1                      POP      AF
 3360 9818 37                      SCF                  ; Set carry to
 3361 9819 D2                      DB       0D2H        ; Skip "POP BC" and "PO
 3362                   ;
 3363 981A C1           RESDIV:    POP      BC          ; Restore divisor
 3364 981B E1                      POP      HL
 3365 981C 79                      LD       A,C         ; Get MSB of quotient
 3366 981D 3C                      INC      A
 3367 981E 3D                      DEC      A
 3368 981F 1F                      RRA                  ; Bit 0 to bit 7
 3369 9820 FACD96                  JP       M,RONDB     ; Done - Normalise resu
 3370 9823 17                      RLA                  ; Restore carry
 3371 9824 7B                      LD       A,E         ; Get LSB of quotient
 3372 9825 17                      RLA                  ; Double it
 3373 9826 5F                      LD       E,A         ; Put it back
 3374 9827 7A                      LD       A,D         ; Get NMSB of quotient
 3375 9828 17                      RLA                  ; Double it
 3376 9829 57                      LD       D,A         ; Put it back
 3377 982A 79                      LD       A,C         ; Get MSB of quotient
 3378 982B 17                      RLA                  ; Double it
 3379 982C 4F                      LD       C,A         ; Put it back
 3380 982D 29                      ADD      HL,HL       ; Double NMSB,LSB of di
 3381 982E 78                      LD       A,B         ; Get MSB of divisor
 3382 982F 17                      RLA                  ; Double it
 3383 9830 47                      LD       B,A         ; Put it back
 3384 9831 3A1505                  LD       A,(DIV4)    ; Get VLSB of quotient
 3385 9834 17                      RLA                  ; Double it
 3386 9835 321505                  LD       (DIV4),A    ; Put it back
 3387 9838 79                      LD       A,C         ; Get MSB of quotient
 3388 9839 B2                      OR       D           ; Merge NMSB
 3389 983A B3                      OR       E           ; Merge LSB
 3390 983B C20798                  JP       NZ,DIVLP    ; Not done - Keep divid
 3391 983E E5                      PUSH     HL          ; Save divisor
 3392 983F 21E705                  LD       HL,FPEXP    ; Point to exponent
 3393 9842 35                      DEC      (HL)        ; Divide by 2
 3394 9843 E1                      POP      HL          ; Restore divisor
 3395 9844 C20798                  JP       NZ,DIVLP    ; Ok - Keep going
 3396 9847 C3E385                  JP       OVERR       ; Overflow error
 3397                   ;
 3398 984A 78           ADDEXP:    LD       A,B         ; Get exponent of divid
 3399 984B B7                      OR       A           ; Test it
 3400 984C CA6E98                  JP       Z,OVTST3    ; Zero - Result zero
 3401 984F 7D                      LD       A,L         ; Get add/subtract flag
 3402 9850 21E705                  LD       HL,FPEXP    ; Point to exponent
 3403 9853 AE                      XOR      (HL)        ; Add or subtract it
 3404 9854 80                      ADD      A,B         ; Add the other exponen
 3405 9855 47                      LD       B,A         ; Save new exponent
 3406 9856 1F                      RRA                  ; Test exponent for ove
 3407 9857 A8                      XOR      B
 3408 9858 78                      LD       A,B         ; Get exponent
 3409 9859 F26D98                  JP       P,OVTST2    ; Positive - Test for o
 3410 985C C680                    ADD      A,80H       ; Add excess 128
 3411 985E 77                      LD       (HL),A      ; Save new exponent
 3412 985F CACD97                  JP       Z,POPHRT    ; Zero - Result zero
 3413 9862 CDF298                  CALL     SIGNS       ; Set MSBs and sign of 
 3414 9865 77                      LD       (HL),A      ; Save new exponent
 3415 9866 2B                      DEC      HL          ; Point to MSB
 3416 9867 C9                      RET
 3417                   ;
 3418 9868 CD8C98       OVTST1:    CALL     TSTSGN      ; Test sign of FPREG
 3419 986B 2F                      CPL                  ; Invert sign
 3420 986C E1                      POP      HL          ; Clean up stack
 3421 986D B7           OVTST2:    OR       A           ; Test if new exponent 
 3422 986E E1           OVTST3:    POP      HL          ; Clear off return addr
 3423 986F F2AC96                  JP       P,RESZER    ; Result zero
 3424 9872 C3E385                  JP       OVERR       ; Overflow error
 3425                   ;
 3426 9875 CDD898       MLSP10:    CALL     BCDEFP      ; Move FPREG to BCDE
 3427 9878 78                      LD       A,B         ; Get exponent
 3428 9879 B7                      OR       A           ; Is it zero?
 3429 987A C8                      RET      Z           ; Yes - Result is zero
 3430 987B C602                    ADD      A,2         ; Multiply by 4
 3431 987D DAE385                  JP       C,OVERR     ; Overflow - ?OV Error
 3432 9880 47                      LD       B,A         ; Re-save exponent
 3433 9881 CD4696                  CALL     FPADD       ; Add BCDE to FPREG (Ti
 3434 9884 21E705                  LD       HL,FPEXP    ; Point to exponent
 3435 9887 34                      INC      (HL)        ; Double number (Times 
 3436 9888 C0                      RET      NZ          ; Ok - Return
 3437 9889 C3E385                  JP       OVERR       ; Overflow error
 3438                   ;
 3439 988C 3AE705       TSTSGN:    LD       A,(FPEXP)   ; Get sign of FPREG
 3440 988F B7                      OR       A
 3441 9890 C8                      RET      Z           ; RETurn if number is z
 3442 9891 3AE605                  LD       A,(FPREG+2) ; Get MSB of FPREG
 3443 9894 FE                      DB       0FEH        ; Test sign
 3444 9895 2F           RETREL:    CPL                  ; Invert sign
 3445 9896 17                      RLA                  ; Sign bit to carry
 3446 9897 9F           FLGDIF:    SBC      A,A         ; Carry to all bits of 
 3447 9898 C0                      RET      NZ          ; Return -1 if negative
 3448 9899 3C                      INC      A           ; Bump to +1
 3449 989A C9                      RET                  ; Positive - Return +1
 3450                   ;
 3451 989B CD8C98       SGN:       CALL     TSTSGN      ; Test sign of FPREG
 3452 989E 0688         FLGREL:    LD       B,80H+8     ; 8 bit integer in expo
 3453 98A0 110000                  LD       DE,0        ; Zero NMSB and LSB
 3454 98A3 21E705       RETINT:    LD       HL,FPEXP    ; Point to exponent
 3455 98A6 4F                      LD       C,A         ; CDE = MSB,NMSB and LS
 3456 98A7 70                      LD       (HL),B      ; Save exponent
 3457 98A8 0600                    LD       B,0         ; CDE = integer to norm
 3458 98AA 23                      INC      HL          ; Point to sign of resu
 3459 98AB 3680                    LD       (HL),80H    ; Set sign of result
 3460 98AD 17                      RLA                  ; Carry = sign of integ
 3461 98AE C39496                  JP       CONPOS      ; Set sign of result
 3462                   ;
 3463 98B1 CD8C98       ABS:       CALL     TSTSGN      ; Test sign of FPREG
 3464 98B4 F0                      RET      P           ; Return if positive
 3465 98B5 21E605       INVSGN:    LD       HL,FPREG+2  ; Point to MSB
 3466 98B8 7E                      LD       A,(HL)      ; Get sign of mantissa
 3467 98B9 EE80                    XOR      80H         ; Invert sign of mantis
 3468 98BB 77                      LD       (HL),A      ; Re-save sign of manti
 3469 98BC C9                      RET
 3470                   ;
 3471 98BD EB           STAKFP:    EX       DE,HL       ; Save code string addr
 3472 98BE 2AE405                  LD       HL,(FPREG)  ; LSB,NLSB of FPREG
 3473 98C1 E3                      EX       (SP),HL     ; Stack them,get return
 3474 98C2 E5                      PUSH     HL          ; Re-save return
 3475 98C3 2AE605                  LD       HL,(FPREG+2) ; MSB and exponent of 
 3476 98C6 E3                      EX       (SP),HL     ; Stack them,get return
 3477 98C7 E5                      PUSH     HL          ; Re-save return
 3478 98C8 EB                      EX       DE,HL       ; Restore code string a
 3479 98C9 C9                      RET
 3480                   ;
 3481 98CA CDDB98       PHLTFP:    CALL     LOADFP      ; Number at HL to BCDE
 3482 98CD EB           FPBCDE:    EX       DE,HL       ; Save code string addr
 3483 98CE 22E405                  LD       (FPREG),HL  ; Save LSB,NLSB of numb
 3484 98D1 60                      LD       H,B         ; Exponent of number
 3485 98D2 69                      LD       L,C         ; MSB of number
 3486 98D3 22E605                  LD       (FPREG+2),HL ; Save MSB and exponen
 3487 98D6 EB                      EX       DE,HL       ; Restore code string a
 3488 98D7 C9                      RET
 3489                   ;
 3490 98D8 21E405       BCDEFP:    LD       HL,FPREG    ; Point to FPREG
 3491 98DB 5E           LOADFP:    LD       E,(HL)      ; Get LSB of number
 3492 98DC 23                      INC      HL
 3493 98DD 56                      LD       D,(HL)      ; Get NMSB of number
 3494 98DE 23                      INC      HL
 3495 98DF 4E                      LD       C,(HL)      ; Get MSB of number
 3496 98E0 23                      INC      HL
 3497 98E1 46                      LD       B,(HL)      ; Get exponent of numbe
 3498 98E2 23           INCHL:     INC      HL          ; Used for conditional 
 3499 98E3 C9                      RET
 3500                   ;
 3501 98E4 11E405       FPTHL:     LD       DE,FPREG    ; Point to FPREG
 3502 98E7 0604         DETHL4:    LD       B,4         ; 4 bytes to move
 3503 98E9 1A           DETHLB:    LD       A,(DE)      ; Get source
 3504 98EA 77                      LD       (HL),A      ; Save destination
 3505 98EB 13                      INC      DE          ; Next source
 3506 98EC 23                      INC      HL          ; Next destination
 3507 98ED 05                      DEC      B           ; Count bytes
 3508 98EE C2E998                  JP       NZ,DETHLB   ; Loop if more
 3509 98F1 C9                      RET
 3510                   ;
 3511 98F2 21E605       SIGNS:     LD       HL,FPREG+2  ; Point to MSB of FPREG
 3512 98F5 7E                      LD       A,(HL)      ; Get MSB
 3513 98F6 07                      RLCA                 ; Old sign to carry
 3514 98F7 37                      SCF                  ; Set MSBit
 3515 98F8 1F                      RRA                  ; Set MSBit of MSB
 3516 98F9 77                      LD       (HL),A      ; Save new MSB
 3517 98FA 3F                      CCF                  ; Complement sign
 3518 98FB 1F                      RRA                  ; Old sign to carry
 3519 98FC 23                      INC      HL
 3520 98FD 23                      INC      HL
 3521 98FE 77                      LD       (HL),A      ; Set sign of result
 3522 98FF 79                      LD       A,C         ; Get MSB
 3523 9900 07                      RLCA                 ; Old sign to carry
 3524 9901 37                      SCF                  ; Set MSBit
 3525 9902 1F                      RRA                  ; Set MSBit of MSB
 3526 9903 4F                      LD       C,A         ; Save MSB
 3527 9904 1F                      RRA
 3528 9905 AE                      XOR      (HL)        ; New sign of result
 3529 9906 C9                      RET
 3530                   ;
 3531 9907 78           CMPNUM:    LD       A,B         ; Get exponent of numbe
 3532 9908 B7                      OR       A
 3533 9909 CA8C98                  JP       Z,TSTSGN    ; Zero - Test sign of F
 3534 990C 219598                  LD       HL,RETREL   ; Return relation routi
 3535 990F E5                      PUSH     HL          ; Save for return
 3536 9910 CD8C98                  CALL     TSTSGN      ; Test sign of FPREG
 3537 9913 79                      LD       A,C         ; Get MSB of number
 3538 9914 C8                      RET      Z           ; FPREG zero - Number's
 3539 9915 21E605                  LD       HL,FPREG+2  ; MSB of FPREG
 3540 9918 AE                      XOR      (HL)        ; Combine signs
 3541 9919 79                      LD       A,C         ; Get MSB of number
 3542 991A F8                      RET      M           ; Exit if signs differe
 3543 991B CD2199                  CALL     CMPFP       ; Compare FP numbers
 3544 991E 1F                      RRA                  ; Get carry to sign
 3545 991F A9                      XOR      C           ; Combine with MSB of n
 3546 9920 C9                      RET
 3547                   ;
 3548 9921 23           CMPFP:     INC      HL          ; Point to exponent
 3549 9922 78                      LD       A,B         ; Get exponent
 3550 9923 BE                      CP       (HL)        ; Compare exponents
 3551 9924 C0                      RET      NZ          ; Different
 3552 9925 2B                      DEC      HL          ; Point to MBS
 3553 9926 79                      LD       A,C         ; Get MSB
 3554 9927 BE                      CP       (HL)        ; Compare MSBs
 3555 9928 C0                      RET      NZ          ; Different
 3556 9929 2B                      DEC      HL          ; Point to NMSB
 3557 992A 7A                      LD       A,D         ; Get NMSB
 3558 992B BE                      CP       (HL)        ; Compare NMSBs
 3559 992C C0                      RET      NZ          ; Different
 3560 992D 2B                      DEC      HL          ; Point to LSB
 3561 992E 7B                      LD       A,E         ; Get LSB
 3562 992F 96                      SUB      (HL)        ; Compare LSBs
 3563 9930 C0                      RET      NZ          ; Different
 3564 9931 E1                      POP      HL          ; Drop RETurn
 3565 9932 E1                      POP      HL          ; Drop another RETurn
 3566 9933 C9                      RET
 3567                   ;
 3568 9934 47           FPINT:     LD       B,A         ; <- Move
 3569 9935 4F                      LD       C,A         ; <- exponent
 3570 9936 57                      LD       D,A         ; <- to all
 3571 9937 5F                      LD       E,A         ; <- bits
 3572 9938 B7                      OR       A           ; Test exponent
 3573 9939 C8                      RET      Z           ; Zero - Return zero
 3574 993A E5                      PUSH     HL          ; Save pointer to numbe
 3575 993B CDD898                  CALL     BCDEFP      ; Move FPREG to BCDE
 3576 993E CDF298                  CALL     SIGNS       ; Set MSBs & sign of re
 3577 9941 AE                      XOR      (HL)        ; Combine with sign of 
 3578 9942 67                      LD       H,A         ; Save combined signs
 3579 9943 FC5899                  CALL     M,DCBCDE    ; Negative - Decrement 
 3580 9946 3E98                    LD       A,80H+24    ; 24 bits
 3581 9948 90                      SUB      B           ; Bits to shift
 3582 9949 CD0B97                  CALL     SCALE       ; Shift BCDE
 3583 994C 7C                      LD       A,H         ; Get combined sign
 3584 994D 17                      RLA                  ; Sign to carry
 3585 994E DCDE96                  CALL     C,FPROND    ; Negative - Round numb
 3586 9951 0600                    LD       B,0         ; Zero exponent
 3587 9953 DCF796                  CALL     C,COMPL     ; If negative make posi
 3588 9956 E1                      POP      HL          ; Restore pointer to nu
 3589 9957 C9                      RET
 3590                   ;
 3591 9958 1B           DCBCDE:    DEC      DE          ; Decrement BCDE
 3592 9959 7A                      LD       A,D         ; Test LSBs
 3593 995A A3                      AND      E
 3594 995B 3C                      INC      A
 3595 995C C0                      RET      NZ          ; Exit if LSBs not FFFF
 3596 995D 0B                      DEC      BC          ; Decrement MSBs
 3597 995E C9                      RET
 3598                   ;
 3599 995F 21E705       INT:       LD       HL,FPEXP    ; Point to exponent
 3600 9962 7E                      LD       A,(HL)      ; Get exponent
 3601 9963 FE98                    CP       80H+24      ; Integer accuracy only
 3602 9965 3AE405                  LD       A,(FPREG)   ; Get LSB
 3603 9968 D0                      RET      NC          ; Yes - Already integer
 3604 9969 7E                      LD       A,(HL)      ; Get exponent
 3605 996A CD3499                  CALL     FPINT       ; F.P to integer
 3606 996D 3698                    LD       (HL),80H+24 ; Save 24 bit integer
 3607 996F 7B                      LD       A,E         ; Get LSB of number
 3608 9970 F5                      PUSH     AF          ; Save LSB
 3609 9971 79                      LD       A,C         ; Get MSB of number
 3610 9972 17                      RLA                  ; Sign to carry
 3611 9973 CD9496                  CALL     CONPOS      ; Set sign of result
 3612 9976 F1                      POP      AF          ; Restore LSB of number
 3613 9977 C9                      RET
 3614                   ;
 3615 9978 210000       MLDEBC:    LD       HL,0        ; Clear partial product
 3616 997B 78                      LD       A,B         ; Test multiplier
 3617 997C B1                      OR       C
 3618 997D C8                      RET      Z           ; Return zero if zero
 3619 997E 3E10                    LD       A,16        ; 16 bits
 3620 9980 29           MLDBLP:    ADD      HL,HL       ; Shift P.P left
 3621 9981 DAB691                  JP       C,BSERR     ; ?BS Error if overflow
 3622 9984 EB                      EX       DE,HL
 3623 9985 29                      ADD      HL,HL       ; Shift multiplier left
 3624 9986 EB                      EX       DE,HL
 3625 9987 D28E99                  JP       NC,NOMLAD   ; Bit was zero - No add
 3626 998A 09                      ADD      HL,BC       ; Add multiplicand
 3627 998B DAB691                  JP       C,BSERR     ; ?BS Error if overflow
 3628 998E 3D           NOMLAD:    DEC      A           ; Count bits
 3629 998F C28099                  JP       NZ,MLDBLP   ; More
 3630 9992 C9                      RET
 3631                   ;
 3632 9993 FE2D         ASCTFP:    CP       '-'         ; Negative?
 3633 9995 F5                      PUSH     AF          ; Save it and flags
 3634 9996 CA9F99                  JP       Z,CNVNUM    ; Yes - Convert number
 3635 9999 FE2B                    CP       '+'         ; Positive?
 3636 999B CA9F99                  JP       Z,CNVNUM    ; Yes - Convert number
 3637 999E 2B                      DEC      HL          ; DEC 'cos GETCHR INCs
 3638 999F CDAC96       CNVNUM:    CALL     RESZER      ; Set result to zero
 3639 99A2 47                      LD       B,A         ; Digits after point co
 3640 99A3 57                      LD       D,A         ; Sign of exponent
 3641 99A4 5F                      LD       E,A         ; Exponent of ten
 3642 99A5 2F                      CPL
 3643 99A6 4F                      LD       C,A         ; Before or after point
 3644 99A7 CD308A       MANLP:     CALL     GETCHR      ; Get next character
 3645 99AA DAF099                  JP       C,ADDIG     ; Digit - Add to number
 3646 99AD FE2E                    CP       '.'
 3647 99AF CACB99                  JP       Z,DPOINT    ; '.' - Flag point
 3648 99B2 FE45                    CP       'E'
 3649 99B4 C2CF99                  JP       NZ,CONEXP   ; Not 'E' - Scale numbe
 3650 99B7 CD308A                  CALL     GETCHR      ; Get next character
 3651 99BA CDE18F                  CALL     SGNEXP      ; Get sign of exponent
 3652 99BD CD308A       EXPLP:     CALL     GETCHR      ; Get next character
 3653 99C0 DA129A                  JP       C,EDIGIT    ; Digit - Add to expone
 3654 99C3 14                      INC      D           ; Is sign negative?
 3655 99C4 C2CF99                  JP       NZ,CONEXP   ; No - Scale number
 3656 99C7 AF                      XOR      A
 3657 99C8 93                      SUB      E           ; Negate exponent
 3658 99C9 5F                      LD       E,A         ; And re-save it
 3659 99CA 0C                      INC      C           ; Flag end of number
 3660 99CB 0C           DPOINT:    INC      C           ; Flag point passed
 3661 99CC CAA799                  JP       Z,MANLP     ; Zero - Get another di
 3662 99CF E5           CONEXP:    PUSH     HL          ; Save code string addr
 3663 99D0 7B                      LD       A,E         ; Get exponent
 3664 99D1 90                      SUB      B           ; Subtract digits after
 3665 99D2 F4E899       SCALMI:    CALL     P,SCALPL    ; Positive - Multiply n
 3666 99D5 F2DE99                  JP       P,ENDCON    ; Positive - All done
 3667 99D8 F5                      PUSH     AF          ; Save number of times 
 3668 99D9 CDD497                  CALL     DIV10       ; Divide by 10
 3669 99DC F1                      POP      AF          ; Restore count
 3670 99DD 3C                      INC      A           ; Count divides
 3671                   ;
 3672 99DE C2D299       ENDCON:    JP       NZ,SCALMI   ; More to do
 3673 99E1 D1                      POP      DE          ; Restore code string a
 3674 99E2 F1                      POP      AF          ; Restore sign of numbe
 3675 99E3 CCB598                  CALL     Z,INVSGN    ; Negative - Negate num
 3676 99E6 EB                      EX       DE,HL       ; Code string address t
 3677 99E7 C9                      RET
 3678                   ;
 3679 99E8 C8           SCALPL:    RET      Z           ; Exit if no scaling ne
 3680 99E9 F5           MULTEN:    PUSH     AF          ; Save count
 3681 99EA CD7598                  CALL     MLSP10      ; Multiply number by 10
 3682 99ED F1                      POP      AF          ; Restore count
 3683 99EE 3D                      DEC      A           ; Count multiplies
 3684 99EF C9                      RET
 3685                   ;
 3686 99F0 D5           ADDIG:     PUSH     DE          ; Save sign of exponent
 3687 99F1 57                      LD       D,A         ; Save digit
 3688 99F2 78                      LD       A,B         ; Get digits after poin
 3689 99F3 89                      ADC      A,C         ; Add one if after poin
 3690 99F4 47                      LD       B,A         ; Re-save counter
 3691 99F5 C5                      PUSH     BC          ; Save point flags
 3692 99F6 E5                      PUSH     HL          ; Save code string addr
 3693 99F7 D5                      PUSH     DE          ; Save digit
 3694 99F8 CD7598                  CALL     MLSP10      ; Multiply number by 10
 3695 99FB F1                      POP      AF          ; Restore digit
 3696 99FC D630                    SUB      '0'         ; Make it absolute
 3697 99FE CD079A                  CALL     RSCALE      ; Re-scale number
 3698 9A01 E1                      POP      HL          ; Restore code string a
 3699 9A02 C1                      POP      BC          ; Restore point flags
 3700 9A03 D1                      POP      DE          ; Restore sign of expon
 3701 9A04 C3A799                  JP       MANLP       ; Get another digit
 3702                   ;
 3703 9A07 CDBD98       RSCALE:    CALL     STAKFP      ; Put number on stack
 3704 9A0A CD9E98                  CALL     FLGREL      ; Digit to add to FPREG
 3705 9A0D C1           PADD:      POP      BC          ; Restore number
 3706 9A0E D1                      POP      DE
 3707 9A0F C34696                  JP       FPADD       ; Add BCDE to FPREG and
 3708                   ;
 3709 9A12 7B           EDIGIT:    LD       A,E         ; Get digit
 3710 9A13 07                      RLCA                 ; Times 2
 3711 9A14 07                      RLCA                 ; Times 4
 3712 9A15 83                      ADD      A,E         ; Times 5
 3713 9A16 07                      RLCA                 ; Times 10
 3714 9A17 86                      ADD      A,(HL)      ; Add next digit
 3715 9A18 D630                    SUB      '0'         ; Make it absolute
 3716 9A1A 5F                      LD       E,A         ; Save new digit
 3717 9A1B C3BD99                  JP       EXPLP       ; Look for another digi
 3718                   ;
 3719 9A1E E5           LINEIN:    PUSH     HL          ; Save code string addr
 3720 9A1F 216C85                  LD       HL,INMSG    ; Output " in "
 3721 9A22 CD8193                  CALL     PRS         ; Output string at HL
 3722 9A25 E1                      POP      HL          ; Restore code string a
 3723 9A26 EB           PRNTHL:    EX       DE,HL       ; Code string address t
 3724 9A27 AF                      XOR      A
 3725 9A28 0698                    LD       B,80H+24    ; 24 bits
 3726 9A2A CDA398                  CALL     RETINT      ; Return the integer
 3727 9A2D 218093                  LD       HL,PRNUMS   ; Print number string
 3728 9A30 E5                      PUSH     HL          ; Save for return
 3729 9A31 21E905       NUMASC:    LD       HL,PBUFF    ; Convert number to ASC
 3730 9A34 E5                      PUSH     HL          ; Save for return
 3731 9A35 CD8C98                  CALL     TSTSGN      ; Test sign of FPREG
 3732 9A38 3620                    LD       (HL),' '    ; Space at start
 3733 9A3A F23F9A                  JP       P,SPCFST    ; Positive - Space to s
 3734 9A3D 362D                    LD       (HL),'-'    ; '-' sign at start
 3735 9A3F 23           SPCFST:    INC      HL          ; First byte of number
 3736 9A40 3630                    LD       (HL),'0'    ; '0' if zero
 3737 9A42 CAF59A                  JP       Z,JSTZER    ; Return '0' if zero
 3738 9A45 E5                      PUSH     HL          ; Save buffer address
 3739 9A46 FCB598                  CALL     M,INVSGN    ; Negate FPREG if negat
 3740 9A49 AF                      XOR      A           ; Zero A
 3741 9A4A F5                      PUSH     AF          ; Save it
 3742 9A4B CDFB9A                  CALL     RNGTST      ; Test number is in ran
 3743 9A4E 014391       SIXDIG:    LD       BC,9143H    ; BCDE - 99999.9
 3744 9A51 11F84F                  LD       DE,4FF8H
 3745 9A54 CD0799                  CALL     CMPNUM      ; Compare numbers
 3746 9A57 B7                      OR       A
 3747 9A58 E26C9A                  JP       PO,INRNG    ; > 99999.9 - Sort it o
 3748 9A5B F1                      POP      AF          ; Restore count
 3749 9A5C CDE999                  CALL     MULTEN      ; Multiply by ten
 3750 9A5F F5                      PUSH     AF          ; Re-save count
 3751 9A60 C34E9A                  JP       SIXDIG      ; Test it again
 3752                   ;
 3753 9A63 CDD497       GTSIXD:    CALL     DIV10       ; Divide by 10
 3754 9A66 F1                      POP      AF          ; Get count
 3755 9A67 3C                      INC      A           ; Count divides
 3756 9A68 F5                      PUSH     AF          ; Re-save count
 3757 9A69 CDFB9A                  CALL     RNGTST      ; Test number is in ran
 3758 9A6C CD3496       INRNG:     CALL     ROUND       ; Add 0.5 to FPREG
 3759 9A6F 3C                      INC      A
 3760 9A70 CD3499                  CALL     FPINT       ; F.P to integer
 3761 9A73 CDCD98                  CALL     FPBCDE      ; Move BCDE to FPREG
 3762 9A76 010603                  LD       BC,0306H    ; 1E+06 to 1E-03 range
 3763 9A79 F1                      POP      AF          ; Restore count
 3764 9A7A 81                      ADD      A,C         ; 6 digits before point
 3765 9A7B 3C                      INC      A           ; Add one
 3766 9A7C FA889A                  JP       M,MAKNUM    ; Do it in 'E' form if 
 3767 9A7F FE08                    CP       6+1+1       ; More than 999999 ?
 3768 9A81 D2889A                  JP       NC,MAKNUM   ; Yes - Do it in 'E' fo
 3769 9A84 3C                      INC      A           ; Adjust for exponent
 3770 9A85 47                      LD       B,A         ; Exponent of number
 3771 9A86 3E02                    LD       A,2         ; Make it zero after
 3772                   ;
 3773 9A88 3D           MAKNUM:    DEC      A           ; Adjust for digits to 
 3774 9A89 3D                      DEC      A
 3775 9A8A E1                      POP      HL          ; Restore buffer addres
 3776 9A8B F5                      PUSH     AF          ; Save count
 3777 9A8C 110E9B                  LD       DE,POWERS   ; Powers of ten
 3778 9A8F 05                      DEC      B           ; Count digits before p
 3779 9A90 C2999A                  JP       NZ,DIGTXT   ; Not zero - Do number
 3780 9A93 362E                    LD       (HL),'.'    ; Save point
 3781 9A95 23                      INC      HL          ; Move on
 3782 9A96 3630                    LD       (HL),'0'    ; Save zero
 3783 9A98 23                      INC      HL          ; Move on
 3784 9A99 05           DIGTXT:    DEC      B           ; Count digits before p
 3785 9A9A 362E                    LD       (HL),'.'    ; Save point in case
 3786 9A9C CCE298                  CALL     Z,INCHL     ; Last digit - move on
 3787 9A9F C5                      PUSH     BC          ; Save digits before po
 3788 9AA0 E5                      PUSH     HL          ; Save buffer address
 3789 9AA1 D5                      PUSH     DE          ; Save powers of ten
 3790 9AA2 CDD898                  CALL     BCDEFP      ; Move FPREG to BCDE
 3791 9AA5 E1                      POP      HL          ; Powers of ten table
 3792 9AA6 062F                    LD       B, '0'-1    ; ASCII '0' - 1
 3793 9AA8 04           TRYAGN:    INC      B           ; Count subtractions
 3794 9AA9 7B                      LD       A,E         ; Get LSB
 3795 9AAA 96                      SUB      (HL)        ; Subtract LSB
 3796 9AAB 5F                      LD       E,A         ; Save LSB
 3797 9AAC 23                      INC      HL
 3798 9AAD 7A                      LD       A,D         ; Get NMSB
 3799 9AAE 9E                      SBC      A,(HL)      ; Subtract NMSB
 3800 9AAF 57                      LD       D,A         ; Save NMSB
 3801 9AB0 23                      INC      HL
 3802 9AB1 79                      LD       A,C         ; Get MSB
 3803 9AB2 9E                      SBC      A,(HL)      ; Subtract MSB
 3804 9AB3 4F                      LD       C,A         ; Save MSB
 3805 9AB4 2B                      DEC      HL          ; Point back to start
 3806 9AB5 2B                      DEC      HL
 3807 9AB6 D2A89A                  JP       NC,TRYAGN   ; No overflow - Try aga
 3808 9AB9 CDEB96                  CALL     PLUCDE      ; Restore number
 3809 9ABC 23                      INC      HL          ; Start of next number
 3810 9ABD CDCD98                  CALL     FPBCDE      ; Move BCDE to FPREG
 3811 9AC0 EB                      EX       DE,HL       ; Save point in table
 3812 9AC1 E1                      POP      HL          ; Restore buffer addres
 3813 9AC2 70                      LD       (HL),B      ; Save digit in buffer
 3814 9AC3 23                      INC      HL          ; And move on
 3815 9AC4 C1                      POP      BC          ; Restore digit count
 3816 9AC5 0D                      DEC      C           ; Count digits
 3817 9AC6 C2999A                  JP       NZ,DIGTXT   ; More - Do them
 3818 9AC9 05                      DEC      B           ; Any decimal part?
 3819 9ACA CAD99A                  JP       Z,DOEBIT    ; No - Do 'E' bit
 3820 9ACD 2B           SUPTLZ:    DEC      HL          ; Move back through buf
 3821 9ACE 7E                      LD       A,(HL)      ; Get character
 3822 9ACF FE30                    CP       '0'         ; '0' character?
 3823 9AD1 CACD9A                  JP       Z,SUPTLZ    ; Yes - Look back for m
 3824 9AD4 FE2E                    CP       '.'         ; A decimal point?
 3825 9AD6 C4E298                  CALL     NZ,INCHL    ; Move back over digit
 3826                   ;
 3827 9AD9 F1           DOEBIT:    POP      AF          ; Get 'E' flag
 3828 9ADA CAF89A                  JP       Z,NOENED    ; No 'E' needed - End b
 3829 9ADD 3645                    LD       (HL),'E'    ; Put 'E' in buffer
 3830 9ADF 23                      INC      HL          ; And move on
 3831 9AE0 362B                    LD       (HL),'+'    ; Put '+' in buffer
 3832 9AE2 F2E99A                  JP       P,OUTEXP    ; Positive - Output exp
 3833 9AE5 362D                    LD       (HL),'-'    ; Put '-' in buffer
 3834 9AE7 2F                      CPL                  ; Negate exponent
 3835 9AE8 3C                      INC      A
 3836 9AE9 062F         OUTEXP:    LD       B,'0'-1     ; ASCII '0' - 1
 3837 9AEB 04           EXPTEN:    INC      B           ; Count subtractions
 3838 9AEC D60A                    SUB      10          ; Tens digit
 3839 9AEE D2EB9A                  JP       NC,EXPTEN   ; More to do
 3840 9AF1 C63A                    ADD      A,'0'+10    ; Restore and make ASCI
 3841 9AF3 23                      INC      HL          ; Move on
 3842 9AF4 70                      LD       (HL),B      ; Save MSB of exponent
 3843 9AF5 23           JSTZER:    INC      HL          ;
 3844 9AF6 77                      LD       (HL),A      ; Save LSB of exponent
 3845 9AF7 23                      INC      HL
 3846 9AF8 71           NOENED:    LD       (HL),C      ; Mark end of buffer
 3847 9AF9 E1                      POP      HL          ; Restore code string a
 3848 9AFA C9                      RET
 3849                   ;
 3850 9AFB 017494       RNGTST:    LD       BC,9474H    ; BCDE = 999999.
 3851 9AFE 11F723                  LD       DE,23F7H
 3852 9B01 CD0799                  CALL     CMPNUM      ; Compare numbers
 3853 9B04 B7                      OR       A
 3854 9B05 E1                      POP      HL          ; Return address to HL
 3855 9B06 E2639A                  JP       PO,GTSIXD   ; Too big - Divide by t
 3856 9B09 E9                      JP       (HL)        ; Otherwise return to c
 3857                   ;
 3858 9B0A 00000080     HALF:      DB       00H,00H,00H,80H ; 0.5
 3859                   ;
 3860 9B0E A08601       POWERS:    DB       0A0H,086H,001H ; 100000
 3861 9B11 102700                  DB       010H,027H,000H ; 10000
 3862 9B14 E80300                  DB       0E8H,003H,000H ; 1000
 3863 9B17 640000                  DB       064H,000H,000H ; 100
 3864 9B1A 0A0000                  DB       00AH,000H,000H ; 10
 3865 9B1D 010000                  DB       001H,000H,000H ; 1
 3866                   ;
 3867 9B20 21B598       NEGAFT:    LD       HL,INVSGN   ; Negate result
 3868 9B23 E3                      EX       (SP),HL     ; To be done after call
 3869 9B24 E9                      JP       (HL)        ; Return to caller
 3870                   ;
 3871 9B25 CDBD98       SQR:       CALL     STAKFP      ; Put value on stack
 3872 9B28 210A9B                  LD       HL,HALF     ; Set power to 1/2
 3873 9B2B CDCA98                  CALL     PHLTFP      ; Move 1/2 to FPREG
 3874                   ;
 3875 9B2E C1           POWER:     POP      BC          ; Get base
 3876 9B2F D1                      POP      DE
 3877 9B30 CD8C98                  CALL     TSTSGN      ; Test sign of power
 3878 9B33 78                      LD       A,B         ; Get exponent of base
 3879 9B34 CA739B                  JP       Z,EXP       ; Make result 1 if zero
 3880 9B37 F23E9B                  JP       P,POWER1    ; Positive base - Ok
 3881 9B3A B7                      OR       A           ; Zero to negative powe
 3882 9B3B CAD785                  JP       Z,DZERR     ; Yes - ?/0 Error
 3883 9B3E B7           POWER1:    OR       A           ; Base zero?
 3884 9B3F CAAD96                  JP       Z,SAVEXP    ; Yes - Return zero
 3885 9B42 D5                      PUSH     DE          ; Save base
 3886 9B43 C5                      PUSH     BC
 3887 9B44 79                      LD       A,C         ; Get MSB of base
 3888 9B45 F67F                    OR       01111111B   ; Get sign status
 3889 9B47 CDD898                  CALL     BCDEFP      ; Move power to BCDE
 3890 9B4A F25B9B                  JP       P,POWER2    ; Positive base - Ok
 3891 9B4D D5                      PUSH     DE          ; Save power
 3892 9B4E C5                      PUSH     BC
 3893 9B4F CD5F99                  CALL     INT         ; Get integer of power
 3894 9B52 C1                      POP      BC          ; Restore power
 3895 9B53 D1                      POP      DE
 3896 9B54 F5                      PUSH     AF          ; MSB of base
 3897 9B55 CD0799                  CALL     CMPNUM      ; Power an integer?
 3898 9B58 E1                      POP      HL          ; Restore MSB of base
 3899 9B59 7C                      LD       A,H         ; but don't affect flag
 3900 9B5A 1F                      RRA                  ; Exponent odd or even?
 3901 9B5B E1           POWER2:    POP      HL          ; Restore MSB and expon
 3902 9B5C 22E605                  LD       (FPREG+2),HL ; Save base in FPREG
 3903 9B5F E1                      POP      HL          ; LSBs of base
 3904 9B60 22E405                  LD       (FPREG),HL  ; Save in FPREG
 3905 9B63 DC209B                  CALL     C,NEGAFT    ; Odd power - Negate re
 3906 9B66 CCB598                  CALL     Z,INVSGN    ; Negative base - Negat
 3907 9B69 D5                      PUSH     DE          ; Save power
 3908 9B6A C5                      PUSH     BC
 3909 9B6B CD4097                  CALL     LOG         ; Get LOG of base
 3910 9B6E C1                      POP      BC          ; Restore power
 3911 9B6F D1                      POP      DE
 3912 9B70 CD8197                  CALL     FPMULT      ; Multiply LOG by power
 3913                   ;
 3914 9B73 CDBD98       EXP:       CALL     STAKFP      ; Put value on stack
 3915 9B76 013881                  LD       BC,08138H   ; BCDE = 1/Ln(2)
 3916 9B79 113BAA                  LD       DE,0AA3BH
 3917 9B7C CD8197                  CALL     FPMULT      ; Multiply value by 1/L
 3918 9B7F 3AE705                  LD       A,(FPEXP)   ; Get exponent
 3919 9B82 FE88                    CP       80H+8       ; Is it in range?
 3920 9B84 D26898                  JP       NC,OVTST1   ; No - Test for overflo
 3921 9B87 CD5F99                  CALL     INT         ; Get INT of FPREG
 3922 9B8A C680                    ADD      A,80H       ; For excess 128
 3923 9B8C C602                    ADD      A,2         ; Exponent > 126?
 3924 9B8E DA6898                  JP       C,OVTST1    ; Yes - Test for overfl
 3925 9B91 F5                      PUSH     AF          ; Save scaling factor
 3926 9B92 212F97                  LD       HL,UNITY    ; Point to 1.
 3927 9B95 CD3796                  CALL     ADDPHL      ; Add 1 to FPREG
 3928 9B98 CD7897                  CALL     MULLN2      ; Multiply by LN(2)
 3929 9B9B F1                      POP      AF          ; Restore scaling facto
 3930 9B9C C1                      POP      BC          ; Restore exponent
 3931 9B9D D1                      POP      DE
 3932 9B9E F5                      PUSH     AF          ; Save scaling factor
 3933 9B9F CD4396                  CALL     SUBCDE      ; Subtract exponent fro
 3934 9BA2 CDB598                  CALL     INVSGN      ; Negate result
 3935 9BA5 21B39B                  LD       HL,EXPTAB   ; Coefficient table
 3936 9BA8 CDE39B                  CALL     SMSER1      ; Sum the series
 3937 9BAB 110000                  LD       DE,0        ; Zero LSBs
 3938 9BAE C1                      POP      BC          ; Scaling factor
 3939 9BAF 4A                      LD       C,D         ; Zero MSB
 3940 9BB0 C38197                  JP       FPMULT      ; Scale result to corre
 3941                   ;
 3942 9BB3 08           EXPTAB:    DB       8           ; Table used by EXP
 3943 9BB4 402E9474                DB       040H,02EH,094H,074H ; -1/7! (-1/504
 3944 9BB8 704F2E77                DB       070H,04FH,02EH,077H ;  1/6! ( 1/720
 3945 9BBC 6E02887A                DB       06EH,002H,088H,07AH ; -1/5! (-1/120
 3946 9BC0 E6A02A7C                DB       0E6H,0A0H,02AH,07CH ;  1/4! ( 1/24)
 3947 9BC4 50AAAA7E                DB       050H,0AAH,0AAH,07EH ; -1/3! (-1/6)
 3948 9BC8 FFFF7F7F                DB       0FFH,0FFH,07FH,07FH ;  1/2! ( 1/2)
 3949 9BCC 00008081                DB       000H,000H,080H,081H ; -1/1! (-1/1)
 3950 9BD0 00000081                DB       000H,000H,000H,081H ;  1/0! ( 1/1)
 3951                   ;
 3952 9BD4 CDBD98       SUMSER:    CALL     STAKFP      ; Put FPREG on stack
 3953 9BD7 117F97                  LD       DE,MULT     ; Multiply by "X"
 3954 9BDA D5                      PUSH     DE          ; To be done after
 3955 9BDB E5                      PUSH     HL          ; Save address of table
 3956 9BDC CDD898                  CALL     BCDEFP      ; Move FPREG to BCDE
 3957 9BDF CD8197                  CALL     FPMULT      ; Square the value
 3958 9BE2 E1                      POP      HL          ; Restore address of ta
 3959 9BE3 CDBD98       SMSER1:    CALL     STAKFP      ; Put value on stack
 3960 9BE6 7E                      LD       A,(HL)      ; Get number of coeffic
 3961 9BE7 23                      INC      HL          ; Point to start of tab
 3962 9BE8 CDCA98                  CALL     PHLTFP      ; Move coefficient to F
 3963 9BEB 06                      DB       06H         ; Skip "POP AF"
 3964 9BEC F1           SUMLP:     POP      AF          ; Restore count
 3965 9BED C1                      POP      BC          ; Restore number
 3966 9BEE D1                      POP      DE
 3967 9BEF 3D                      DEC      A           ; Cont coefficients
 3968 9BF0 C8                      RET      Z           ; All done
 3969 9BF1 D5                      PUSH     DE          ; Save number
 3970 9BF2 C5                      PUSH     BC
 3971 9BF3 F5                      PUSH     AF          ; Save count
 3972 9BF4 E5                      PUSH     HL          ; Save address in table
 3973 9BF5 CD8197                  CALL     FPMULT      ; Multiply FPREG by BCD
 3974 9BF8 E1                      POP      HL          ; Restore address in ta
 3975 9BF9 CDDB98                  CALL     LOADFP      ; Number at HL to BCDE
 3976 9BFC E5                      PUSH     HL          ; Save address in table
 3977 9BFD CD4696                  CALL     FPADD       ; Add coefficient to FP
 3978 9C00 E1                      POP      HL          ; Restore address in ta
 3979 9C01 C3EC9B                  JP       SUMLP       ; More coefficients
 3980                   ;
 3981 9C04 CD8C98       RND:       CALL     TSTSGN      ; Test sign of FPREG
 3982 9C07 211905                  LD       HL,SEED+2   ; Random number seed
 3983 9C0A FA659C                  JP       M,RESEED    ; Negative - Re-seed
 3984 9C0D 213A05                  LD       HL,LSTRND   ; Last random number
 3985 9C10 CDCA98                  CALL     PHLTFP      ; Move last RND to FPRE
 3986 9C13 211905                  LD       HL,SEED+2   ; Random number seed
 3987 9C16 C8                      RET      Z           ; Return if RND(0)
 3988 9C17 86                      ADD      A,(HL)      ; Add (SEED)+2)
 3989 9C18 E607                    AND      00000111B   ; 0 to 7
 3990 9C1A 0600                    LD       B,0
 3991 9C1C 77                      LD       (HL),A      ; Re-save seed
 3992 9C1D 23                      INC      HL          ; Move to coefficient t
 3993 9C1E 87                      ADD      A,A         ; 4 bytes
 3994 9C1F 87                      ADD      A,A         ; per entry
 3995 9C20 4F                      LD       C,A         ; BC = Offset into tabl
 3996 9C21 09                      ADD      HL,BC       ; Point to coefficient
 3997 9C22 CDDB98                  CALL     LOADFP      ; Coefficient to BCDE
 3998 9C25 CD8197                  CALL     FPMULT      ;       ; Multiply FPRE
 3999 9C28 3A1805                  LD       A,(SEED+1)  ; Get (SEED+1)
 4000 9C2B 3C                      INC      A           ; Add 1
 4001 9C2C E603                    AND      00000011B   ; 0 to 3
 4002 9C2E 0600                    LD       B,0
 4003 9C30 FE01                    CP       1           ; Is it zero?
 4004 9C32 88                      ADC      A,B         ; Yes - Make it 1
 4005 9C33 321805                  LD       (SEED+1),A  ; Re-save seed
 4006 9C36 21699C                  LD       HL,RNDTAB-4 ; Addition table
 4007 9C39 87                      ADD      A,A         ; 4 bytes
 4008 9C3A 87                      ADD      A,A         ; per entry
 4009 9C3B 4F                      LD       C,A         ; BC = Offset into tabl
 4010 9C3C 09                      ADD      HL,BC       ; Point to value
 4011 9C3D CD3796                  CALL     ADDPHL      ; Add value to FPREG
 4012 9C40 CDD898       RND1:      CALL     BCDEFP      ; Move FPREG to BCDE
 4013 9C43 7B                      LD       A,E         ; Get LSB
 4014 9C44 59                      LD       E,C         ; LSB = MSB
 4015 9C45 EE4F                    XOR      01001111B   ; Fiddle around
 4016 9C47 4F                      LD       C,A         ; New MSB
 4017 9C48 3680                    LD       (HL),80H    ; Set exponent
 4018 9C4A 2B                      DEC      HL          ; Point to MSB
 4019 9C4B 46                      LD       B,(HL)      ; Get MSB
 4020 9C4C 3680                    LD       (HL),80H    ; Make value -0.5
 4021 9C4E 211705                  LD       HL,SEED     ; Random number seed
 4022 9C51 34                      INC      (HL)        ; Count seed
 4023 9C52 7E                      LD       A,(HL)      ; Get seed
 4024 9C53 D6AB                    SUB      171         ; Do it modulo 171
 4025 9C55 C25C9C                  JP       NZ,RND2     ; Non-zero - Ok
 4026 9C58 77                      LD       (HL),A      ; Zero seed
 4027 9C59 0C                      INC      C           ; Fillde about
 4028 9C5A 15                      DEC      D           ; with the
 4029 9C5B 1C                      INC      E           ; number
 4030 9C5C CD9796       RND2:      CALL     BNORM       ; Normalise number
 4031 9C5F 213A05                  LD       HL,LSTRND   ; Save random number
 4032 9C62 C3E498                  JP       FPTHL       ; Move FPREG to last an
 4033                   ;
 4034 9C65 77           RESEED:    LD       (HL),A      ; Re-seed random number
 4035 9C66 2B                      DEC      HL
 4036 9C67 77                      LD       (HL),A
 4037 9C68 2B                      DEC      HL
 4038 9C69 77                      LD       (HL),A
 4039 9C6A C3409C                  JP       RND1        ; Return RND seed
 4040                   ;
 4041 9C6D 68B14668     RNDTAB:    DB       068H,0B1H,046H,068H ; Table used by
 4042 9C71 99E99269                DB       099H,0E9H,092H,069H
 4043 9C75 10D17568                DB       010H,0D1H,075H,068H
 4044                   ;
 4045 9C79 21C39C       COS:       LD       HL,HALFPI   ; Point to PI/2
 4046 9C7C CD3796                  CALL     ADDPHL      ; Add it to PPREG
 4047 9C7F CDBD98       SIN:       CALL     STAKFP      ; Put angle on stack
 4048 9C82 014983                  LD       BC,8349H    ; BCDE = 2 PI
 4049 9C85 11DB0F                  LD       DE,0FDBH
 4050 9C88 CDCD98                  CALL     FPBCDE      ; Move 2 PI to FPREG
 4051 9C8B C1                      POP      BC          ; Restore angle
 4052 9C8C D1                      POP      DE
 4053 9C8D CDE297                  CALL     DVBCDE      ; Divide angle by 2 PI
 4054 9C90 CDBD98                  CALL     STAKFP      ; Put it on stack
 4055 9C93 CD5F99                  CALL     INT         ; Get INT of result
 4056 9C96 C1                      POP      BC          ; Restore number
 4057 9C97 D1                      POP      DE
 4058 9C98 CD4396                  CALL     SUBCDE      ; Make it 0 <= value < 
 4059 9C9B 21C79C                  LD       HL,QUARTR   ; Point to 0.25
 4060 9C9E CD3D96                  CALL     SUBPHL      ; Subtract value from 0
 4061 9CA1 CD8C98                  CALL     TSTSGN      ; Test sign of value
 4062 9CA4 37                      SCF                  ; Flag positive
 4063 9CA5 F2AF9C                  JP       P,SIN1      ; Positive - Ok
 4064 9CA8 CD3496                  CALL     ROUND       ; Add 0.5 to value
 4065 9CAB CD8C98                  CALL     TSTSGN      ; Test sign of value
 4066 9CAE B7                      OR       A           ; Flag negative
 4067 9CAF F5           SIN1:      PUSH     AF          ; Save sign
 4068 9CB0 F4B598                  CALL     P,INVSGN    ; Negate value if posit
 4069 9CB3 21C79C                  LD       HL,QUARTR   ; Point to 0.25
 4070 9CB6 CD3796                  CALL     ADDPHL      ; Add 0.25 to value
 4071 9CB9 F1                      POP      AF          ; Restore sign
 4072 9CBA D4B598                  CALL     NC,INVSGN   ; Negative - Make posit
 4073 9CBD 21CB9C                  LD       HL,SINTAB   ; Coefficient table
 4074 9CC0 C3D49B                  JP       SUMSER      ; Evaluate sum of serie
 4075                   ;
 4076 9CC3 DB0F4981     HALFPI:    DB       0DBH,00FH,049H,081H ; 1.5708 (PI/2)
 4077                   ;
 4078 9CC7 0000007F     QUARTR:    DB       000H,000H,000H,07FH ; 0.25
 4079                   ;
 4080 9CCB 05           SINTAB:    DB       5           ; Table used by SIN
 4081 9CCC BAD71E86                DB       0BAH,0D7H,01EH,086H ; 39.711
 4082 9CD0 64269987                DB       064H,026H,099H,087H ;-76.575
 4083 9CD4 58342387                DB       058H,034H,023H,087H ; 81.602
 4084 9CD8 E05DA586                DB       0E0H,05DH,0A5H,086H ;-41.342
 4085 9CDC DA0F4983                DB       0DAH,00FH,049H,083H ; 6.2832
 4086                   ;
 4087 9CE0 CDBD98       TAN:       CALL     STAKFP      ; Put angle on stack
 4088 9CE3 CD7F9C                  CALL     SIN         ; Get SIN of angle
 4089 9CE6 C1                      POP      BC          ; Restore angle
 4090 9CE7 E1                      POP      HL
 4091 9CE8 CDBD98                  CALL     STAKFP      ; Save SIN of angle
 4092 9CEB EB                      EX       DE,HL       ; BCDE = Angle
 4093 9CEC CDCD98                  CALL     FPBCDE      ; Angle to FPREG
 4094 9CEF CD799C                  CALL     COS         ; Get COS of angle
 4095 9CF2 C3E097                  JP       DIV         ; TAN = SIN / COS
 4096                   ;
 4097 9CF5 CD8C98       ATN:       CALL     TSTSGN      ; Test sign of value
 4098 9CF8 FC209B                  CALL     M,NEGAFT    ; Negate result after i
 4099 9CFB FCB598                  CALL     M,INVSGN    ; Negate value if -ve
 4100 9CFE 3AE705                  LD       A,(FPEXP)   ; Get exponent
 4101 9D01 FE81                    CP       81H         ; Number less than 1?
 4102 9D03 DA129D                  JP       C,ATN1      ; Yes - Get arc tangnt
 4103 9D06 010081                  LD       BC,8100H    ; BCDE = 1
 4104 9D09 51                      LD       D,C
 4105 9D0A 59                      LD       E,C
 4106 9D0B CDE297                  CALL     DVBCDE      ; Get reciprocal of num
 4107 9D0E 213D96                  LD       HL,SUBPHL   ; Sub angle from PI/2
 4108 9D11 E5                      PUSH     HL          ; Save for angle > 1
 4109 9D12 211C9D       ATN1:      LD       HL,ATNTAB   ; Coefficient table
 4110 9D15 CDD49B                  CALL     SUMSER      ; Evaluate sum of serie
 4111 9D18 21C39C                  LD       HL,HALFPI   ; PI/2 - angle in case 
 4112 9D1B C9                      RET                  ; Number > 1 - Sub from
 4113                   ;
 4114 9D1C 09           ATNTAB:    DB       9           ; Table used by ATN
 4115 9D1D 4AD73B78                DB       04AH,0D7H,03BH,078H ; 1/17
 4116 9D21 026E847B                DB       002H,06EH,084H,07BH ;-1/15
 4117 9D25 FEC12F7C                DB       0FEH,0C1H,02FH,07CH ; 1/13
 4118 9D29 74319A7D                DB       074H,031H,09AH,07DH ;-1/11
 4119 9D2D 843D5A7D                DB       084H,03DH,05AH,07DH ; 1/9
 4120 9D31 C87F917E                DB       0C8H,07FH,091H,07EH ;-1/7
 4121 9D35 E4BB4C7E                DB       0E4H,0BBH,04CH,07EH ; 1/5
 4122 9D39 6CAAAA7F                DB       06CH,0AAH,0AAH,07FH ;-1/3
 4123 9D3D 00000081                DB       000H,000H,000H,081H ; 1/1
 4124                   ;
 4125                   
 4126 9D41 C9           ARET:      RET                  ; A RETurn instruction
 4127                   ;
 4128 9D42              CLS:
 4129 9D42 3E0C                    LD       A,CS        ; ASCII Clear screen
 4130 9D44 C30782                  JP       TXA         ; Output character
 4131                   ;
 4132 9D47 CD0B96       WIDTH:     CALL     GETINT      ; Get integer 0-255
 4133 9D4A 7B                      LD       A,E         ; Width to A
 4134 9D4B 324205                  LD       (LWIDTH),A  ; Set width
 4135 9D4E C9                      RET
 4136                   ;
 4137 9D4F CDA78E       LINES:     CALL     GETNUM      ; Get a number
 4138 9D52 CDEC8A                  CALL     DEINT       ; Get integer -32768 to
 4139                   ;       LD      (LINESC),DE     ; Set lines counter
 4140                   ;       LD      (LINESN),DE     ; Set lines number
 4141 9D55 E5                      PUSH     HL          ; REPLACE Z80 CODE
 4142 9D56 D5                      PUSH     DE          ; REPLACE Z80 CODE
 4143 9D57 E1                      POP      HL          ; REPLACE Z80 CODE
 4144 9D58 224605                  LD       (LINESC),HL ; REPLACE Z80 CODE
 4145 9D5B 224805                  LD       (LINESN),HL ; REPLACE Z80 CODE
 4146 9D5E E1                      POP      HL          ; REPLACE Z80 CODE
 4147 9D5F C9                      RET
 4148                   ;
 4149 9D60 CDEC8A       DEEK:      CALL     DEINT       ; Get integer -32768 to
 4150 9D63 D5                      PUSH     DE          ; Save number
 4151 9D64 E1                      POP      HL          ; Number to HL
 4152 9D65 46                      LD       B,(HL)      ; Get LSB of contents
 4153 9D66 23                      INC      HL
 4154 9D67 7E                      LD       A,(HL)      ; Get MSB of contents
 4155 9D68 C36392                  JP       ABPASS      ; Return integer AB
 4156                   ;
 4157 9D6B CDA78E       DOKE:      CALL     GETNUM      ; Get a number
 4158 9D6E CDEC8A                  CALL     DEINT       ; Get integer -32768 to
 4159 9D71 D5                      PUSH     DE          ; Save address
 4160 9D72 CDA288                  CALL     CHKSYN      ; Make sure ',' follows
 4161 9D75 2C                      DB       ','
 4162 9D76 CDA78E                  CALL     GETNUM      ; Get a number
 4163 9D79 CDEC8A                  CALL     DEINT       ; Get integer -32768 to
 4164 9D7C E3                      EX       (SP),HL     ; Save value,get addres
 4165 9D7D 73                      LD       (HL),E      ; Save LSB of value
 4166 9D7E 23                      INC      HL
 4167 9D7F 72                      LD       (HL),D      ; Save MSB of value
 4168 9D80 E1                      POP      HL          ; Restore code string a
 4169 9D81 C9                      RET
 4170                   ;
 4171                   ; HEX$(nn) Convert 16 bit number to Hexadecimal string
 4172                   ;
 4173 9D82 CDAA8E       HEX:       CALL     TSTNUM      ; Verify it's a number
 4174 9D85 CDEC8A                  CALL     DEINT       ; Get integer -32768 to
 4175 9D88 C5                      PUSH     BC          ; Save contents of BC
 4176 9D89 21E905                  LD       HL,PBUFF
 4177 9D8C 7A                      LD       A,D         ; Get high order into A
 4178 9D8D FE00                    CP       0
 4179 9D8F CA9F9D                  JP       Z,HEX2      ; Skip output if both h
 4180 9D92 CDBE9D                  CALL     BYT2ASC     ; Convert D to ASCII
 4181 9D95 78                      LD       A,B
 4182 9D96 FE30                    CP       '0'
 4183 9D98 CA9D9D                  JP       Z,HEX1      ; Don't store high digi
 4184 9D9B 70                      LD       (HL),B      ; Store it to PBUFF
 4185 9D9C 23                      INC      HL          ; Next location
 4186 9D9D 71           HEX1:      LD       (HL),C      ; Store C to PBUFF+1
 4187 9D9E 23                      INC      HL          ; Next location
 4188 9D9F 7B           HEX2:      LD       A,E         ; Get lower byte
 4189 9DA0 CDBE9D                  CALL     BYT2ASC     ; Convert E to ASCII
 4190 9DA3 7A                      LD       A,D
 4191 9DA4 FE00                    CP       0
 4192 9DA6 C2AF9D                  JP       NZ,HEX3     ; If upper byte was not
 4193 9DA9 78                      LD       A,B
 4194 9DAA FE30                    CP       '0'         ; If high digit of lowe
 4195 9DAC CAB19D                  JP       Z,HEX4
 4196 9DAF 70           HEX3:      LD       (HL),B      ; to PBUFF+2
 4197 9DB0 23                      INC      HL          ; Next location
 4198 9DB1 71           HEX4:      LD       (HL),C      ; to PBUFF+3
 4199 9DB2 23                      INC      HL          ; PBUFF+4 to zero
 4200 9DB3 AF                      XOR      A           ; Terminating character
 4201 9DB4 77                      LD       (HL),A      ; Store zero to termina
 4202 9DB5 23                      INC      HL          ; Make sure PBUFF is te
 4203 9DB6 77                      LD       (HL),A      ; Store the double zero
 4204 9DB7 C1                      POP      BC          ; Get BC back
 4205 9DB8 21E905                  LD       HL,PBUFF    ; Reset to start of PBU
 4206 9DBB C31193                  JP       STR1        ; Convert the PBUFF to 
 4207                   ;
 4208 9DBE 47           BYT2ASC    LD       B,A         ; Save original value
 4209 9DBF E60F                    AND      0FH         ; Strip off upper nybbl
 4210 9DC1 FE0A                    CP       0AH         ; 0-9?
 4211 9DC3 DAC89D                  JP       C,ADD30     ; If A-F, add 7 more
 4212 9DC6 C607                    ADD      A,07H       ; Bring value up to ASC
 4213 9DC8 C630         ADD30      ADD      A,30H       ; And make ASCII
 4214 9DCA 4F                      LD       C,A         ; Save converted char t
 4215 9DCB 78                      LD       A,B         ; Retrieve original val
 4216 9DCC 0F                      RRCA                 ; and Rotate it right
 4217 9DCD 0F                      RRCA
 4218 9DCE 0F                      RRCA
 4219 9DCF 0F                      RRCA
 4220 9DD0 E60F                    AND      0FH         ; Mask off upper nybble
 4221 9DD2 FE0A                    CP       0AH         ; 0-9? < A hex?
 4222 9DD4 DAD99D                  JP       C,ADD301    ; Skip Add 7
 4223 9DD7 C607                    ADD      A,07H       ; Bring it up to ASCII 
 4224 9DD9 C630         ADD301     ADD      A,30H       ; And make it full ASCI
 4225 9DDB 47                      LD       B,A         ; Store high order byte
 4226 9DDC C9                      RET
 4227                   ;
 4228                   ; Convert "&Hnnnn" to FPREG
 4229                   ; Gets a character from (HL) checks for Hexadecimal ASC
 4230                   ; Char is in A, NC if char is;<=>?@ A-z, CY is set if 0
 4231 9DDD EB           HEXTFP     EX       DE,HL       ; Move code string poin
 4232 9DDE 210000                  LD       HL,0000H    ; Zero out the value
 4233 9DE1 CDF99D                  CALL     GETHEX      ; Check the number for 
 4234 9DE4 DA1A9E                  JP       C,HXERR     ; First value wasn't he
 4235 9DE7 C3F09D                  JP       HEXLP1      ; Convert first charact
 4236 9DEA CDF99D       HEXLP      CALL     GETHEX      ; Get second and addtio
 4237 9DED DA119E                  JP       C,HEXIT     ; Exit if not a hex cha
 4238 9DF0 29           HEXLP1     ADD      HL,HL       ; Rotate 4 bits to the 
 4239 9DF1 29                      ADD      HL,HL
 4240 9DF2 29                      ADD      HL,HL
 4241 9DF3 29                      ADD      HL,HL
 4242 9DF4 B5                      OR       L           ; Add in D0-D3 into L
 4243 9DF5 6F                      LD       L,A         ; Save new value
 4244 9DF6 C3EA9D                  JP       HEXLP       ; And continue until al
 4245                   ;
 4246 9DF9 13           GETHEX     INC      DE          ; Next location
 4247 9DFA 1A                      LD       A,(DE)      ; Load character at poi
 4248 9DFB FE20                    CP       ' '
 4249 9DFD CAF99D                  JP       Z,GETHEX    ; Skip spaces
 4250 9E00 D630                    SUB      30H         ; Get absolute value
 4251 9E02 D8                      RET      C           ; < "0", error
 4252 9E03 FE0A                    CP       0AH
 4253 9E05 DA0D9E                  JP       C,NOSUB7    ; Is already in the ran
 4254 9E08 D607                    SUB      07H         ; Reduce to A-F
 4255 9E0A FE0A                    CP       0AH         ; Value should be $0A-$
 4256 9E0C D8                      RET      C           ; CY set if was :      
 4257 9E0D FE10         NOSUB7     CP       10H         ; > Greater than "F"?
 4258 9E0F 3F                      CCF
 4259 9E10 C9                      RET                  ; CY set if it wasn't v
 4260                   
 4261 9E11 EB           HEXIT      EX       DE,HL       ; Value into DE, Code s
 4262 9E12 7A                      LD       A,D         ; Load DE into AC
 4263 9E13 4B                      LD       C,E         ; For prep to
 4264 9E14 E5                      PUSH     HL
 4265 9E15 CD6292                  CALL     ACPASS      ; ACPASS to set AC as i
 4266 9E18 E1                      POP      HL
 4267 9E19 C9                      RET
 4268                   ;
 4269 9E1A 1E26         HXERR:     LD       E,HX        ; ?HEX Error
 4270 9E1C C3E885                  JP       ERROR
 4271                   ;
 4272                   ; BIN$(NN) Convert integer to a 1-16 char binary string
 4273 9E1F CDAA8E       BIN:       CALL     TSTNUM      ; Verify it's a number
 4274 9E22 CDEC8A                  CALL     DEINT       ; Get integer -32768 to
 4275 9E25 C5           BIN2:      PUSH     BC          ; Save contents of BC
 4276 9E26 21E905                  LD       HL,PBUFF
 4277 9E29 0611                    LD       B,17        ; One higher than max c
 4278 9E2B              ZEROSUP:                        ; Suppress leading zero
 4279 9E2B 05                      DEC      B           ; Max 16 chars
 4280 9E2C 78                      LD       A,B
 4281 9E2D FE01                    CP       01H
 4282 9E2F CA3E9E                  JP       Z,BITOUT    ; Always output at leas
 4283                   ;       RL      E
 4284                   ;       RL      D
 4285 9E32 7B                      LD       A,E         ; REPLACE Z80 CODE
 4286 9E33 17                      RLA                  ; REPLACE Z80 CODE
 4287 9E34 5F                      LD       E,A         ; REPLACE Z80 CODE
 4288 9E35 7A                      LD       A,D         ; REPLACE Z80 CODE
 4289 9E36 17                      RLA                  ; REPLACE Z80 CODE
 4290 9E37 57                      LD       D,A         ; REPLACE Z80 CODE
 4291 9E38 D22B9E                  JP       NC,ZEROSUP
 4292 9E3B C3449E                  JP       BITOUT2
 4293 9E3E              BITOUT:
 4294                   ;       RL      E
 4295                   ;       RL      D               ; Top bit now in carry
 4296 9E3E 7B                      LD       A,E         ; REPLACE Z80 CODE
 4297 9E3F 17                      RLA                  ; REPLACE Z80 CODE
 4298 9E40 5F                      LD       E,A         ; REPLACE Z80 CODE
 4299 9E41 7A                      LD       A,D         ; REPLACE Z80 CODE
 4300 9E42 17                      RLA                  ; REPLACE Z80 CODE
 4301 9E43 57                      LD       D,A         ; REPLACE Z80 CODE
 4302 9E44              BITOUT2:
 4303 9E44 3E30                    LD       A,'0'       ; Char for '0'
 4304 9E46 CE00                    ADC      A,0         ; If carry set then '0'
 4305 9E48 77                      LD       (HL),A
 4306 9E49 23                      INC      HL
 4307 9E4A 05                      DEC      B
 4308 9E4B C23E9E                  JP       NZ,BITOUT
 4309 9E4E AF                      XOR      A           ; Terminating character
 4310 9E4F 77                      LD       (HL),A      ; Store zero to termina
 4311 9E50 23                      INC      HL          ; Make sure PBUFF is te
 4312 9E51 77                      LD       (HL),A      ; Store the double zero
 4313 9E52 C1                      POP      BC
 4314 9E53 21E905                  LD       HL,PBUFF
 4315 9E56 C31193                  JP       STR1
 4316                   ;
 4317                   ; Convert "&Bnnnn" to FPREG
 4318                   ; Gets a character from (HL) checks for Binary ASCII nu
 4319 9E59 EB           BINTFP:    EX       DE,HL       ; Move code string poin
 4320 9E5A 210000                  LD       HL,0000H    ; Zero out the value
 4321 9E5D CD779E                  CALL     CHKBIN      ; Check the number for 
 4322 9E60 DA859E                  JP       C,BINERR    ; First value wasn't bi
 4323 9E63 D630         BINIT:     SUB      '0'
 4324 9E65 29                      ADD      HL,HL       ; Rotate HL left
 4325 9E66 B5                      OR       L
 4326 9E67 6F                      LD       L,A
 4327 9E68 CD779E                  CALL     CHKBIN      ; Get second and addtio
 4328 9E6B D2639E                  JP       NC,BINIT    ; Process if a bin char
 4329 9E6E EB                      EX       DE,HL       ; Value into DE, Code s
 4330 9E6F 7A                      LD       A,D         ; Load DE into AC
 4331 9E70 4B                      LD       C,E         ; For prep to
 4332 9E71 E5                      PUSH     HL
 4333 9E72 CD6292                  CALL     ACPASS      ; ACPASS to set AC as i
 4334 9E75 E1                      POP      HL
 4335 9E76 C9                      RET
 4336                   ;
 4337                   ; Char is in A, NC if char is 0 or 1
 4338 9E77 13           CHKBIN:    INC      DE
 4339 9E78 1A                      LD       A,(DE)
 4340 9E79 FE20                    CP       ' '
 4341 9E7B CA779E                  JP       Z,CHKBIN    ; Skip spaces
 4342 9E7E FE30                    CP       '0'         ; Set C if < '0'
 4343 9E80 D8                      RET      C
 4344 9E81 FE32                    CP       '2'
 4345 9E83 3F                      CCF                  ; Set C if > '1'
 4346 9E84 C9                      RET
 4347                   ;
 4348 9E85 1E28         BINERR:    LD       E,BN        ; ?BIN Error
 4349 9E87 C3E885                  JP       ERROR
 4350                   ;
 4351 9E8A C32782       JJUMP1:    JP       CSTART      ; Go and initialise
 4352                   ;
 4353 9E8D 3E00         INITST:    LD       A,0         ; Clear break flag
 4354 9E8F 324D05                  LD       (BRKFLG),A
 4355 9E92 C32E82                  JP       INIT
 4356                   ;
 4357 9E95 F5           TSTBIT:    PUSH     AF          ; Save bit mask
 4358 9E96 A0                      AND      B           ; Get common bits
 4359 9E97 C1                      POP      BC          ; Restore bit mask
 4360 9E98 B8                      CP       B           ; Same bit set?
 4361 9E99 3E00                    LD       A,0         ; Return 0 in A
 4362 9E9B C9                      RET
 4363                   ;
 4364 9E9C CDAD88       OUTNCR:    CALL     OUTC        ; Output character in A
 4365 9E9F C3E28C                  JP       PRCRLF      ; Output CRLF
 4366                   ;
 4367 9EA2                         END
