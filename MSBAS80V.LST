    1                   ;       MS-BASIC START UP ROUTINE
    2                   ;       TARGET: SBC8080
    3                   ;       ASSEMBLER: ARCPIT XZ80.EXE
    4                   ;
    5 0000              UARTRD     EQU      00H
    6 0001              UARTRC     EQU      01H
    7                   ;
    8 003F              BUFSIZ     EQU      3FH
    9 0030              BUFFUL     EQU      30H
   10 0005              BUFEMP     EQU      5
   11                   ;
   12 0017              RTSHIG     EQU      00010111B
   13 0037              RTSLOW     EQU      00110111B
   14                   ;
   15 8000              SERBUF     EQU      8000H
   16 803F              SERINP     EQU      SERBUF+BUFSIZ
   17 8041              SERRDP     EQU      SERINP+2
   18 8043              SERCNT     EQU      SERRDP+2
   19 8044              BASFLG     EQU      SERCNT+1
   20                   ;
   21 000D              CR         EQU      0DH
   22 000A              LF         EQU      0AH
   23                   ;
   24 0000                         ORG      0000H
   25                   ;
   26                   ;       RESET VECTOR
   27 0000 F3                      DI
   28 0001 C3B900                  JP       SINIT
   29                   ;
   30                   ;       INTERRUPT VECTOR
   31 0038                         ORG      0038H
   32 0038 C33B00       RST38:     JP       SERINT
   33                   ;
   34                   ;       8251 -> BUFFER BY INTERRUPT
   35 003B F5           SERINT:    PUSH     AF
   36 003C E5                      PUSH     HL
   37 003D DB01                    IN       A,(UARTRC)
   38 003F E602                    AND      00000010B
   39 0041 CA7500                  JP       Z,RTS0
   40 0044 DB00                    IN       A,(UARTRD)
   41 0046 F5                      PUSH     AF
   42 0047 3A4380                  LD       A,(SERCNT)
   43 004A FE3F                    CP       BUFSIZ
   44 004C C25300                  JP       NZ,NOTFUL
   45 004F F1                      POP      AF
   46 0050 C37500                  JP       RTS0
   47 0053 2A3F80       NOTFUL:    LD       HL,(SERINP)
   48 0056 23                      INC      HL
   49 0057 7D                      LD       A,L
   50 0058 FE3F                    CP       SERINP & 0FFH
   51 005A C26000                  JP       NZ,NOTWRP
   52 005D 210080                  LD       HL,SERBUF
   53 0060 223F80       NOTWRP:    LD       (SERINP),HL
   54 0063 F1                      POP      AF
   55 0064 77                      LD       (HL),A
   56 0065 3A4380                  LD       A,(SERCNT)
   57 0068 3C                      INC      A
   58 0069 324380                  LD       (SERCNT),A
   59 006C FE30                    CP       BUFFUL
   60 006E DA7500                  JP       C,RTS0
   61 0071 3E17                    LD       A,RTSHIG
   62 0073 D301                    OUT      (UARTRC),A
   63 0075 E1           RTS0:      POP      HL
   64 0076 F1                      POP      AF
   65 0077 FB                      EI
   66 0078 C9                      RET
   67                   ;
   68                   ;       BUFFER -> A
   69 0079 3A4380       RXA:       LD       A,(SERCNT)
   70 007C FE00                    CP       00H
   71 007E CA7900                  JP       Z,RXA
   72 0081 E5                      PUSH     HL
   73 0082 2A4180                  LD       HL,(SERRDP)
   74 0085 23                      INC      HL
   75 0086 7D                      LD       A,L         ;Only need to check low
   76 0087 FE3F                    CP       SERINP & 0FFH ;(SERBUF+BUFSIZ) & 0F
   77 0089 C28F00                  JP       NZ,NRWRAP
   78 008C 210080                  LD       HL,SERBUF
   79 008F F3           NRWRAP:    DI
   80 0090 224180                  LD       (SERRDP),HL
   81 0093 3A4380                  LD       A,(SERCNT)
   82 0096 3D                      DEC      A
   83 0097 324380                  LD       (SERCNT),A
   84 009A FE05                    CP       BUFEMP
   85 009C D2A300                  JP       NC,RTS1
   86 009F 3E37                    LD       A,RTSLOW
   87 00A1 D301                    OUT      (UARTRC),A
   88 00A3 7E           RTS1:      LD       A,(HL)
   89 00A4 FB                      EI
   90 00A5 E1                      POP      HL
   91 00A6 C9                      RET                  ;Char ready in A
   92                   ;
   93                   ;       A -> 8251
   94 00A7 F5           TXA:       PUSH     AF          ;Store character
   95 00A8 DB01         COUT1:     IN       A,(UARTRC)  ;Status byte
   96 00AA E601                    AND      01H         ;Set Zero flag if still
   97 00AC CAA800                  JP       Z,COUT1     ;Loop until flag signal
   98 00AF F1                      POP      AF          ;Retrieve character
   99 00B0 D300                    OUT      (UARTRD),A  ;Output the character
  100 00B2 C9                      RET
  101                   ;
  102                   ;       CHECK RECEIVE STATUS
  103 00B3 3A4380       CHKCHR:    LD       A,(SERCNT)
  104 00B6 FE00                    CP       00H
  105 00B8 C9                      RET
  106                   ;
  107                   ;       SYSTEM INITIALIZE
  108 00B9 21AB80       SINIT:     LD       HL,STACK
  109 00BC F9                      LD       SP,HL
  110 00BD 210080                  LD       HL,SERBUF
  111 00C0 223F80                  LD       (SERINP),HL
  112 00C3 224180                  LD       (SERRDP),HL
  113 00C6 AF                      XOR      A
  114 00C7 324380                  LD       (SERCNT),A
  115 00CA D301                    OUT      (UARTRC),A
  116 00CC D301                    OUT      (UARTRC),A
  117 00CE D301                    OUT      (UARTRC),A
  118 00D0 3E40                    LD       A,01000000B
  119 00D2 D301                    OUT      (UARTRC),A  ; RESET
  120 00D4 00                      NOP
  121 00D5 00                      NOP
  122 00D6 3E4E                    LD       A,01001110B
  123 00D8 D301                    OUT      (UARTRC),A  ; MODE SET
  124 00DA 00                      NOP
  125 00DB 00                      NOP
  126 00DC 3E37                    LD       A,RTSLOW
  127 00DE D301                    OUT      (UARTRC),A
  128 00E0 FB                      EI
  129                   ;
  130                   ;       START BASIC
  131 00E1 C3E400                  JP       COLD
  132                   ;
  133                   ;======================================================
  134                   ; The updates to the original BASIC within this file ar
  135                   ;
  136                   ; You have permission to use this for NON COMMERCIAL US
  137                   ; If you wish to use it elsewhere, please include an ac
  138                   ;
  139                   ; http://searle.hostei.com/grant/index.html
  140                   ;
  141                   ; eMail: home.micros01@btinternet.com
  142                   ;
  143                   ; If the above don't work, please perform an Internet s
  144                   ; updated the web page hosting service.
  145                   ;
  146                   ;======================================================
  147                   ;
  148                   ; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
  149                   ; Scanned from source published in 80-BUS NEWS from Vol
  150                   ; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
  151                   ; Adapted for the freeware Zilog Macro Assembler 2.10 t
  152                   ; the original ROM code (checksum A934H). PA
  153                   ;
  154                   ; GENERAL EQUATES
  155                   ;
  156 0003              CTRLC      EQU      03H         ; Control "C"
  157 0007              CTRLG      EQU      07H         ; Control "G"
  158 0008              BKSP       EQU      08H         ; Back space
  159 000A              LF         EQU      0AH         ; Line feed
  160 000C              CS         EQU      0CH         ; Clear screen
  161 000D              CR         EQU      0DH         ; Carriage return
  162 000F              CTRLO      EQU      0FH         ; Control "O"
  163 0011              CTRLQ      EQU      11H         ; Control "Q"
  164 0012              CTRLR      EQU      12H         ; Control "R"
  165 0013              CTRLS      EQU      13H         ; Control "S"
  166 0015              CTRLU      EQU      15H         ; Control "U"
  167 001B              ESC        EQU      1BH         ; Escape
  168 007F              DEL        EQU      7FH         ; Delete
  169                   ;
  170                   ; BASIC WORK SPACE LOCATIONS
  171                   ;
  172 8045              WRKSPC     EQU      8045H       ; BASIC Work space
  173 8048              USR        EQU      WRKSPC+3H   ; "USR (x)" jump
  174 804B              OUTSUB     EQU      WRKSPC+6H   ; "OUT p,n"
  175 804C              OTPORT     EQU      WRKSPC+7H   ; Port (p)
  176 804E              DIVSUP     EQU      WRKSPC+9H   ; Division support rout
  177 804F              DIV1       EQU      WRKSPC+0AH  ; <- Values
  178 8053              DIV2       EQU      WRKSPC+0EH  ; <- to
  179 8057              DIV3       EQU      WRKSPC+12H  ; <- be
  180 805A              DIV4       EQU      WRKSPC+15H  ; <- inserted
  181 805C              SEED       EQU      WRKSPC+17H  ; Random number seed
  182 807F              LSTRND     EQU      WRKSPC+3AH  ; Last random number
  183 8083              INPSUB     EQU      WRKSPC+3EH  ; #INP (x)" Routine
  184 8084              INPORT     EQU      WRKSPC+3FH  ; PORT (x)
  185 8086              NULLS      EQU      WRKSPC+41H  ; Number of nulls
  186 8087              LWIDTH     EQU      WRKSPC+42H  ; Terminal width
  187 8088              COMMAN     EQU      WRKSPC+43H  ; Width for commas
  188 8089              NULFLG     EQU      WRKSPC+44H  ; Null after input byte
  189 808A              CTLOFG     EQU      WRKSPC+45H  ; Control "O" flag
  190 808B              LINESC     EQU      WRKSPC+46H  ; Lines counter
  191 808D              LINESN     EQU      WRKSPC+48H  ; Lines number
  192 808F              CHKSUM     EQU      WRKSPC+4AH  ; Array load/save check
  193 8091              NMIFLG     EQU      WRKSPC+4CH  ; Flag for NMI break ro
  194 8092              BRKFLG     EQU      WRKSPC+4DH  ; Break flag
  195 8093              RINPUT     EQU      WRKSPC+4EH  ; Input reflection
  196 8096              POINT      EQU      WRKSPC+51H  ; "POINT" reflection (u
  197 8099              PSET       EQU      WRKSPC+54H  ; "SET" reflection
  198 809C              RESET      EQU      WRKSPC+57H  ; "RESET" reflection
  199 809F              STRSPC     EQU      WRKSPC+5AH  ; Bottom of string spac
  200 80A1              LINEAT     EQU      WRKSPC+5CH  ; Current line number
  201 80A3              BASTXT     EQU      WRKSPC+5EH  ; Pointer to start of p
  202 80A6              BUFFER     EQU      WRKSPC+61H  ; Input buffer
  203 80AB              STACK      EQU      WRKSPC+66H  ; Initial stack
  204 80F0              CURPOS     EQU      WRKSPC+0ABH ; Character position on
  205 80F1              LCRFLG     EQU      WRKSPC+0ACH ; Locate/Create flag
  206 80F2              TYPE       EQU      WRKSPC+0ADH ; Data type flag
  207 80F3              DATFLG     EQU      WRKSPC+0AEH ; Literal statement fla
  208 80F4              LSTRAM     EQU      WRKSPC+0AFH ; Last available RAM
  209 80F6              TMSTPT     EQU      WRKSPC+0B1H ; Temporary string poin
  210 80F8              TMSTPL     EQU      WRKSPC+0B3H ; Temporary string pool
  211 8104              TMPSTR     EQU      WRKSPC+0BFH ; Temporary string
  212 8108              STRBOT     EQU      WRKSPC+0C3H ; Bottom of string spac
  213 810A              CUROPR     EQU      WRKSPC+0C5H ; Current operator in E
  214 810C              LOOPST     EQU      WRKSPC+0C7H ; First statement of lo
  215 810E              DATLIN     EQU      WRKSPC+0C9H ; Line of current DATA 
  216 8110              FORFLG     EQU      WRKSPC+0CBH ; "FOR" loop flag
  217 8111              LSTBIN     EQU      WRKSPC+0CCH ; Last byte entered
  218 8112              READFG     EQU      WRKSPC+0CDH ; Read/Input flag
  219 8113              BRKLIN     EQU      WRKSPC+0CEH ; Line of break
  220 8115              NXTOPR     EQU      WRKSPC+0D0H ; Next operator in EVAL
  221 8117              ERRLIN     EQU      WRKSPC+0D2H ; Line of error
  222 8119              CONTAD     EQU      WRKSPC+0D4H ; Where to CONTinue
  223 811B              PROGND     EQU      WRKSPC+0D6H ; End of program
  224 811D              VAREND     EQU      WRKSPC+0D8H ; End of variables
  225 811F              ARREND     EQU      WRKSPC+0DAH ; End of arrays
  226 8121              NXTDAT     EQU      WRKSPC+0DCH ; Next data item
  227 8123              FNRGNM     EQU      WRKSPC+0DEH ; Name of FN argument
  228 8125              FNARG      EQU      WRKSPC+0E0H ; FN argument value
  229 8129              FPREG      EQU      WRKSPC+0E4H ; Floating point regist
  230 812C              FPEXP      EQU      FPREG+3     ; Floating point expone
  231 812D              SGNRES     EQU      WRKSPC+0E8H ; Sign of result
  232 812E              PBUFF      EQU      WRKSPC+0E9H ; Number print buffer
  233 813B              MULVAL     EQU      WRKSPC+0F6H ; Multiplier
  234 813E              PROGST     EQU      WRKSPC+0F9H ; Start of program text
  235 81A2              STLOOK     EQU      WRKSPC+15DH ; Start of memory test
  236                   ;
  237                   ; BASIC ERROR CODE VALUES
  238                   ;
  239 0000              NF         EQU      00H         ; NEXT without FOR
  240 0002              SN         EQU      02H         ; Syntax error
  241 0004              RG         EQU      04H         ; RETURN without GOSUB
  242 0006              OD         EQU      06H         ; Out of DATA
  243 0008              FC         EQU      08H         ; Function call error
  244 000A              OV         EQU      0AH         ; Overflow
  245 000C              OM         EQU      0CH         ; Out of memory
  246 000E              UL         EQU      0EH         ; Undefined line number
  247 0010              BS         EQU      10H         ; Bad subscript
  248 0012              RD         EQU      12H         ; Re-DIMensioned array
  249 0014              DZ         EQU      14H         ; Division by zero (/0)
  250 0016              ID         EQU      16H         ; Illegal direct
  251 0018              TM         EQU      18H         ; Type miss-match
  252 001A              OS         EQU      1AH         ; Out of string space
  253 001C              LS         EQU      1CH         ; String too long
  254 001E              ST         EQU      1EH         ; String formula too co
  255 0020              CN         EQU      20H         ; Can't CONTinue
  256 0022              UF         EQU      22H         ; UnDEFined FN function
  257 0024              MO         EQU      24H         ; Missing operand
  258 0026              HX         EQU      26H         ; HEX error
  259 0028              BN         EQU      28H         ; BIN error
  260                   ;
  261 00E4 C3EA00       COLD:      JP       STARTB      ; Jump for cold start
  262 00E7 C35F01       WARM:      JP       WARMST      ; Jump for warm start
  263 00EA C3F100       STARTB:    JP       CSTART      ; Jump to initialise
  264                   ;
  265 00ED B609                    DW       DEINT       ; Get integer -32768 to
  266 00EF 2D11                    DW       ABPASS      ; Return integer in AB
  267                   ;
  268 00F1 214580       CSTART:    LD       HL,WRKSPC   ; Start of workspace RA
  269 00F4 F9                      LD       SP,HL       ; Set up a temporary st
  270 00F5 C35A1D                  JP       INITST      ; Go to initialise
  271                   ;
  272 00F8 11CF03       INIT:      LD       DE,INITAB   ; Initialise workspace
  273 00FB 0663                    LD       B,INITBE-INITAB+3 ; Bytes to copy
  274 00FD 214580                  LD       HL,WRKSPC   ; Into workspace RAM
  275 0100 1A           COPY:      LD       A,(DE)      ; Get source
  276 0101 77                      LD       (HL),A      ; To destination
  277 0102 23                      INC      HL          ; Next destination
  278 0103 13                      INC      DE          ; Next source
  279 0104 05                      DEC      B           ; Count bytes
  280 0105 C20001                  JP       NZ,COPY     ; More to move
  281 0108 F9                      LD       SP,HL       ; Temporary stack
  282 0109 CDD005                  CALL     CLREG       ; Clear registers and s
  283 010C CDAC0B                  CALL     PRCRLF      ; Output CRLF
  284 010F 32EF80                  LD       (BUFFER+72+1),A ; Mark end of buffe
  285 0112 323E81                  LD       (PROGST),A  ; Initialise program ar
  286 0115 21A281       MSIZE:     LD       HL,STLOOK   ; Point to start of RAM
  287 0118 23           MLOOP:     INC      HL          ; Next byte
  288 0119 7C                      LD       A,H         ; Above address FFFF ?
  289 011A B5                      OR       L
  290 011B CA2701                  JP       Z,SETTOP    ; Yes - 64K RAM
  291 011E 7E                      LD       A,(HL)      ; Get contents
  292 011F 47                      LD       B,A         ; Save it
  293 0120 2F                      CPL                  ; Flip all bits
  294 0121 77                      LD       (HL),A      ; Put it back
  295 0122 BE                      CP       (HL)        ; RAM there if same
  296 0123 70                      LD       (HL),B      ; Restore old contents
  297 0124 CA1801                  JP       Z,MLOOP     ; If RAM - test next by
  298                   ;
  299 0127 2B           SETTOP:    DEC      HL          ; Back one byte
  300 0128 11A181                  LD       DE,STLOOK-1 ; See if enough RAM
  301 012B CD6607                  CALL     CPDEHL      ; Compare DE with HL
  302 012E DA6801                  JP       C,NEMEM     ; If not enough RAM
  303 0131 11CEFF                  LD       DE,0-50     ; 50 Bytes string space
  304 0134 22F480                  LD       (LSTRAM),HL ; Save last available R
  305 0137 19                      ADD      HL,DE       ; Allocate string space
  306 0138 229F80                  LD       (STRSPC),HL ; Save string space
  307 013B CDAB05                  CALL     CLRPTR      ; Clear program area
  308 013E 2A9F80                  LD       HL,(STRSPC) ; Get end of memory
  309 0141 11EFFF                  LD       DE,0-17     ; Offset for free bytes
  310 0144 19                      ADD      HL,DE       ; Adjust HL
  311 0145 113E81                  LD       DE,PROGST   ; Start of program text
  312 0148 7D                      LD       A,L         ; Get LSB
  313 0149 93                      SUB      E           ; Adjust it
  314 014A 6F                      LD       L,A         ; Re-save
  315 014B 7C                      LD       A,H         ; Get MSB
  316 014C 9A                      SBC      A,D         ; Adjust it
  317 014D 67                      LD       H,A         ; Re-save
  318 014E E5                      PUSH     HL          ; Save bytes free
  319 014F 218001                  LD       HL,SIGNON   ; Sign-on message
  320 0152 CD4B12                  CALL     PRS         ; Output string
  321 0155 E1                      POP      HL          ; Get bytes free back
  322 0156 CDF018                  CALL     PRNTHL      ; Output amount of free
  323 0159 217101                  LD       HL,BFREE    ; " Bytes free" message
  324 015C CD4B12                  CALL     PRS         ; Output string
  325                   ;
  326 015F 31AB80       WARMST:    LD       SP,STACK    ; Temporary stack
  327 0162 CDD005       BRKRET:    CALL     CLREG       ; Clear registers and s
  328 0165 C3E904                  JP       PRNTOK      ; Go to get command lin
  329                   ;
  330 0168 21BD01       NEMEM:     LD       HL,MEMMSG   ; Memory size not enoug
  331 016B CD4B12                  CALL     PRS         ; Print it
  332 016E C36E01       XXXXX:     JP       XXXXX       ; Stop
  333                   ;
  334 0171 204279746573 BFREE:     DB       " Bytes free",CR,LF,0,0
           20667265650D 
           0A0000       
  335                   ;
  336 0180 494E54454C38 SIGNON:    DB       "INTEL8080 BASIC Ver 4.7b",CR,LF
           303830204241 
           534943205665 
           7220342E3762 
           0D0A         
  337 019A 436F70797269            DB       "Copyright ",40,"C",41
           676874202843 
           29           
  338 01A7 203139373820            DB       " 1978 by Microsoft",CR,LF,0,0
           6279204D6963 
           726F736F6674 
           0D0A0000     
  339                   ;
  340 01BD 4D656D6F7279 MEMMSG:    DB       "Memory size not enough",CR,LF
           2073697A6520 
           6E6F7420656E 
           6F7567680D0A 
  341 01D5 546865207379            DB       "The system is stopped.",CR,LF,0,0
           7374656D2069 
           732073746F70 
           7065642E0D0A 
           0000         
  342                   ;
  343                   ; FUNCTION ADDRESS TABLE
  344                   ;
  345 01EF 6517         FNCTAB:    DW       SGN
  346 01F1 2918                    DW       INT
  347 01F3 7B17                    DW       ABS
  348 01F5 4880                    DW       USR
  349 01F7 0B11                    DW       FRE
  350 01F9 9214                    DW       INP
  351 01FB 3911                    DW       POS
  352 01FD EF19                    DW       SQR
  353 01FF CE1A                    DW       RND
  354 0201 0A16                    DW       LOG
  355 0203 3D1A                    DW       EXP
  356 0205 431B                    DW       COS
  357 0207 491B                    DW       SIN
  358 0209 AA1B                    DW       TAN
  359 020B BF1B                    DW       ATN
  360 020D E614                    DW       PEEK
  361 020F 2A1C                    DW       DEEK
  362 0211 9680                    DW       POINT
  363 0213 BD13                    DW       LEN
  364 0215 D511                    DW       STR
  365 0217 5714                    DW       VAL
  366 0219 CC13                    DW       ASC
  367 021B DD13                    DW       CHR
  368 021D 4C1C                    DW       HEX
  369 021F E91C                    DW       BIN
  370 0221 ED13                    DW       LEFT
  371 0223 1D14                    DW       RIGHT
  372 0225 2714                    DW       MID
  373                   ;
  374                   ; RESERVED WORD LIST
  375                   ;
  376 0227 C54E44       WORDS:     DB       0C5H,"ND"
  377 022A C64F52                  DB       0C6H,"OR"
  378 022D CE455854                DB       0CEH,"EXT"
  379 0231 C4415441                DB       0C4H,"ATA"
  380 0235 C94E505554              DB       0C9H,"NPUT"
  381 023A C4494D                  DB       0C4H,"IM"
  382 023D D2454144                DB       0D2H,"EAD"
  383 0241 CC4554                  DB       0CCH,"ET"
  384 0244 C74F544F                DB       0C7H,"OTO"
  385 0248 D2554E                  DB       0D2H,"UN"
  386 024B C946                    DB       0C9H,"F"
  387 024D D24553544F52            DB       0D2H,"ESTORE"
           45           
  388 0254 C74F535542              DB       0C7H,"OSUB"
  389 0259 D2455455524E            DB       0D2H,"ETURN"
  390 025F D2454D                  DB       0D2H,"EM"
  391 0262 D3544F50                DB       0D3H,"TOP"
  392 0266 CF5554                  DB       0CFH,"UT"
  393 0269 CF4E                    DB       0CFH,"N"
  394 026B CE554C4C                DB       0CEH,"ULL"
  395 026F D7414954                DB       0D7H,"AIT"
  396 0273 C44546                  DB       0C4H,"EF"
  397 0276 D04F4B45                DB       0D0H,"OKE"
  398 027A C44F4B45                DB       0C4H,"OKE"
  399 027E D3435245454E            DB       0D3H,"CREEN"
  400 0284 CC494E4553              DB       0CCH,"INES"
  401 0289 C34C53                  DB       0C3H,"LS"
  402 028C D749445448              DB       0D7H,"IDTH"
  403 0291 CD4F4E49544F            DB       0CDH,"ONITOR"
           52           
  404 0298 D34554                  DB       0D3H,"ET"
  405 029B D245534554              DB       0D2H,"ESET"
  406 02A0 D052494E54              DB       0D0H,"RINT"
  407 02A5 C34F4E54                DB       0C3H,"ONT"
  408 02A9 CC495354                DB       0CCH,"IST"
  409 02AD C34C454152              DB       0C3H,"LEAR"
  410 02B2 C34C4F4144              DB       0C3H,"LOAD"
  411 02B7 C353415645              DB       0C3H,"SAVE"
  412 02BC CE4557                  DB       0CEH,"EW"
  413                   ;
  414 02BF D4414228                DB       0D4H,"AB("
  415 02C3 D44F                    DB       0D4H,"O"
  416 02C5 C64E                    DB       0C6H,"N"
  417 02C7 D3504328                DB       0D3H,"PC("
  418 02CB D448454E                DB       0D4H,"HEN"
  419 02CF CE4F54                  DB       0CEH,"OT"
  420 02D2 D3544550                DB       0D3H,"TEP"
  421                   ;
  422 02D6 AB                      DB       0ABH
  423 02D7 AD                      DB       0ADH
  424 02D8 AA                      DB       0AAH
  425 02D9 AF                      DB       0AFH
  426 02DA DE                      DB       0DEH
  427 02DB C14E44                  DB       0C1H,"ND"
  428 02DE CF52                    DB       0CFH,"R"
  429 02E0 BE                      DB       0BEH
  430 02E1 BD                      DB       0BDH
  431 02E2 BC                      DB       0BCH
  432                   ;
  433 02E3 D3474E                  DB       0D3H,"GN"
  434 02E6 C94E54                  DB       0C9H,"NT"
  435 02E9 C14253                  DB       0C1H,"BS"
  436 02EC D55352                  DB       0D5H,"SR"
  437 02EF C65245                  DB       0C6H,"RE"
  438 02F2 C94E50                  DB       0C9H,"NP"
  439 02F5 D04F53                  DB       0D0H,"OS"
  440 02F8 D35152                  DB       0D3H,"QR"
  441 02FB D24E44                  DB       0D2H,"ND"
  442 02FE CC4F47                  DB       0CCH,"OG"
  443 0301 C55850                  DB       0C5H,"XP"
  444 0304 C34F53                  DB       0C3H,"OS"
  445 0307 D3494E                  DB       0D3H,"IN"
  446 030A D4414E                  DB       0D4H,"AN"
  447 030D C1544E                  DB       0C1H,"TN"
  448 0310 D045454B                DB       0D0H,"EEK"
  449 0314 C445454B                DB       0C4H,"EEK"
  450 0318 D04F494E54              DB       0D0H,"OINT"
  451 031D CC454E                  DB       0CCH,"EN"
  452 0320 D3545224                DB       0D3H,"TR$"
  453 0324 D6414C                  DB       0D6H,"AL"
  454 0327 C15343                  DB       0C1H,"SC"
  455 032A C3485224                DB       0C3H,"HR$"
  456 032E C8455824                DB       0C8H,"EX$"
  457 0332 C2494E24                DB       0C2H,"IN$"
  458 0336 CC45465424              DB       0CCH,"EFT$"
  459 033B D24947485424            DB       0D2H,"IGHT$"
  460 0341 CD494424                DB       0CDH,"ID$"
  461 0345 80                      DB       80H         ; End of list marker
  462                   ;
  463                   ; KEYWORD ADDRESS TABLE
  464                   ;
  465 0346 4E09         WORDTB:    DW       PEND
  466 0348 4108                    DW       FOR
  467 034A 260D                    DW       NEXT
  468 034C 9B0A                    DW       DATA
  469 034E 2D0C                    DW       INPUT
  470 0350 630F                    DW       DIM
  471 0352 5C0C                    DW       READ
  472 0354 B20A                    DW       LET
  473 0356 580A                    DW       GOTO
  474 0358 3B0A                    DW       RUN
  475 035A 2A0B                    DW       IF
  476 035C 0A09                    DW       RESTOR
  477 035E 470A                    DW       GOSUB
  478 0360 760A                    DW       RETURN
  479 0362 9D0A                    DW       REM
  480 0364 4C09                    DW       STOP
  481 0366 9E14                    DW       POUT
  482 0368 0C0B                    DW       ON
  483 036A 8D09                    DW       NULL
  484 036C A414                    DW       WAIT
  485 036E 4111                    DW       DEF
  486 0370 ED14                    DW       POKE
  487 0372 351C                    DW       DOKE
  488 0374 9D0A                    DW       REM
  489 0376 191C                    DW       LINES
  490 0378 0C1C                    DW       CLS
  491 037A 111C                    DW       WIDTH
  492 037C 571D                    DW       MONITR
  493 037E 9980                    DW       PSET
  494 0380 9C80                    DW       RESET
  495 0382 4E0B                    DW       PRINT
  496 0384 7A09                    DW       CONT
  497 0386 B207                    DW       LIST
  498 0388 F509                    DW       CLEAR
  499 038A 9D0A                    DW       REM
  500 038C 9D0A                    DW       REM
  501 038E AA05                    DW       NEW
  502                   ;
  503                   ; RESERVED WORD TOKEN VALUES
  504                   ;
  505 0080              ZEND       EQU      080H        ; END
  506 0081              ZFOR       EQU      081H        ; FOR
  507 0083              ZDATA      EQU      083H        ; DATA
  508 0088              ZGOTO      EQU      088H        ; GOTO
  509 008C              ZGOSUB     EQU      08CH        ; GOSUB
  510 008E              ZREM       EQU      08EH        ; REM
  511 009E              ZPRINT     EQU      09EH        ; PRINT
  512 00A4              ZNEW       EQU      0A4H        ; NEW
  513                   ;
  514 00A5              ZTAB       EQU      0A5H        ; TAB
  515 00A6              ZTO        EQU      0A6H        ; TO
  516 00A7              ZFN        EQU      0A7H        ; FN
  517 00A8              ZSPC       EQU      0A8H        ; SPC
  518 00A9              ZTHEN      EQU      0A9H        ; THEN
  519 00AA              ZNOT       EQU      0AAH        ; NOT
  520 00AB              ZSTEP      EQU      0ABH        ; STEP
  521                   ;
  522 00AC              ZPLUS      EQU      0ACH        ; +
  523 00AD              ZMINUS     EQU      0ADH        ; -
  524 00AE              ZTIMES     EQU      0AEH        ; *
  525 00AF              ZDIV       EQU      0AFH        ; /
  526 00B2              ZOR        EQU      0B2H        ; OR
  527 00B3              ZGTR       EQU      0B3H        ; >
  528 00B4              ZEQUAL     EQU      0B4H        ; M
  529 00B5              ZLTH       EQU      0B5H        ; <
  530 00B6              ZSGN       EQU      0B6H        ; SGN
  531 00C7              ZPOINT     EQU      0C7H        ; POINT
  532 00CF              ZLEFT      EQU      0CDH +2     ; LEFT$
  533                   ;
  534                   ; ARITHMETIC PRECEDENCE TABLE
  535                   ;
  536 0390 79           PRITAB:    DB       79H         ; Precedence value
  537 0391 D718                    DW       PADD        ; FPREG = <last> + FPRE
  538                   ;
  539 0393 79                      DB       79H         ; Precedence value
  540 0394 0B15                    DW       PSUB        ; FPREG = <last> - FPRE
  541                   ;
  542 0396 7C                      DB       7CH         ; Precedence value
  543 0397 4916                    DW       MULT        ; PPREG = <last> * FPRE
  544                   ;
  545 0399 7C                      DB       7CH         ; Precedence value
  546 039A AA16                    DW       DIV         ; FPREG = <last> / FPRE
  547                   ;
  548 039C 7F                      DB       7FH         ; Precedence value
  549 039D F819                    DW       POWER       ; FPREG = <last> ^ FPRE
  550                   ;
  551 039F 50                      DB       50H         ; Precedence value
  552 03A0 BC0E                    DW       PAND        ; FPREG = <last> AND FP
  553                   ;
  554 03A2 46                      DB       46H         ; Precedence value
  555 03A3 BB0E                    DW       POR         ; FPREG = <last> OR FPR
  556                   ;
  557                   ; BASIC ERROR CODE LIST
  558                   ;
  559 03A5 4E46         ERRORS:    DB       "NF"        ; NEXT without FOR
  560 03A7 534E                    DB       "SN"        ; Syntax error
  561 03A9 5247                    DB       "RG"        ; RETURN without GOSUB
  562 03AB 4F44                    DB       "OD"        ; Out of DATA
  563 03AD 4643                    DB       "FC"        ; Illegal function call
  564 03AF 4F56                    DB       "OV"        ; Overflow error
  565 03B1 4F4D                    DB       "OM"        ; Out of memory
  566 03B3 554C                    DB       "UL"        ; Undefined line
  567 03B5 4253                    DB       "BS"        ; Bad subscript
  568 03B7 4444                    DB       "DD"        ; Re-DIMensioned array
  569 03B9 2F30                    DB       "/0"        ; Division by zero
  570 03BB 4944                    DB       "ID"        ; Illegal direct
  571 03BD 544D                    DB       "TM"        ; Type mis-match
  572 03BF 4F53                    DB       "OS"        ; Out of string space
  573 03C1 4C53                    DB       "LS"        ; String too long
  574 03C3 5354                    DB       "ST"        ; String formula too co
  575 03C5 434E                    DB       "CN"        ; Can't CONTinue
  576 03C7 5546                    DB       "UF"        ; Undefined FN function
  577 03C9 4D4F                    DB       "MO"        ; Missing operand
  578 03CB 4858                    DB       "HX"        ; HEX error
  579 03CD 424E                    DB       "BN"        ; BIN error
  580                   ;
  581                   ; INITIALISATION TABLE --------------------------------
  582                   ;
  583 03CF C35F01       INITAB:    JP       WARMST      ; Warm start jump
  584 03D2 C3CB09                  JP       FCERR       ; "USR (X)" jump (Set t
  585 03D5 D300                    OUT      (0),A       ; "OUT p,n" skeleton
  586 03D7 C9                      RET
  587 03D8 D600                    SUB      0           ; Division support rout
  588 03DA 6F                      LD       L,A
  589 03DB 7C                      LD       A,H
  590 03DC DE00                    SBC      A,0
  591 03DE 67                      LD       H,A
  592 03DF 78                      LD       A,B
  593 03E0 DE00                    SBC      A,0
  594 03E2 47                      LD       B,A
  595 03E3 3E00                    LD       A,0
  596 03E5 C9                      RET
  597 03E6 000000                  DB       0,0,0       ; Random number seed ta
  598 03E9 354ACA99                DB       035H,04AH,0CAH,099H ;-2.65145E+07
  599 03ED 391C7698                DB       039H,01CH,076H,098H ; 1.61291E+07
  600 03F1 2295B398                DB       022H,095H,0B3H,098H ;-1.17691E+07
  601 03F5 0ADD4798                DB       00AH,0DDH,047H,098H ; 1.30983E+07
  602 03F9 53D19999                DB       053H,0D1H,099H,099H ;-2-01612E+07
  603 03FD 0A1A9F98                DB       00AH,01AH,09FH,098H ;-1.04269E+07
  604 0401 65BCCD98                DB       065H,0BCH,0CDH,098H ;-1.34831E+07
  605 0405 D6773E98                DB       0D6H,077H,03EH,098H ; 1.24825E+07
  606 0409 52C74F80                DB       052H,0C7H,04FH,080H ; Last random n
  607 040D DB00                    IN       A,(0)       ; INP (x) skeleton
  608 040F C9                      RET
  609 0410 01                      DB       1           ; POS (x) number (1)
  610 0411 FF                      DB       255         ; Terminal width (255 =
  611 0412 1C                      DB       28          ; Width for commas (3 c
  612 0413 00                      DB       0           ; No nulls after input 
  613 0414 00                      DB       0           ; Output enabled (^O of
  614 0415 1400                    DW       20          ; Initial lines counter
  615 0417 1400                    DW       20          ; Initial lines number
  616 0419 0000                    DW       0           ; Array load/save check
  617 041B 00                      DB       0           ; Break not by NMI
  618 041C 00                      DB       0           ; Break flag
  619 041D C3E306                  JP       TTYLIN      ; Input reflection (set
  620 0420 C30000                  JP       0000H       ; POINT reflection unus
  621 0423 C30000                  JP       0000H       ; SET reflection
  622 0426 C30000                  JP       0000H       ; RESET reflection
  623 0429 A281                    DW       STLOOK      ; Temp string space
  624 042B FEFF                    DW       -2          ; Current line number (
  625 042D 3F81                    DW       PROGST+1    ; Start of program text
  626 042F              INITBE:
  627                   ;
  628                   ; END OF INITIALISATION TABLE -------------------------
  629                   ;
  630 042F 204572726F72 ERRMSG:    DB       " Error",0
           00           
  631 0436 20696E2000   INMSG:     DB       " in ",0
  632 043A              ZERBYT     EQU      $-1         ; A zero byte
  633 043B 4F6B0D0A0000 OKMSG:     DB       "Ok",CR,LF,0,0
  634 0441 427265616B00 BRKMSG:    DB       "Break",0
  635                   ;
  636 0447 210400       BAKSTK:    LD       HL,4        ; Look for "FOR" block 
  637 044A 39                      ADD      HL,SP       ; same index as specifi
  638 044B 7E           LOKFOR:    LD       A,(HL)      ; Get block ID
  639 044C 23                      INC      HL          ; Point to index addres
  640 044D FE81                    CP       ZFOR        ; Is it a "FOR" token
  641 044F C0                      RET      NZ          ; No - exit
  642 0450 4E                      LD       C,(HL)      ; BC = Address of "FOR"
  643 0451 23                      INC      HL
  644 0452 46                      LD       B,(HL)
  645 0453 23                      INC      HL          ; Point to sign of STEP
  646 0454 E5                      PUSH     HL          ; Save pointer to sign
  647 0455 69                      LD       L,C         ; HL = address of "FOR"
  648 0456 60                      LD       H,B
  649 0457 7A                      LD       A,D         ; See if an index was s
  650 0458 B3                      OR       E           ; DE = 0 if no index sp
  651 0459 EB                      EX       DE,HL       ; Specified index into 
  652 045A CA6104                  JP       Z,INDFND    ; Skip if no index give
  653 045D EB                      EX       DE,HL       ; Index back into DE
  654 045E CD6607                  CALL     CPDEHL      ; Compare index with on
  655 0461 010D00       INDFND:    LD       BC,16-3     ; Offset to next block
  656 0464 E1                      POP      HL          ; Restore pointer to si
  657 0465 C8                      RET      Z           ; Return if block found
  658 0466 09                      ADD      HL,BC       ; Point to next block
  659 0467 C34B04                  JP       LOKFOR      ; Keep on looking
  660                   ;
  661 046A CD8404       MOVUP:     CALL     ENFMEM      ; See if enough memory
  662 046D C5           MOVSTR:    PUSH     BC          ; Save end of source
  663 046E E3                      EX       (SP),HL     ; Swap source and dest"
  664 046F C1                      POP      BC          ; Get end of destinatio
  665 0470 CD6607       MOVLP:     CALL     CPDEHL      ; See if list moved
  666 0473 7E                      LD       A,(HL)      ; Get byte
  667 0474 02                      LD       (BC),A      ; Move it
  668 0475 C8                      RET      Z           ; Exit if all done
  669 0476 0B                      DEC      BC          ; Next byte to move to
  670 0477 2B                      DEC      HL          ; Next byte to move
  671 0478 C37004                  JP       MOVLP       ; Loop until all bytes 
  672                   ;
  673 047B E5           CHKSTK:    PUSH     HL          ; Save code string addr
  674 047C 2A1F81                  LD       HL,(ARREND) ; Lowest free memory
  675 047F 0600                    LD       B,0         ; BC = Number of levels
  676 0481 09                      ADD      HL,BC       ; 2 Bytes for each leve
  677 0482 09                      ADD      HL,BC
  678 0483 3E                      DB       3EH         ; Skip "PUSH HL"
  679 0484 E5           ENFMEM:    PUSH     HL          ; Save code string addr
  680 0485 3ED0                    LD       A,0D0H      ; LOW -48; 48 Bytes min
  681 0487 95                      SUB      L
  682 0488 6F                      LD       L,A
  683 0489 3EFF                    LD       A,0FFH      ; HIGH (-48); 48 Bytes 
  684 048B 9C                      SBC      A,H
  685 048C DA9304                  JP       C,OMERR     ; Not enough - ?OM Erro
  686 048F 67                      LD       H,A
  687 0490 39                      ADD      HL,SP       ; Test if stack is over
  688 0491 E1                      POP      HL          ; Restore code string a
  689 0492 D8                      RET      C           ; Return if enough mmor
  690 0493 1E0C         OMERR:     LD       E,OM        ; ?OM Error
  691 0495 C3B204                  JP       ERROR
  692                   ;
  693 0498 2A0E81       DATSNR:    LD       HL,(DATLIN) ; Get line of current D
  694 049B 22A180                  LD       (LINEAT),HL ; Save as current line
  695 049E 1E02         SNERR:     LD       E,SN        ; ?SN Error
  696 04A0 01                      DB       01H         ; Skip "LD E,DZ"
  697 04A1 1E14         DZERR:     LD       E,DZ        ; ?/0 Error
  698 04A3 01                      DB       01H         ; Skip "LD E,NF"
  699 04A4 1E00         NFERR:     LD       E,NF        ; ?NF Error
  700 04A6 01                      DB       01H         ; Skip "LD E,RD"
  701 04A7 1E12         DDERR:     LD       E,RD        ; ?DD Error
  702 04A9 01                      DB       01H         ; Skip "LD E,UF"
  703 04AA 1E22         UFERR:     LD       E,UF        ; ?UF Error
  704 04AC 01                      DB       01H         ; Skip "LD E,OV
  705 04AD 1E0A         OVERR:     LD       E,OV        ; ?OV Error
  706 04AF 01                      DB       01H         ; Skip "LD E,TM"
  707 04B0 1E18         TMERR:     LD       E,TM        ; ?TM Error
  708                   ;
  709 04B2 CDD005       ERROR:     CALL     CLREG       ; Clear registers and s
  710 04B5 328A80                  LD       (CTLOFG),A  ; Enable output (A is 0
  711 04B8 CD9F0B                  CALL     STTLIN      ; Start new line
  712 04BB 21A503                  LD       HL,ERRORS   ; Point to error codes
  713 04BE 57                      LD       D,A         ; D = 0 (A is 0)
  714 04BF 3E3F                    LD       A,'?'
  715 04C1 CD7707                  CALL     OUTC        ; Output '?'
  716 04C4 19                      ADD      HL,DE       ; Offset to correct err
  717 04C5 7E                      LD       A,(HL)      ; First character
  718 04C6 CD7707                  CALL     OUTC        ; Output it
  719 04C9 CDFA08                  CALL     GETCHR      ; Get next character
  720 04CC CD7707                  CALL     OUTC        ; Output it
  721 04CF 212F04                  LD       HL,ERRMSG   ; "Error" message
  722 04D2 CD4B12       ERRIN:     CALL     PRS         ; Output message
  723 04D5 2AA180                  LD       HL,(LINEAT) ; Get line of error
  724 04D8 11FEFF                  LD       DE,-2       ; Cold start error if -
  725 04DB CD6607                  CALL     CPDEHL      ; See if cold start err
  726 04DE CAF100                  JP       Z,CSTART    ; Cold start error - Re
  727 04E1 7C                      LD       A,H         ; Was it a direct error
  728 04E2 A5                      AND      L           ; Line = -1 if direct e
  729 04E3 3C                      INC      A
  730 04E4 C4E818                  CALL     NZ,LINEIN   ; No - output line of e
  731 04E7 3E                      DB       3EH         ; Skip "POP BC"
  732 04E8 C1           POPNOK:    POP      BC          ; Drop address in input
  733                   ;
  734 04E9 AF           PRNTOK:    XOR      A           ; Output "Ok" and get c
  735 04EA 328A80                  LD       (CTLOFG),A  ; Enable output
  736 04ED CD9F0B                  CALL     STTLIN      ; Start new line
  737 04F0 213B04                  LD       HL,OKMSG    ; "Ok" message
  738 04F3 CD4B12                  CALL     PRS         ; Output "Ok"
  739 04F6 21FFFF       GETCMD:    LD       HL,-1       ; Flag direct mode
  740 04F9 22A180                  LD       (LINEAT),HL ; Save as current line
  741 04FC CDE306                  CALL     GETLIN      ; Get an input line
  742 04FF DAF604                  JP       C,GETCMD    ; Get line again if bre
  743 0502 CDFA08                  CALL     GETCHR      ; Get first character
  744 0505 3C                      INC      A           ; Test if end of line
  745 0506 3D                      DEC      A           ; Without affecting Car
  746 0507 CAF604                  JP       Z,GETCMD    ; Nothing entered - Get
  747 050A F5                      PUSH     AF          ; Save Carry status
  748 050B CDD009                  CALL     ATOH        ; Get line number into 
  749 050E D5                      PUSH     DE          ; Save line number
  750 050F CDFA05                  CALL     CRUNCH      ; Tokenise rest of line
  751 0512 47                      LD       B,A         ; Length of tokenised l
  752 0513 D1                      POP      DE          ; Restore line number
  753 0514 F1                      POP      AF          ; Restore Carry
  754 0515 D2DA08                  JP       NC,EXCUTE   ; No line number - Dire
  755 0518 D5                      PUSH     DE          ; Save line number
  756 0519 C5                      PUSH     BC          ; Save length of tokeni
  757 051A AF                      XOR      A
  758 051B 321181                  LD       (LSTBIN),A  ; Clear last byte input
  759 051E CDFA08                  CALL     GETCHR      ; Get next character
  760 0521 B7                      OR       A           ; Set flags
  761 0522 F5                      PUSH     AF          ; And save them
  762 0523 CD8A05                  CALL     SRCHLN      ; Search for line numbe
  763 0526 DA2F05                  JP       C,LINFND    ; Jump if line found
  764 0529 F1                      POP      AF          ; Get status
  765 052A F5                      PUSH     AF          ; And re-save
  766 052B CA710A                  JP       Z,ULERR     ; Nothing after number 
  767 052E B7                      OR       A           ; Clear Carry
  768 052F C5           LINFND:    PUSH     BC          ; Save address of line 
  769 0530 D24605                  JP       NC,INEWLN   ; Line not found - Inse
  770 0533 EB                      EX       DE,HL       ; Next line address in 
  771 0534 2A1B81                  LD       HL,(PROGND) ; End of program
  772 0537 1A           SFTPRG:    LD       A,(DE)      ; Shift rest of program
  773 0538 02                      LD       (BC),A
  774 0539 03                      INC      BC          ; Next destination
  775 053A 13                      INC      DE          ; Next source
  776 053B CD6607                  CALL     CPDEHL      ; All done?
  777 053E C23705                  JP       NZ,SFTPRG   ; More to do
  778 0541 60                      LD       H,B         ; HL - New end of progr
  779 0542 69                      LD       L,C
  780 0543 221B81                  LD       (PROGND),HL ; Update end of program
  781                   ;
  782 0546 D1           INEWLN:    POP      DE          ; Get address of line,
  783 0547 F1                      POP      AF          ; Get status
  784 0548 CA6D05                  JP       Z,SETPTR    ; No text - Set up poin
  785 054B 2A1B81                  LD       HL,(PROGND) ; Get end of program
  786 054E E3                      EX       (SP),HL     ; Get length of input l
  787 054F C1                      POP      BC          ; End of program to BC
  788 0550 09                      ADD      HL,BC       ; Find new end
  789 0551 E5                      PUSH     HL          ; Save new end
  790 0552 CD6A04                  CALL     MOVUP       ; Make space for line
  791 0555 E1                      POP      HL          ; Restore new end
  792 0556 221B81                  LD       (PROGND),HL ; Update end of program
  793 0559 EB                      EX       DE,HL       ; Get line to move up i
  794 055A 74                      LD       (HL),H      ; Save MSB
  795 055B D1                      POP      DE          ; Get new line number
  796 055C 23                      INC      HL          ; Skip pointer
  797 055D 23                      INC      HL
  798 055E 73                      LD       (HL),E      ; Save LSB of line numb
  799 055F 23                      INC      HL
  800 0560 72                      LD       (HL),D      ; Save MSB of line numb
  801 0561 23                      INC      HL          ; To first byte in line
  802 0562 11A680                  LD       DE,BUFFER   ; Copy buffer to progra
  803 0565 1A           MOVBUF:    LD       A,(DE)      ; Get source
  804 0566 77                      LD       (HL),A      ; Save destinations
  805 0567 23                      INC      HL          ; Next source
  806 0568 13                      INC      DE          ; Next destination
  807 0569 B7                      OR       A           ; Done?
  808 056A C26505                  JP       NZ,MOVBUF   ; No - Repeat
  809 056D CDB605       SETPTR:    CALL     RUNFST      ; Set line pointers
  810 0570 23                      INC      HL          ; To LSB of pointer
  811 0571 EB                      EX       DE,HL       ; Address to DE
  812 0572 62           PTRLP:     LD       H,D         ; Address to HL
  813 0573 6B                      LD       L,E
  814 0574 7E                      LD       A,(HL)      ; Get LSB of pointer
  815 0575 23                      INC      HL          ; To MSB of pointer
  816 0576 B6                      OR       (HL)        ; Compare with MSB poin
  817 0577 CAF604                  JP       Z,GETCMD    ; Get command line if e
  818 057A 23                      INC      HL          ; To LSB of line number
  819 057B 23                      INC      HL          ; Skip line number
  820 057C 23                      INC      HL          ; Point to first byte i
  821 057D AF                      XOR      A           ; Looking for 00 byte
  822 057E BE           FNDEND:    CP       (HL)        ; Found end of line?
  823 057F 23                      INC      HL          ; Move to next byte
  824 0580 C27E05                  JP       NZ,FNDEND   ; No - Keep looking
  825 0583 EB                      EX       DE,HL       ; Next line address to 
  826 0584 73                      LD       (HL),E      ; Save LSB of pointer
  827 0585 23                      INC      HL
  828 0586 72                      LD       (HL),D      ; Save MSB of pointer
  829 0587 C37205                  JP       PTRLP       ; Do next line
  830                   ;
  831 058A 2AA380       SRCHLN:    LD       HL,(BASTXT) ; Start of program text
  832 058D 44           SRCHLP:    LD       B,H         ; BC = Address to look 
  833 058E 4D                      LD       C,L
  834 058F 7E                      LD       A,(HL)      ; Get address of next l
  835 0590 23                      INC      HL
  836 0591 B6                      OR       (HL)        ; End of program found?
  837 0592 2B                      DEC      HL
  838 0593 C8                      RET      Z           ; Yes - Line not found
  839 0594 23                      INC      HL
  840 0595 23                      INC      HL
  841 0596 7E                      LD       A,(HL)      ; Get LSB of line numbe
  842 0597 23                      INC      HL
  843 0598 66                      LD       H,(HL)      ; Get MSB of line numbe
  844 0599 6F                      LD       L,A
  845 059A CD6607                  CALL     CPDEHL      ; Compare with line in 
  846 059D 60                      LD       H,B         ; HL = Start of this li
  847 059E 69                      LD       L,C
  848 059F 7E                      LD       A,(HL)      ; Get LSB of next line 
  849 05A0 23                      INC      HL
  850 05A1 66                      LD       H,(HL)      ; Get MSB of next line 
  851 05A2 6F                      LD       L,A         ; Next line to HL
  852 05A3 3F                      CCF
  853 05A4 C8                      RET      Z           ; Lines found - Exit
  854 05A5 3F                      CCF
  855 05A6 D0                      RET      NC          ; Line not found,at lin
  856 05A7 C38D05                  JP       SRCHLP      ; Keep looking
  857                   ;
  858 05AA C0           NEW:       RET      NZ          ; Return if any more on
  859 05AB 2AA380       CLRPTR:    LD       HL,(BASTXT) ; Point to start of pro
  860 05AE AF                      XOR      A           ; Set program area to e
  861 05AF 77                      LD       (HL),A      ; Save LSB = 00
  862 05B0 23                      INC      HL
  863 05B1 77                      LD       (HL),A      ; Save MSB = 00
  864 05B2 23                      INC      HL
  865 05B3 221B81                  LD       (PROGND),HL ; Set program end
  866                   ;
  867 05B6 2AA380       RUNFST:    LD       HL,(BASTXT) ; Clear all variables
  868 05B9 2B                      DEC      HL
  869                   ;
  870 05BA 221381       INTVAR:    LD       (BRKLIN),HL ; Initialise RUN variab
  871 05BD 2AF480                  LD       HL,(LSTRAM) ; Get end of RAM
  872 05C0 220881                  LD       (STRBOT),HL ; Clear string space
  873 05C3 AF                      XOR      A
  874 05C4 CD0A09                  CALL     RESTOR      ; Reset DATA pointers
  875 05C7 2A1B81                  LD       HL,(PROGND) ; Get end of program
  876 05CA 221D81                  LD       (VAREND),HL ; Clear variables
  877 05CD 221F81                  LD       (ARREND),HL ; Clear arrays
  878                   ;
  879 05D0 C1           CLREG:     POP      BC          ; Save return address
  880 05D1 2A9F80                  LD       HL,(STRSPC) ; Get end of working RA
  881 05D4 F9                      LD       SP,HL       ; Set stack
  882 05D5 21F880                  LD       HL,TMSTPL   ; Temporary string pool
  883 05D8 22F680                  LD       (TMSTPT),HL ; Reset temporary strin
  884 05DB AF                      XOR      A           ; A = 00
  885 05DC 6F                      LD       L,A         ; HL = 0000
  886 05DD 67                      LD       H,A
  887 05DE 221981                  LD       (CONTAD),HL ; No CONTinue
  888 05E1 321081                  LD       (FORFLG),A  ; Clear FOR flag
  889 05E4 222381                  LD       (FNRGNM),HL ; Clear FN argument
  890 05E7 E5                      PUSH     HL          ; HL = 0000
  891 05E8 C5                      PUSH     BC          ; Put back return
  892 05E9 2A1381       DOAGN:     LD       HL,(BRKLIN) ; Get address of code t
  893 05EC C9                      RET                  ; Return to execution d
  894                   ;
  895 05ED 3E3F         PROMPT:    LD       A,'?'       ; '?'
  896 05EF CD7707                  CALL     OUTC        ; Output character
  897 05F2 3E20                    LD       A,' '       ; Space
  898 05F4 CD7707                  CALL     OUTC        ; Output character
  899 05F7 C39380                  JP       RINPUT      ; Get input line
  900                   ;
  901 05FA AF           CRUNCH:    XOR      A           ; Tokenise line @ HL to
  902 05FB 32F380                  LD       (DATFLG),A  ; Reset literal flag
  903 05FE 0E05                    LD       C,2+3       ; 2 byte number and 3 n
  904 0600 11A680                  LD       DE,BUFFER   ; Start of input buffer
  905 0603 7E           CRNCLP:    LD       A,(HL)      ; Get byte
  906 0604 FE20                    CP       ' '         ; Is it a space?
  907 0606 CA8206                  JP       Z,MOVDIR    ; Yes - Copy direct
  908 0609 47                      LD       B,A         ; Save character
  909 060A FE22                    CP       '"'         ; Is it a quote?
  910 060C CAA206                  JP       Z,CPYLIT    ; Yes - Copy literal st
  911 060F B7                      OR       A           ; Is it end of buffer?
  912 0610 CAA906                  JP       Z,ENDBUF    ; Yes - End buffer
  913 0613 3AF380                  LD       A,(DATFLG)  ; Get data type
  914 0616 B7                      OR       A           ; Literal?
  915 0617 7E                      LD       A,(HL)      ; Get byte to copy
  916 0618 C28206                  JP       NZ,MOVDIR   ; Literal - Copy direct
  917 061B FE3F                    CP       '?'         ; Is it '?' short for P
  918 061D 3E9E                    LD       A,ZPRINT    ; "PRINT" token
  919 061F CA8206                  JP       Z,MOVDIR    ; Yes - replace it
  920 0622 7E                      LD       A,(HL)      ; Get byte again
  921 0623 FE30                    CP       '0'         ; Is it less than '0'
  922 0625 DA2D06                  JP       C,FNDWRD    ; Yes - Look for reserv
  923 0628 FE3C                    CP       60          ; ";"+1; Is it "0123456
  924 062A DA8206                  JP       C,MOVDIR    ; Yes - copy it direct
  925 062D D5           FNDWRD:    PUSH     DE          ; Look for reserved wor
  926 062E 112602                  LD       DE,WORDS-1  ; Point to table
  927 0631 C5                      PUSH     BC          ; Save count
  928 0632 017E06                  LD       BC,RETNAD   ; Where to return to
  929 0635 C5                      PUSH     BC          ; Save return address
  930 0636 067F                    LD       B,ZEND-1    ; First token value -1
  931 0638 7E                      LD       A,(HL)      ; Get byte
  932 0639 FE61                    CP       'a'         ; Less than 'a' ?
  933 063B DA4606                  JP       C,SEARCH    ; Yes - search for word
  934 063E FE7B                    CP       'z'+1       ; Greater than 'z' ?
  935 0640 D24606                  JP       NC,SEARCH   ; Yes - search for word
  936 0643 E65F                    AND      01011111B   ; Force upper case
  937 0645 77                      LD       (HL),A      ; Replace byte
  938 0646 4E           SEARCH:    LD       C,(HL)      ; Search for a word
  939 0647 EB                      EX       DE,HL
  940 0648 23           GETNXT:    INC      HL          ; Get next reserved wor
  941 0649 B6                      OR       (HL)        ; Start of word?
  942 064A F24806                  JP       P,GETNXT    ; No - move on
  943 064D 04                      INC      B           ; Increment token value
  944 064E 7E                      LD       A, (HL)     ; Get byte from table
  945 064F E67F                    AND      01111111B   ; Strip bit 7
  946 0651 C8                      RET      Z           ; Return if end of list
  947 0652 B9                      CP       C           ; Same character as in 
  948 0653 C24806                  JP       NZ,GETNXT   ; No - get next word
  949 0656 EB                      EX       DE,HL
  950 0657 E5                      PUSH     HL          ; Save start of word
  951                   ;
  952 0658 13           NXTBYT:    INC      DE          ; Look through rest of 
  953 0659 1A                      LD       A,(DE)      ; Get byte from table
  954 065A B7                      OR       A           ; End of word ?
  955 065B FA7A06                  JP       M,MATCH     ; Yes - Match found
  956 065E 4F                      LD       C,A         ; Save it
  957 065F 78                      LD       A,B         ; Get token value
  958 0660 FE88                    CP       ZGOTO       ; Is it "GOTO" token ?
  959 0662 C26906                  JP       NZ,NOSPC    ; No - Don't allow spac
  960 0665 CDFA08                  CALL     GETCHR      ; Get next character
  961 0668 2B                      DEC      HL          ; Cancel increment from
  962 0669 23           NOSPC:     INC      HL          ; Next byte
  963 066A 7E                      LD       A,(HL)      ; Get byte
  964 066B FE61                    CP       'a'         ; Less than 'a' ?
  965 066D DA7206                  JP       C,NOCHNG    ; Yes - don't change
  966 0670 E65F                    AND      01011111B   ; Make upper case
  967 0672 B9           NOCHNG:    CP       C           ; Same as in buffer ?
  968 0673 CA5806                  JP       Z,NXTBYT    ; Yes - keep testing
  969 0676 E1                      POP      HL          ; Get back start of wor
  970 0677 C34606                  JP       SEARCH      ; Look at next word
  971                   ;
  972 067A 48           MATCH:     LD       C,B         ; Word found - Save tok
  973 067B F1                      POP      AF          ; Throw away return
  974 067C EB                      EX       DE,HL
  975 067D C9                      RET                  ; Return to "RETNAD"
  976 067E EB           RETNAD:    EX       DE,HL       ; Get address in string
  977 067F 79                      LD       A,C         ; Get token value
  978 0680 C1                      POP      BC          ; Restore buffer length
  979 0681 D1                      POP      DE          ; Get destination addre
  980 0682 23           MOVDIR:    INC      HL          ; Next source in buffer
  981 0683 12                      LD       (DE),A      ; Put byte in buffer
  982 0684 13                      INC      DE          ; Move up buffer
  983 0685 0C                      INC      C           ; Increment length of b
  984 0686 D63A                    SUB      ':'         ; End of statement?
  985 0688 CA9006                  JP       Z,SETLIT    ; Jump if multi-stateme
  986 068B FE49                    CP       ZDATA-3AH   ; Is it DATA statement 
  987 068D C29306                  JP       NZ,TSTREM   ; No - see if REM
  988 0690 32F380       SETLIT:    LD       (DATFLG),A  ; Set literal flag
  989 0693 D654         TSTREM:    SUB      ZREM-3AH    ; Is it REM?
  990 0695 C20306                  JP       NZ,CRNCLP   ; No - Leave flag
  991 0698 47                      LD       B,A         ; Copy rest of buffer
  992 0699 7E           NXTCHR:    LD       A,(HL)      ; Get byte
  993 069A B7                      OR       A           ; End of line ?
  994 069B CAA906                  JP       Z,ENDBUF    ; Yes - Terminate buffe
  995 069E B8                      CP       B           ; End of statement ?
  996 069F CA8206                  JP       Z,MOVDIR    ; Yes - Get next one
  997 06A2 23           CPYLIT:    INC      HL          ; Move up source string
  998 06A3 12                      LD       (DE),A      ; Save in destination
  999 06A4 0C                      INC      C           ; Increment length
 1000 06A5 13                      INC      DE          ; Move up destination
 1001 06A6 C39906                  JP       NXTCHR      ; Repeat
 1002                   ;
 1003 06A9 21A580       ENDBUF:    LD       HL,BUFFER-1 ; Point to start of buf
 1004 06AC 12                      LD       (DE),A      ; Mark end of buffer (A
 1005 06AD 13                      INC      DE
 1006 06AE 12                      LD       (DE),A      ; A = 00
 1007 06AF 13                      INC      DE
 1008 06B0 12                      LD       (DE),A      ; A = 00
 1009 06B1 C9                      RET
 1010                   ;
 1011 06B2 3A8980       DODEL:     LD       A,(NULFLG)  ; Get null flag status
 1012 06B5 B7                      OR       A           ; Is it zero?
 1013 06B6 3E00                    LD       A,0         ; Zero A - Leave flags
 1014 06B8 328980                  LD       (NULFLG),A  ; Zero null flag
 1015 06BB C2C606                  JP       NZ,ECHDEL   ; Set - Echo it
 1016 06BE 05                      DEC      B           ; Decrement length
 1017 06BF CAE306                  JP       Z,GETLIN    ; Get line again if emp
 1018 06C2 CD7707                  CALL     OUTC        ; Output null character
 1019 06C5 3E                      DB       3EH         ; Skip "DEC B"
 1020 06C6 05           ECHDEL:    DEC      B           ; Count bytes in buffer
 1021 06C7 2B                      DEC      HL          ; Back space buffer
 1022 06C8 CADA06                  JP       Z,OTKLN     ; No buffer - Try again
 1023 06CB 7E                      LD       A,(HL)      ; Get deleted byte
 1024 06CC CD7707                  CALL     OUTC        ; Echo it
 1025 06CF C3EC06                  JP       MORINP      ; Get more input
 1026                   ;
 1027 06D2 05           DELCHR:    DEC      B           ; Count bytes in buffer
 1028 06D3 2B                      DEC      HL          ; Back space buffer
 1029 06D4 CD7707                  CALL     OUTC        ; Output character in A
 1030 06D7 C2EC06                  JP       NZ,MORINP   ; Not end - Get more
 1031 06DA CD7707       OTKLN:     CALL     OUTC        ; Output character in A
 1032 06DD CDAC0B       KILIN:     CALL     PRCRLF      ; Output CRLF
 1033 06E0 C3E306                  JP       TTYLIN      ; Get line again
 1034                   ;
 1035 06E3              GETLIN:
 1036 06E3 21A680       TTYLIN:    LD       HL,BUFFER   ; Get a line by charact
 1037 06E6 0601                    LD       B,1         ; Set buffer as empty
 1038 06E8 AF                      XOR      A
 1039 06E9 328980                  LD       (NULFLG),A  ; Clear null flag
 1040 06EC CDA107       MORINP:    CALL     CLOTST      ; Get character and tes
 1041 06EF 4F                      LD       C,A         ; Save character in C
 1042 06F0 FE7F                    CP       DEL         ; Delete character?
 1043 06F2 CAB206                  JP       Z,DODEL     ; Yes - Process it
 1044 06F5 3A8980                  LD       A,(NULFLG)  ; Get null flag
 1045 06F8 B7                      OR       A           ; Test null flag status
 1046 06F9 CA0507                  JP       Z,PROCES    ; Reset - Process chara
 1047 06FC 3E00                    LD       A,0         ; Set a null
 1048 06FE CD7707                  CALL     OUTC        ; Output null
 1049 0701 AF                      XOR      A           ; Clear A
 1050 0702 328980                  LD       (NULFLG),A  ; Reset null flag
 1051 0705 79           PROCES:    LD       A,C         ; Get character
 1052 0706 FE07                    CP       CTRLG       ; Bell?
 1053 0708 CA4907                  JP       Z,PUTCTL    ; Yes - Save it
 1054 070B FE03                    CP       CTRLC       ; Is it control "C"?
 1055 070D CCAC0B                  CALL     Z,PRCRLF    ; Yes - Output CRLF
 1056 0710 37                      SCF                  ; Flag break
 1057 0711 C8                      RET      Z           ; Return if control "C"
 1058 0712 FE0D                    CP       CR          ; Is it enter?
 1059 0714 CAA70B                  JP       Z,ENDINP    ; Yes - Terminate input
 1060 0717 FE15                    CP       CTRLU       ; Is it control "U"?
 1061 0719 CADD06                  JP       Z,KILIN     ; Yes - Get another lin
 1062 071C FE40                    CP       '@'         ; Is it "kill line"?
 1063 071E CADA06                  JP       Z,OTKLN     ; Yes - Kill line
 1064 0721 FE5F                    CP       '_'         ; Is it delete?
 1065 0723 CAD206                  JP       Z,DELCHR    ; Yes - Delete characte
 1066 0726 FE08                    CP       BKSP        ; Is it backspace?
 1067 0728 CAD206                  JP       Z,DELCHR    ; Yes - Delete characte
 1068 072B FE12                    CP       CTRLR       ; Is it control "R"?
 1069 072D C24407                  JP       NZ,PUTBUF   ; No - Put in buffer
 1070 0730 C5                      PUSH     BC          ; Save buffer length
 1071 0731 D5                      PUSH     DE          ; Save DE
 1072 0732 E5                      PUSH     HL          ; Save buffer address
 1073 0733 3600                    LD       (HL),0      ; Mark end of buffer
 1074 0735 CD691D                  CALL     OUTNCR      ; Output and do CRLF
 1075 0738 21A680                  LD       HL,BUFFER   ; Point to buffer start
 1076 073B CD4B12                  CALL     PRS         ; Output buffer
 1077 073E E1                      POP      HL          ; Restore buffer addres
 1078 073F D1                      POP      DE          ; Restore DE
 1079 0740 C1                      POP      BC          ; Restore buffer length
 1080 0741 C3EC06                  JP       MORINP      ; Get another character
 1081                   ;
 1082 0744 FE20         PUTBUF:    CP       ' '         ; Is it a control code?
 1083 0746 DAEC06                  JP       C,MORINP    ; Yes - Ignore
 1084 0749 78           PUTCTL:    LD       A,B         ; Get number of bytes i
 1085 074A FE49                    CP       72+1        ; Test for line overflo
 1086 074C 3E07                    LD       A,CTRLG     ; Set a bell
 1087 074E D25E07                  JP       NC,OUTNBS   ; Ring bell if buffer f
 1088 0751 79                      LD       A,C         ; Get character
 1089 0752 71                      LD       (HL),C      ; Save in buffer
 1090 0753 321181                  LD       (LSTBIN),A  ; Save last input byte
 1091 0756 23                      INC      HL          ; Move up buffer
 1092 0757 04                      INC      B           ; Increment length
 1093 0758 CD7707       OUTIT:     CALL     OUTC        ; Output the character 
 1094 075B C3EC06                  JP       MORINP      ; Get another character
 1095                   ;
 1096 075E CD7707       OUTNBS:    CALL     OUTC        ; Output bell and back 
 1097 0761 3E08                    LD       A,BKSP      ; Set back space
 1098 0763 C35807                  JP       OUTIT       ; Output it and get mor
 1099                   ;
 1100 0766 7C           CPDEHL:    LD       A,H         ; Get H
 1101 0767 92                      SUB      D           ; Compare with D
 1102 0768 C0                      RET      NZ          ; Different - Exit
 1103 0769 7D                      LD       A,L         ; Get L
 1104 076A 93                      SUB      E           ; Compare with E
 1105 076B C9                      RET                  ; Return status
 1106                   ;
 1107 076C 7E           CHKSYN:    LD       A,(HL)      ; Check syntax of chara
 1108 076D E3                      EX       (SP),HL     ; Address of test byte
 1109 076E BE                      CP       (HL)        ; Same as in code strin
 1110 076F 23                      INC      HL          ; Return address
 1111 0770 E3                      EX       (SP),HL     ; Put it back
 1112 0771 CAFA08                  JP       Z,GETCHR    ; Yes - Get next charac
 1113 0774 C39E04                  JP       SNERR       ; Different - ?SN Error
 1114                   ;
 1115 0777 F5           OUTC:      PUSH     AF          ; Save character
 1116 0778 3A8A80                  LD       A,(CTLOFG)  ; Get control "O" flag
 1117 077B B7                      OR       A           ; Is it set?
 1118 077C C28012                  JP       NZ,POPAF    ; Yes - don't output
 1119 077F F1                      POP      AF          ; Restore character
 1120 0780 C5                      PUSH     BC          ; Save buffer length
 1121 0781 F5                      PUSH     AF          ; Save character
 1122 0782 FE20                    CP       ' '         ; Is it a control code?
 1123 0784 DA9B07                  JP       C,DINPOS    ; Yes - Don't INC POS(X
 1124 0787 3A8780                  LD       A,(LWIDTH)  ; Get line width
 1125 078A 47                      LD       B,A         ; To B
 1126 078B 3AF080                  LD       A,(CURPOS)  ; Get cursor position
 1127 078E 04                      INC      B           ; Width 255?
 1128 078F CA9707                  JP       Z,INCLEN    ; Yes - No width limit
 1129 0792 05                      DEC      B           ; Restore width
 1130 0793 B8                      CP       B           ; At end of line?
 1131 0794 CCAC0B                  CALL     Z,PRCRLF    ; Yes - output CRLF
 1132 0797 3C           INCLEN:    INC      A           ; Move on one character
 1133 0798 32F080                  LD       (CURPOS),A  ; Save new position
 1134 079B F1           DINPOS:    POP      AF          ; Restore character
 1135 079C C1                      POP      BC          ; Restore buffer length
 1136 079D CDA700                  CALL     TXA         ; Send it
 1137 07A0 C9                      RET
 1138                   ;
 1139 07A1 CD7900       CLOTST:    CALL     RXA         ; Get input character
 1140 07A4 E67F                    AND      01111111B   ; Strip bit 7
 1141 07A6 FE0F                    CP       CTRLO       ; Is it control "O"?
 1142 07A8 C0                      RET      NZ          ; No don't flip flag
 1143 07A9 3A8A80                  LD       A,(CTLOFG)  ; Get flag
 1144 07AC 2F                      CPL                  ; Flip it
 1145 07AD 328A80                  LD       (CTLOFG),A  ; Put it back
 1146 07B0 AF                      XOR      A           ; Null character
 1147 07B1 C9                      RET
 1148                   ;
 1149 07B2 CDD009       LIST:      CALL     ATOH        ; ASCII number to DE
 1150 07B5 C0                      RET      NZ          ; Return if anything ex
 1151 07B6 C1                      POP      BC          ; Rubbish - Not needed
 1152 07B7 CD8A05                  CALL     SRCHLN      ; Search for line numbe
 1153 07BA C5                      PUSH     BC          ; Save address of line
 1154 07BB CD0808                  CALL     SETLIN      ; Set up lines counter
 1155 07BE E1           LISTLP:    POP      HL          ; Restore address of li
 1156 07BF 4E                      LD       C,(HL)      ; Get LSB of next line
 1157 07C0 23                      INC      HL
 1158 07C1 46                      LD       B,(HL)      ; Get MSB of next line
 1159 07C2 23                      INC      HL
 1160 07C3 78                      LD       A,B         ; BC = 0 (End of progra
 1161 07C4 B1                      OR       C
 1162 07C5 CAE904                  JP       Z,PRNTOK    ; Yes - Go to command m
 1163 07C8 CD1108                  CALL     COUNT       ; Count lines
 1164 07CB CD2509                  CALL     TSTBRK      ; Test for break key
 1165 07CE C5                      PUSH     BC          ; Save address of next 
 1166 07CF CDAC0B                  CALL     PRCRLF      ; Output CRLF
 1167 07D2 5E                      LD       E,(HL)      ; Get LSB of line numbe
 1168 07D3 23                      INC      HL
 1169 07D4 56                      LD       D,(HL)      ; Get MSB of line numbe
 1170 07D5 23                      INC      HL
 1171 07D6 E5                      PUSH     HL          ; Save address of line 
 1172 07D7 EB                      EX       DE,HL       ; Line number to HL
 1173 07D8 CDF018                  CALL     PRNTHL      ; Output line number in
 1174 07DB 3E20                    LD       A,' '       ; Space after line numb
 1175 07DD E1                      POP      HL          ; Restore start of line
 1176 07DE CD7707       LSTLP2:    CALL     OUTC        ; Output character in A
 1177 07E1 7E           LSTLP3:    LD       A,(HL)      ; Get next byte in line
 1178 07E2 B7                      OR       A           ; End of line?
 1179 07E3 23                      INC      HL          ; To next byte in line
 1180 07E4 CABE07                  JP       Z,LISTLP    ; Yes - get next line
 1181 07E7 F2DE07                  JP       P,LSTLP2    ; No token - output it
 1182 07EA D67F                    SUB      ZEND-1      ; Find and output word
 1183 07EC 4F                      LD       C,A         ; Token offset+1 to C
 1184 07ED 112702                  LD       DE,WORDS    ; Reserved word list
 1185 07F0 1A           FNDTOK:    LD       A,(DE)      ; Get character in list
 1186 07F1 13                      INC      DE          ; Move on to next
 1187 07F2 B7                      OR       A           ; Is it start of word?
 1188 07F3 F2F007                  JP       P,FNDTOK    ; No - Keep looking for
 1189 07F6 0D                      DEC      C           ; Count words
 1190 07F7 C2F007                  JP       NZ,FNDTOK   ; Not there - keep look
 1191 07FA E67F         OUTWRD:    AND      01111111B   ; Strip bit 7
 1192 07FC CD7707                  CALL     OUTC        ; Output first characte
 1193 07FF 1A                      LD       A,(DE)      ; Get next character
 1194 0800 13                      INC      DE          ; Move on to next
 1195 0801 B7                      OR       A           ; Is it end of word?
 1196 0802 F2FA07                  JP       P,OUTWRD    ; No - output the rest
 1197 0805 C3E107                  JP       LSTLP3      ; Next byte in line
 1198                   ;
 1199 0808 E5           SETLIN:    PUSH     HL          ; Set up LINES counter
 1200 0809 2A8D80                  LD       HL,(LINESN) ; Get LINES number
 1201 080C 228B80                  LD       (LINESC),HL ; Save in LINES counter
 1202 080F E1                      POP      HL
 1203 0810 C9                      RET
 1204                   ;
 1205 0811 E5           COUNT:     PUSH     HL          ; Save code string addr
 1206 0812 D5                      PUSH     DE
 1207 0813 2A8B80                  LD       HL,(LINESC) ; Get LINES counter
 1208 0816 11FFFF                  LD       DE,-1
 1209                   ;       ADC     HL,DE           ; Decrement
 1210 0819 7B                      LD       A,E         ;REPLACE Z80 CODE
 1211 081A 8D                      ADC      A,L         ;REPLACE Z80 CODE
 1212 081B 6F                      LD       L,A         ;REPLACE Z80 CODE
 1213 081C 7A                      LD       A,D         ;REPLACE Z80 CODE
 1214 081D 8C                      ADC      A,H         ;REPLACE Z80 CODE
 1215 081E 67                      LD       H,A         ;REPLACE Z80 CODE
 1216                   ;
 1217 081F 228B80                  LD       (LINESC),HL ; Put it back
 1218 0822 D1                      POP      DE
 1219 0823 E1                      POP      HL          ; Restore code string a
 1220 0824 F0                      RET      P           ; Return if more lines 
 1221 0825 E5                      PUSH     HL          ; Save code string addr
 1222 0826 2A8D80                  LD       HL,(LINESN) ; Get LINES number
 1223 0829 228B80                  LD       (LINESC),HL ; Reset LINES counter
 1224 082C CD7900                  CALL     RXA         ; Get input character
 1225 082F FE03                    CP       CTRLC       ; Is it control "C"?
 1226 0831 CA3808                  JP       Z,RSLNBK    ; Yes - Reset LINES and
 1227 0834 E1                      POP      HL          ; Restore code string a
 1228 0835 C31108                  JP       COUNT       ; Keep on counting
 1229                   ;
 1230 0838 2A8D80       RSLNBK:    LD       HL,(LINESN) ; Get LINES number
 1231 083B 228B80                  LD       (LINESC),HL ; Reset LINES counter
 1232 083E C36201                  JP       BRKRET      ; Go and output "Break"
 1233                   ;
 1234 0841 3E64         FOR:       LD       A,64H       ; Flag "FOR" assignment
 1235 0843 321081                  LD       (FORFLG),A  ; Save "FOR" flag
 1236 0846 CDB20A                  CALL     LET         ; Set up initial index
 1237 0849 C1                      POP      BC          ; Drop RETurn address
 1238 084A E5                      PUSH     HL          ; Save code string addr
 1239 084B CD9B0A                  CALL     DATA        ; Get next statement ad
 1240 084E 220C81                  LD       (LOOPST),HL ; Save it for start of 
 1241 0851 210200                  LD       HL,2        ; Offset for "FOR" bloc
 1242 0854 39                      ADD      HL,SP       ; Point to it
 1243 0855 CD4B04       FORSLP:    CALL     LOKFOR      ; Look for existing "FO
 1244 0858 D1                      POP      DE          ; Get code string addre
 1245 0859 C27108                  JP       NZ,FORFND   ; No nesting found
 1246 085C 09                      ADD      HL,BC       ; Move into "FOR" block
 1247 085D D5                      PUSH     DE          ; Save code string addr
 1248 085E 2B                      DEC      HL
 1249 085F 56                      LD       D,(HL)      ; Get MSB of loop state
 1250 0860 2B                      DEC      HL
 1251 0861 5E                      LD       E,(HL)      ; Get LSB of loop state
 1252 0862 23                      INC      HL
 1253 0863 23                      INC      HL
 1254 0864 E5                      PUSH     HL          ; Save block address
 1255 0865 2A0C81                  LD       HL,(LOOPST) ; Get address of loop s
 1256 0868 CD6607                  CALL     CPDEHL      ; Compare the FOR loops
 1257 086B E1                      POP      HL          ; Restore block address
 1258 086C C25508                  JP       NZ,FORSLP   ; Different FORs - Find
 1259 086F D1                      POP      DE          ; Restore code string a
 1260 0870 F9                      LD       SP,HL       ; Remove all nested loo
 1261                   ;
 1262 0871 EB           FORFND:    EX       DE,HL       ; Code string address t
 1263 0872 0E08                    LD       C,8
 1264 0874 CD7B04                  CALL     CHKSTK      ; Check for 8 levels of
 1265 0877 E5                      PUSH     HL          ; Save code string addr
 1266 0878 2A0C81                  LD       HL,(LOOPST) ; Get first statement o
 1267 087B E3                      EX       (SP),HL     ; Save and restore code
 1268 087C E5                      PUSH     HL          ; Re-save code string a
 1269 087D 2AA180                  LD       HL,(LINEAT) ; Get current line numb
 1270 0880 E3                      EX       (SP),HL     ; Save and restore code
 1271 0881 CD740D                  CALL     TSTNUM      ; Make sure it's a numb
 1272 0884 CD6C07                  CALL     CHKSYN      ; Make sure "TO" is nex
 1273 0887 A6                      DB       ZTO         ; "TO" token
 1274 0888 CD710D                  CALL     GETNUM      ; Get "TO" expression v
 1275 088B E5                      PUSH     HL          ; Save code string addr
 1276 088C CDA217                  CALL     BCDEFP      ; Move "TO" value to BC
 1277 088F E1                      POP      HL          ; Restore code string a
 1278 0890 C5                      PUSH     BC          ; Save "TO" value in bl
 1279 0891 D5                      PUSH     DE
 1280 0892 010081                  LD       BC,8100H    ; BCDE - 1 (default STE
 1281 0895 51                      LD       D,C         ; C=0
 1282 0896 5A                      LD       E,D         ; D=0
 1283 0897 7E                      LD       A,(HL)      ; Get next byte in code
 1284 0898 FEAB                    CP       ZSTEP       ; See if "STEP" is stat
 1285 089A 3E01                    LD       A,1         ; Sign of step = 1
 1286 089C C2AD08                  JP       NZ,SAVSTP   ; No STEP given - Defau
 1287 089F CDFA08                  CALL     GETCHR      ; Jump over "STEP" toke
 1288 08A2 CD710D                  CALL     GETNUM      ; Get step value
 1289 08A5 E5                      PUSH     HL          ; Save code string addr
 1290 08A6 CDA217                  CALL     BCDEFP      ; Move STEP to BCDE
 1291 08A9 CD5617                  CALL     TSTSGN      ; Test sign of FPREG
 1292 08AC E1                      POP      HL          ; Restore code string a
 1293 08AD C5           SAVSTP:    PUSH     BC          ; Save the STEP value i
 1294 08AE D5                      PUSH     DE
 1295 08AF F5                      PUSH     AF          ; Save sign of STEP
 1296 08B0 33                      INC      SP          ; Don't save flags
 1297 08B1 E5                      PUSH     HL          ; Save code string addr
 1298 08B2 2A1381                  LD       HL,(BRKLIN) ; Get address of index 
 1299 08B5 E3                      EX       (SP),HL     ; Save and restore code
 1300 08B6 0681         PUTFID:    LD       B,ZFOR      ; "FOR" block marker
 1301 08B8 C5                      PUSH     BC          ; Save it
 1302 08B9 33                      INC      SP          ; Don't save C
 1303                   ;
 1304 08BA CD2509       RUNCNT:    CALL     TSTBRK      ; Execution driver - Te
 1305 08BD 221381                  LD       (BRKLIN),HL ; Save code address for
 1306 08C0 7E                      LD       A,(HL)      ; Get next byte in code
 1307 08C1 FE3A                    CP       ':'         ; Multi statement line?
 1308 08C3 CADA08                  JP       Z,EXCUTE    ; Yes - Execute it
 1309 08C6 B7                      OR       A           ; End of line?
 1310 08C7 C29E04                  JP       NZ,SNERR    ; No - Syntax error
 1311 08CA 23                      INC      HL          ; Point to address of n
 1312 08CB 7E                      LD       A,(HL)      ; Get LSB of line point
 1313 08CC 23                      INC      HL
 1314 08CD B6                      OR       (HL)        ; Is it zero (End of pr
 1315 08CE CA5609                  JP       Z,ENDPRG    ; Yes - Terminate execu
 1316 08D1 23                      INC      HL          ; Point to line number
 1317 08D2 5E                      LD       E,(HL)      ; Get LSB of line numbe
 1318 08D3 23                      INC      HL
 1319 08D4 56                      LD       D,(HL)      ; Get MSB of line numbe
 1320 08D5 EB                      EX       DE,HL       ; Line number to HL
 1321 08D6 22A180                  LD       (LINEAT),HL ; Save as current line 
 1322 08D9 EB                      EX       DE,HL       ; Line number back to D
 1323 08DA CDFA08       EXCUTE:    CALL     GETCHR      ; Get key word
 1324 08DD 11BA08                  LD       DE,RUNCNT   ; Where to RETurn to
 1325 08E0 D5                      PUSH     DE          ; Save for RETurn
 1326 08E1 C8           IFJMP:     RET      Z           ; Go to RUNCNT if end o
 1327 08E2 D680         ONJMP:     SUB      ZEND        ; Is it a token?
 1328 08E4 DAB20A                  JP       C,LET       ; No - try to assign it
 1329 08E7 FE25                    CP       ZNEW+1-ZEND ; END to NEW ?
 1330 08E9 D29E04                  JP       NC,SNERR    ; Not a key word - ?SN 
 1331 08EC 07                      RLCA                 ; Double it
 1332 08ED 4F                      LD       C,A         ; BC = Offset into tabl
 1333 08EE 0600                    LD       B,0
 1334 08F0 EB                      EX       DE,HL       ; Save code string addr
 1335 08F1 214603                  LD       HL,WORDTB   ; Keyword address table
 1336 08F4 09                      ADD      HL,BC       ; Point to routine addr
 1337 08F5 4E                      LD       C,(HL)      ; Get LSB of routine ad
 1338 08F6 23                      INC      HL
 1339 08F7 46                      LD       B,(HL)      ; Get MSB of routine ad
 1340 08F8 C5                      PUSH     BC          ; Save routine address
 1341 08F9 EB                      EX       DE,HL       ; Restore code string a
 1342                   ;
 1343 08FA 23           GETCHR:    INC      HL          ; Point to next charact
 1344 08FB 7E                      LD       A,(HL)      ; Get next code string 
 1345 08FC FE3A                    CP       ':'         ; Z if ':'
 1346 08FE D0                      RET      NC          ; NC if > "9"
 1347 08FF FE20                    CP       ' '
 1348 0901 CAFA08                  JP       Z,GETCHR    ; Skip over spaces
 1349 0904 FE30                    CP       '0'
 1350 0906 3F                      CCF                  ; NC if < '0'
 1351 0907 3C                      INC      A           ; Test for zero - Leave
 1352 0908 3D                      DEC      A           ; Z if Null
 1353 0909 C9                      RET
 1354                   ;
 1355 090A EB           RESTOR:    EX       DE,HL       ; Save code string addr
 1356 090B 2AA380                  LD       HL,(BASTXT) ; Point to start of pro
 1357 090E CA1F09                  JP       Z,RESTNL    ; Just RESTORE - reset 
 1358 0911 EB                      EX       DE,HL       ; Restore code string a
 1359 0912 CDD009                  CALL     ATOH        ; Get line number to DE
 1360 0915 E5                      PUSH     HL          ; Save code string addr
 1361 0916 CD8A05                  CALL     SRCHLN      ; Search for line numbe
 1362 0919 60                      LD       H,B         ; HL = Address of line
 1363 091A 69                      LD       L,C
 1364 091B D1                      POP      DE          ; Restore code string a
 1365 091C D2710A                  JP       NC,ULERR    ; ?UL Error if not foun
 1366 091F 2B           RESTNL:    DEC      HL          ; Byte before DATA stat
 1367 0920 222181       UPDATA:    LD       (NXTDAT),HL ; Update DATA pointer
 1368 0923 EB                      EX       DE,HL       ; Restore code string a
 1369 0924 C9                      RET
 1370                   ;
 1371                   
 1372 0925 CDB300       TSTBRK:    CALL     CHKCHR      ; Check input status
 1373 0928 C8                      RET      Z           ; No key, go back
 1374 0929 CD7900                  CALL     RXA         ; Get the key into A
 1375 092C FE1B                    CP       ESC         ; Escape key?
 1376 092E CA4709                  JP       Z,BRK       ; Yes, break
 1377 0931 FE03                    CP       CTRLC       ; <Ctrl-C>
 1378 0933 CA4709                  JP       Z,BRK       ; Yes, break
 1379 0936 FE13                    CP       CTRLS       ; Stop scrolling?
 1380 0938 C0                      RET      NZ          ; Other key, ignore
 1381                   ;
 1382                   
 1383 0939 CD7900       STALL:     CALL     RXA         ; Wait for key
 1384 093C FE11                    CP       CTRLQ       ; Resume scrolling?
 1385 093E C8                      RET      Z           ; Release the chokehold
 1386 093F FE03                    CP       CTRLC       ; Second break?
 1387 0941 CA4C09                  JP       Z,STOP      ; Break during hold exi
 1388 0944 C33909                  JP       STALL       ; Loop until <Ctrl-Q> o
 1389                   ;
 1390 0947 3EFF         BRK        LD       A,0FFH      ; Set BRKFLG
 1391 0949 329280                  LD       (BRKFLG),A  ; Store it
 1392                   ;
 1393                   
 1394 094C C0           STOP:      RET      NZ          ; Exit if anything else
 1395 094D F6                      DB       0F6H        ; Flag "STOP"
 1396 094E C0           PEND:      RET      NZ          ; Exit if anything else
 1397 094F 221381                  LD       (BRKLIN),HL ; Save point of break
 1398 0952 21                      DB       21H         ; Skip "OR 11111111B"
 1399 0953 F6FF         INPBRK:    OR       11111111B   ; Flag "Break" wanted
 1400 0955 C1                      POP      BC          ; Return not needed and
 1401 0956 2AA180       ENDPRG:    LD       HL,(LINEAT) ; Get current line numb
 1402 0959 F5                      PUSH     AF          ; Save STOP / END statu
 1403 095A 7D                      LD       A,L         ; Is it direct break?
 1404 095B A4                      AND      H
 1405 095C 3C                      INC      A           ; Line is -1 if direct 
 1406 095D CA6909                  JP       Z,NOLIN     ; Yes - No line number
 1407 0960 221781                  LD       (ERRLIN),HL ; Save line of break
 1408 0963 2A1381                  LD       HL,(BRKLIN) ; Get point of break
 1409 0966 221981                  LD       (CONTAD),HL ; Save point to CONTinu
 1410 0969 AF           NOLIN:     XOR      A
 1411 096A 328A80                  LD       (CTLOFG),A  ; Enable output
 1412 096D CD9F0B                  CALL     STTLIN      ; Start a new line
 1413 0970 F1                      POP      AF          ; Restore STOP / END st
 1414 0971 214104                  LD       HL,BRKMSG   ; "Break" message
 1415 0974 C2D204                  JP       NZ,ERRIN    ; "in line" wanted?
 1416 0977 C3E904                  JP       PRNTOK      ; Go to command mode
 1417                   ;
 1418 097A 2A1981       CONT:      LD       HL,(CONTAD) ; Get CONTinue address
 1419 097D 7C                      LD       A,H         ; Is it zero?
 1420 097E B5                      OR       L
 1421 097F 1E20                    LD       E,CN        ; ?CN Error
 1422 0981 CAB204                  JP       Z,ERROR     ; Yes - output "?CN Err
 1423 0984 EB                      EX       DE,HL       ; Save code string addr
 1424 0985 2A1781                  LD       HL,(ERRLIN) ; Get line of last brea
 1425 0988 22A180                  LD       (LINEAT),HL ; Set up current line n
 1426 098B EB                      EX       DE,HL       ; Restore code string a
 1427 098C C9                      RET                  ; CONTinue where left o
 1428                   ;
 1429 098D CDD514       NULL:      CALL     GETINT      ; Get integer 0-255
 1430 0990 C0                      RET      NZ          ; Return if bad value
 1431 0991 328680                  LD       (NULLS),A   ; Set nulls number
 1432 0994 C9                      RET
 1433                   ;
 1434                   
 1435 0995 E5           ACCSUM:    PUSH     HL          ; Save address in array
 1436 0996 2A8F80                  LD       HL,(CHKSUM) ; Get check sum
 1437 0999 0600                    LD       B,0         ; BC - Value of byte
 1438 099B 4F                      LD       C,A
 1439 099C 09                      ADD      HL,BC       ; Add byte to check sum
 1440 099D 228F80                  LD       (CHKSUM),HL ; Re-save check sum
 1441 09A0 E1                      POP      HL          ; Restore address in ar
 1442 09A1 C9                      RET
 1443                   ;
 1444 09A2 7E           CHKLTR:    LD       A,(HL)      ; Get byte
 1445 09A3 FE41                    CP       'A'         ; < 'a' ?
 1446 09A5 D8                      RET      C           ; Carry set if not lett
 1447 09A6 FE5B                    CP       'Z'+1       ; > 'z' ?
 1448 09A8 3F                      CCF
 1449 09A9 C9                      RET                  ; Carry set if not lett
 1450                   ;
 1451 09AA CDFA08       FPSINT:    CALL     GETCHR      ; Get next character
 1452 09AD CD710D       POSINT:    CALL     GETNUM      ; Get integer 0 to 3276
 1453 09B0 CD5617       DEPINT:    CALL     TSTSGN      ; Test sign of FPREG
 1454 09B3 FACB09                  JP       M,FCERR     ; Negative - ?FC Error
 1455 09B6 3A2C81       DEINT:     LD       A,(FPEXP)   ; Get integer value to 
 1456 09B9 FE90                    CP       80H+16      ; Exponent in range (16
 1457 09BB DAFE17                  JP       C,FPINT     ; Yes - convert it
 1458 09BE 018090                  LD       BC,9080H    ; BCDE = -32768
 1459 09C1 110000                  LD       DE,0000
 1460 09C4 E5                      PUSH     HL          ; Save code string addr
 1461 09C5 CDD117                  CALL     CMPNUM      ; Compare FPREG with BC
 1462 09C8 E1                      POP      HL          ; Restore code string a
 1463 09C9 51                      LD       D,C         ; MSB to D
 1464 09CA C8                      RET      Z           ; Return if in range
 1465 09CB 1E08         FCERR:     LD       E,FC        ; ?FC Error
 1466 09CD C3B204                  JP       ERROR       ; Output error-
 1467                   ;
 1468 09D0 2B           ATOH:      DEC      HL          ; ASCII number to DE bi
 1469 09D1 110000       GETLN:     LD       DE,0        ; Get number to DE
 1470 09D4 CDFA08       GTLNLP:    CALL     GETCHR      ; Get next character
 1471 09D7 D0                      RET      NC          ; Exit if not a digit
 1472 09D8 E5                      PUSH     HL          ; Save code string addr
 1473 09D9 F5                      PUSH     AF          ; Save digit
 1474 09DA 219819                  LD       HL,65529/10 ; Largest number 65529
 1475 09DD CD6607                  CALL     CPDEHL      ; Number in range?
 1476 09E0 DA9E04                  JP       C,SNERR     ; No - ?SN Error
 1477 09E3 62                      LD       H,D         ; HL = Number
 1478 09E4 6B                      LD       L,E
 1479 09E5 19                      ADD      HL,DE       ; Times 2
 1480 09E6 29                      ADD      HL,HL       ; Times 4
 1481 09E7 19                      ADD      HL,DE       ; Times 5
 1482 09E8 29                      ADD      HL,HL       ; Times 10
 1483 09E9 F1                      POP      AF          ; Restore digit
 1484 09EA D630                    SUB      '0'         ; Make it 0 to 9
 1485 09EC 5F                      LD       E,A         ; DE = Value of digit
 1486 09ED 1600                    LD       D,0
 1487 09EF 19                      ADD      HL,DE       ; Add to number
 1488 09F0 EB                      EX       DE,HL       ; Number to DE
 1489 09F1 E1                      POP      HL          ; Restore code string a
 1490 09F2 C3D409                  JP       GTLNLP      ; Go to next character
 1491                   ;
 1492 09F5 CABA05       CLEAR:     JP       Z,INTVAR    ; Just "CLEAR" Keep par
 1493 09F8 CDAD09                  CALL     POSINT      ; Get integer 0 to 3276
 1494 09FB 2B                      DEC      HL          ; Cancel increment
 1495 09FC CDFA08                  CALL     GETCHR      ; Get next character
 1496 09FF E5                      PUSH     HL          ; Save code string addr
 1497 0A00 2AF480                  LD       HL,(LSTRAM) ; Get end of RAM
 1498 0A03 CA180A                  JP       Z,STORED    ; No value given - Use 
 1499 0A06 E1                      POP      HL          ; Restore code string a
 1500 0A07 CD6C07                  CALL     CHKSYN      ; Check for comma
 1501 0A0A 2C                      DB       ','
 1502 0A0B D5                      PUSH     DE          ; Save number
 1503 0A0C CDAD09                  CALL     POSINT      ; Get integer 0 to 3276
 1504 0A0F 2B                      DEC      HL          ; Cancel increment
 1505 0A10 CDFA08                  CALL     GETCHR      ; Get next character
 1506 0A13 C29E04                  JP       NZ,SNERR    ; ?SN Error if more on 
 1507 0A16 E3                      EX       (SP),HL     ; Save code string addr
 1508 0A17 EB                      EX       DE,HL       ; Number to DE
 1509 0A18 7D           STORED:    LD       A,L         ; Get LSB of new RAM to
 1510 0A19 93                      SUB      E           ; Subtract LSB of strin
 1511 0A1A 5F                      LD       E,A         ; Save LSB
 1512 0A1B 7C                      LD       A,H         ; Get MSB of new RAM to
 1513 0A1C 9A                      SBC      A,D         ; Subtract MSB of strin
 1514 0A1D 57                      LD       D,A         ; Save MSB
 1515 0A1E DA9304                  JP       C,OMERR     ; ?OM Error if not enou
 1516 0A21 E5                      PUSH     HL          ; Save RAM top
 1517 0A22 2A1B81                  LD       HL,(PROGND) ; Get program end
 1518 0A25 012800                  LD       BC,40       ; 40 Bytes minimum work
 1519 0A28 09                      ADD      HL,BC       ; Get lowest address
 1520 0A29 CD6607                  CALL     CPDEHL      ; Enough memory?
 1521 0A2C D29304                  JP       NC,OMERR    ; No - ?OM Error
 1522 0A2F EB                      EX       DE,HL       ; RAM top to HL
 1523 0A30 229F80                  LD       (STRSPC),HL ; Set new string space
 1524 0A33 E1                      POP      HL          ; End of memory to use
 1525 0A34 22F480                  LD       (LSTRAM),HL ; Set new top of RAM
 1526 0A37 E1                      POP      HL          ; Restore code string a
 1527 0A38 C3BA05                  JP       INTVAR      ; Initialise variables
 1528                   ;
 1529 0A3B CAB605       RUN:       JP       Z,RUNFST    ; RUN from start if jus
 1530 0A3E CDBA05                  CALL     INTVAR      ; Initialise variables
 1531 0A41 01BA08                  LD       BC,RUNCNT   ; Execution driver loop
 1532 0A44 C3570A                  JP       RUNLIN      ; RUN from line number
 1533                   ;
 1534 0A47 0E03         GOSUB:     LD       C,3         ; 3 Levels of stack nee
 1535 0A49 CD7B04                  CALL     CHKSTK      ; Check for 3 levels of
 1536 0A4C C1                      POP      BC          ; Get return address
 1537 0A4D E5                      PUSH     HL          ; Save code string for 
 1538 0A4E E5                      PUSH     HL          ; And for GOSUB routine
 1539 0A4F 2AA180                  LD       HL,(LINEAT) ; Get current line
 1540 0A52 E3                      EX       (SP),HL     ; Into stack - Code str
 1541 0A53 3E8C                    LD       A,ZGOSUB    ; "GOSUB" token
 1542 0A55 F5                      PUSH     AF          ; Save token
 1543 0A56 33                      INC      SP          ; Don't save flags
 1544                   ;
 1545 0A57 C5           RUNLIN:    PUSH     BC          ; Save return address
 1546 0A58 CDD009       GOTO:      CALL     ATOH        ; ASCII number to DE bi
 1547 0A5B CD9D0A                  CALL     REM         ; Get end of line
 1548 0A5E E5                      PUSH     HL          ; Save end of line
 1549 0A5F 2AA180                  LD       HL,(LINEAT) ; Get current line
 1550 0A62 CD6607                  CALL     CPDEHL      ; Line after current?
 1551 0A65 E1                      POP      HL          ; Restore end of line
 1552 0A66 23                      INC      HL          ; Start of next line
 1553 0A67 DC8D05                  CALL     C,SRCHLP    ; Line is after current
 1554 0A6A D48A05                  CALL     NC,SRCHLN   ; Line is before curren
 1555 0A6D 60                      LD       H,B         ; Set up code string ad
 1556 0A6E 69                      LD       L,C
 1557 0A6F 2B                      DEC      HL          ; Incremented after
 1558 0A70 D8                      RET      C           ; Line found
 1559 0A71 1E0E         ULERR:     LD       E,UL        ; ?UL Error
 1560 0A73 C3B204                  JP       ERROR       ; Output error message
 1561                   ;
 1562 0A76 C0           RETURN:    RET      NZ          ; Return if not just RE
 1563 0A77 16FF                    LD       D,-1        ; Flag "GOSUB" search
 1564 0A79 CD4704                  CALL     BAKSTK      ; Look "GOSUB" block
 1565 0A7C F9                      LD       SP,HL       ; Kill all FORs in subr
 1566 0A7D FE8C                    CP       ZGOSUB      ; Test for "GOSUB" toke
 1567 0A7F 1E04                    LD       E,RG        ; ?RG Error
 1568 0A81 C2B204                  JP       NZ,ERROR    ; Error if no "GOSUB" f
 1569 0A84 E1                      POP      HL          ; Get RETURN line numbe
 1570 0A85 22A180                  LD       (LINEAT),HL ; Save as current
 1571 0A88 23                      INC      HL          ; Was it from direct st
 1572 0A89 7C                      LD       A,H
 1573 0A8A B5                      OR       L           ; Return to line
 1574 0A8B C2950A                  JP       NZ,RETLIN   ; No - Return to line
 1575 0A8E 3A1181                  LD       A,(LSTBIN)  ; Any INPUT in subrouti
 1576 0A91 B7                      OR       A           ; If so buffer is corru
 1577 0A92 C2E804                  JP       NZ,POPNOK   ; Yes - Go to command m
 1578 0A95 21BA08       RETLIN:    LD       HL,RUNCNT   ; Execution driver loop
 1579 0A98 E3                      EX       (SP),HL     ; Into stack - Code str
 1580 0A99 3E                      DB       3EH         ; Skip "POP HL"
 1581 0A9A E1           NXTDTA:    POP      HL          ; Restore code string a
 1582                   ;
 1583 0A9B 013A         DATA:      DB       01H,3AH     ; ':' End of statement
 1584 0A9D 0E00         REM:       LD       C,0         ; 00    End of statemen
 1585 0A9F 0600                    LD       B,0
 1586 0AA1 79           NXTSTL:    LD       A,C         ; Statement and byte
 1587 0AA2 48                      LD       C,B
 1588 0AA3 47                      LD       B,A         ; Statement end byte
 1589 0AA4 7E           NXTSTT:    LD       A,(HL)      ; Get byte
 1590 0AA5 B7                      OR       A           ; End of line?
 1591 0AA6 C8                      RET      Z           ; Yes - Exit
 1592 0AA7 B8                      CP       B           ; End of statement?
 1593 0AA8 C8                      RET      Z           ; Yes - Exit
 1594 0AA9 23                      INC      HL          ; Next byte
 1595 0AAA FE22                    CP       '"'         ; Literal string?
 1596 0AAC CAA10A                  JP       Z,NXTSTL    ; Yes - Look for anothe
 1597 0AAF C3A40A                  JP       NXTSTT      ; Keep looking
 1598                   ;
 1599 0AB2 CD680F       LET:       CALL     GETVAR      ; Get variable name
 1600 0AB5 CD6C07                  CALL     CHKSYN      ; Make sure "=" follows
 1601 0AB8 B4                      DB       ZEQUAL      ; "=" token
 1602 0AB9 D5                      PUSH     DE          ; Save address of varia
 1603 0ABA 3AF280                  LD       A,(TYPE)    ; Get data type
 1604 0ABD F5                      PUSH     AF          ; Save type
 1605 0ABE CD830D                  CALL     EVAL        ; Evaluate expression
 1606 0AC1 F1                      POP      AF          ; Restore type
 1607 0AC2 E3                      EX       (SP),HL     ; Save code - Get var a
 1608 0AC3 221381                  LD       (BRKLIN),HL ; Save address of varia
 1609 0AC6 1F                      RRA                  ; Adjust type
 1610 0AC7 CD760D                  CALL     CHKTYP      ; Check types are the s
 1611 0ACA CA050B                  JP       Z,LETNUM    ; Numeric - Move value
 1612 0ACD E5           LETSTR:    PUSH     HL          ; Save address of strin
 1613 0ACE 2A2981                  LD       HL,(FPREG)  ; Pointer to string ent
 1614 0AD1 E5                      PUSH     HL          ; Save it on stack
 1615 0AD2 23                      INC      HL          ; Skip over length
 1616 0AD3 23                      INC      HL
 1617 0AD4 5E                      LD       E,(HL)      ; LSB of string address
 1618 0AD5 23                      INC      HL
 1619 0AD6 56                      LD       D,(HL)      ; MSB of string address
 1620 0AD7 2AA380                  LD       HL,(BASTXT) ; Point to start of pro
 1621 0ADA CD6607                  CALL     CPDEHL      ; Is string before prog
 1622 0ADD D2F40A                  JP       NC,CRESTR   ; Yes - Create string e
 1623 0AE0 2A9F80                  LD       HL,(STRSPC) ; Point to string space
 1624 0AE3 CD6607                  CALL     CPDEHL      ; Is string literal in 
 1625 0AE6 D1                      POP      DE          ; Restore address of st
 1626 0AE7 D2FC0A                  JP       NC,MVSTPT   ; Yes - Set up pointer
 1627 0AEA 210481                  LD       HL,TMPSTR   ; Temporary string pool
 1628 0AED CD6607                  CALL     CPDEHL      ; Is string in temporar
 1629 0AF0 D2FC0A                  JP       NC,MVSTPT   ; No - Set up pointer
 1630 0AF3 3E                      DB       3EH         ; Skip "POP DE"
 1631 0AF4 D1           CRESTR:    POP      DE          ; Restore address of st
 1632 0AF5 CDAC13                  CALL     BAKTMP      ; Back to last tmp-str 
 1633 0AF8 EB                      EX       DE,HL       ; Address of string ent
 1634 0AF9 CDE511                  CALL     SAVSTR      ; Save string in string
 1635 0AFC CDAC13       MVSTPT:    CALL     BAKTMP      ; Back to last tmp-str 
 1636 0AFF E1                      POP      HL          ; Get string pointer
 1637 0B00 CDB117                  CALL     DETHL4      ; Move string pointer t
 1638 0B03 E1                      POP      HL          ; Restore code string a
 1639 0B04 C9                      RET
 1640                   ;
 1641 0B05 E5           LETNUM:    PUSH     HL          ; Save address of varia
 1642 0B06 CDAE17                  CALL     FPTHL       ; Move value to variabl
 1643 0B09 D1                      POP      DE          ; Restore address of va
 1644 0B0A E1                      POP      HL          ; Restore code string a
 1645 0B0B C9                      RET
 1646                   ;
 1647 0B0C CDD514       ON:        CALL     GETINT      ; Get integer 0-255
 1648 0B0F 7E                      LD       A,(HL)      ; Get "GOTO" or "GOSUB"
 1649 0B10 47                      LD       B,A         ; Save in B
 1650 0B11 FE8C                    CP       ZGOSUB      ; "GOSUB" token?
 1651 0B13 CA1B0B                  JP       Z,ONGO      ; Yes - Find line numbe
 1652 0B16 CD6C07                  CALL     CHKSYN      ; Make sure it's "GOTO"
 1653 0B19 88                      DB       ZGOTO       ; "GOTO" token
 1654 0B1A 2B                      DEC      HL          ; Cancel increment
 1655 0B1B 4B           ONGO:      LD       C,E         ; Integer of branch val
 1656 0B1C 0D           ONGOLP:    DEC      C           ; Count branches
 1657 0B1D 78                      LD       A,B         ; Get "GOTO" or "GOSUB"
 1658 0B1E CAE208                  JP       Z,ONJMP     ; Go to that line if ri
 1659 0B21 CDD109                  CALL     GETLN       ; Get line number to DE
 1660 0B24 FE2C                    CP       ','         ; Another line number?
 1661 0B26 C0                      RET      NZ          ; No - Drop through
 1662 0B27 C31C0B                  JP       ONGOLP      ; Yes - loop
 1663                   ;
 1664 0B2A CD830D       IF:        CALL     EVAL        ; Evaluate expression
 1665 0B2D 7E                      LD       A,(HL)      ; Get token
 1666 0B2E FE88                    CP       ZGOTO       ; "GOTO" token?
 1667 0B30 CA380B                  JP       Z,IFGO      ; Yes - Get line
 1668 0B33 CD6C07                  CALL     CHKSYN      ; Make sure it's "THEN"
 1669 0B36 A9                      DB       ZTHEN       ; "THEN" token
 1670 0B37 2B                      DEC      HL          ; Cancel increment
 1671 0B38 CD740D       IFGO:      CALL     TSTNUM      ; Make sure it's numeri
 1672 0B3B CD5617                  CALL     TSTSGN      ; Test state of express
 1673 0B3E CA9D0A                  JP       Z,REM       ; False - Drop through
 1674 0B41 CDFA08                  CALL     GETCHR      ; Get next character
 1675 0B44 DA580A                  JP       C,GOTO      ; Number - GOTO that li
 1676 0B47 C3E108                  JP       IFJMP       ; Otherwise do statemen
 1677                   ;
 1678 0B4A 2B           MRPRNT:    DEC      HL          ; DEC 'cos GETCHR INCs
 1679 0B4B CDFA08                  CALL     GETCHR      ; Get next character
 1680 0B4E CAAC0B       PRINT:     JP       Z,PRCRLF    ; CRLF if just PRINT
 1681 0B51 C8           PRNTLP:    RET      Z           ; End of list - Exit
 1682 0B52 FEA5                    CP       ZTAB        ; "TAB(" token?
 1683 0B54 CADF0B                  JP       Z,DOTAB     ; Yes - Do TAB routine
 1684 0B57 FEA8                    CP       ZSPC        ; "SPC(" token?
 1685 0B59 CADF0B                  JP       Z,DOTAB     ; Yes - Do SPC routine
 1686 0B5C E5                      PUSH     HL          ; Save code string addr
 1687 0B5D FE2C                    CP       ','         ; Comma?
 1688 0B5F CAC80B                  JP       Z,DOCOM     ; Yes - Move to next zo
 1689 0B62 FE3B                    CP       59          ;";"          ; Semi-co
 1690 0B64 CA020C                  JP       Z,NEXITM    ; Do semi-colon routine
 1691 0B67 C1                      POP      BC          ; Code string address t
 1692 0B68 CD830D                  CALL     EVAL        ; Evaluate expression
 1693 0B6B E5                      PUSH     HL          ; Save code string addr
 1694 0B6C 3AF280                  LD       A,(TYPE)    ; Get variable type
 1695 0B6F B7                      OR       A           ; Is it a string variab
 1696 0B70 C2980B                  JP       NZ,PRNTST   ; Yes - Output string c
 1697 0B73 CDFB18                  CALL     NUMASC      ; Convert number to tex
 1698 0B76 CD0912                  CALL     CRTST       ; Create temporary stri
 1699 0B79 3620                    LD       (HL),' '    ; Followed by a space
 1700 0B7B 2A2981                  LD       HL,(FPREG)  ; Get length of output
 1701 0B7E 34                      INC      (HL)        ; Plus 1 for the space
 1702 0B7F 2A2981                  LD       HL,(FPREG)  ; < Not needed >
 1703 0B82 3A8780                  LD       A,(LWIDTH)  ; Get width of line
 1704 0B85 47                      LD       B,A         ; To B
 1705 0B86 04                      INC      B           ; Width 255 (No limit)?
 1706 0B87 CA940B                  JP       Z,PRNTNB    ; Yes - Output number s
 1707 0B8A 04                      INC      B           ; Adjust it
 1708 0B8B 3AF080                  LD       A,(CURPOS)  ; Get cursor position
 1709 0B8E 86                      ADD      A,(HL)      ; Add length of string
 1710 0B8F 3D                      DEC      A           ; Adjust it
 1711 0B90 B8                      CP       B           ; Will output fit on th
 1712 0B91 D4AC0B                  CALL     NC,PRCRLF   ; No - CRLF first
 1713 0B94 CD4E12       PRNTNB:    CALL     PRS1        ; Output string at (HL)
 1714 0B97 AF                      XOR      A           ; Skip CALL by setting 
 1715 0B98 C44E12       PRNTST:    CALL     NZ,PRS1     ; Output string at (HL)
 1716 0B9B E1                      POP      HL          ; Restore code string a
 1717 0B9C C34A0B                  JP       MRPRNT      ; See if more to PRINT
 1718                   ;
 1719 0B9F 3AF080       STTLIN:    LD       A,(CURPOS)  ; Make sure on new line
 1720 0BA2 B7                      OR       A           ; Already at start?
 1721 0BA3 C8                      RET      Z           ; Yes - Do nothing
 1722 0BA4 C3AC0B                  JP       PRCRLF      ; Start a new line
 1723                   ;
 1724 0BA7 3600         ENDINP:    LD       (HL),0      ; Mark end of buffer
 1725 0BA9 21A580                  LD       HL,BUFFER-1 ; Point to buffer
 1726 0BAC 3E0D         PRCRLF:    LD       A,CR        ; Load a CR
 1727 0BAE CD7707                  CALL     OUTC        ; Output character
 1728 0BB1 3E0A                    LD       A,LF        ; Load a LF
 1729 0BB3 CD7707                  CALL     OUTC        ; Output character
 1730 0BB6 AF           DONULL:    XOR      A           ; Set to position 0
 1731 0BB7 32F080                  LD       (CURPOS),A  ; Store it
 1732 0BBA 3A8680                  LD       A,(NULLS)   ; Get number of nulls
 1733 0BBD 3D           NULLP:     DEC      A           ; Count them
 1734 0BBE C8                      RET      Z           ; Return if done
 1735 0BBF F5                      PUSH     AF          ; Save count
 1736 0BC0 AF                      XOR      A           ; Load a null
 1737 0BC1 CD7707                  CALL     OUTC        ; Output it
 1738 0BC4 F1                      POP      AF          ; Restore count
 1739 0BC5 C3BD0B                  JP       NULLP       ; Keep counting
 1740                   ;
 1741 0BC8 3A8880       DOCOM:     LD       A,(COMMAN)  ; Get comma width
 1742 0BCB 47                      LD       B,A         ; Save in B
 1743 0BCC 3AF080                  LD       A,(CURPOS)  ; Get current position
 1744 0BCF B8                      CP       B           ; Within the limit?
 1745 0BD0 D4AC0B                  CALL     NC,PRCRLF   ; No - output CRLF
 1746 0BD3 D2020C                  JP       NC,NEXITM   ; Get next item
 1747 0BD6 D60E         ZONELP:    SUB      14          ; Next zone of 14 chara
 1748 0BD8 D2D60B                  JP       NC,ZONELP   ; Repeat if more zones
 1749 0BDB 2F                      CPL                  ; Number of spaces to o
 1750 0BDC C3F70B                  JP       ASPCS       ; Output them
 1751                   ;
 1752 0BDF F5           DOTAB:     PUSH     AF          ; Save token
 1753 0BE0 CDD214                  CALL     FNDNUM      ; Evaluate expression
 1754 0BE3 CD6C07                  CALL     CHKSYN      ; Make sure ")" follows
 1755 0BE6 29                      DB       ")"
 1756 0BE7 2B                      DEC      HL          ; Back space on to ")"
 1757 0BE8 F1                      POP      AF          ; Restore token
 1758 0BE9 D6A8                    SUB      ZSPC        ; Was it "SPC(" ?
 1759 0BEB E5                      PUSH     HL          ; Save code string addr
 1760 0BEC CAF20B                  JP       Z,DOSPC     ; Yes - Do 'E' spaces
 1761 0BEF 3AF080                  LD       A,(CURPOS)  ; Get current position
 1762 0BF2 2F           DOSPC:     CPL                  ; Number of spaces to p
 1763 0BF3 83                      ADD      A,E         ; Total number to print
 1764 0BF4 D2020C                  JP       NC,NEXITM   ; TAB < Current POS(X)
 1765 0BF7 3C           ASPCS:     INC      A           ; Output A spaces
 1766 0BF8 47                      LD       B,A         ; Save number to print
 1767 0BF9 3E20                    LD       A,' '       ; Space
 1768 0BFB CD7707       SPCLP:     CALL     OUTC        ; Output character in A
 1769 0BFE 05                      DEC      B           ; Count them
 1770 0BFF C2FB0B                  JP       NZ,SPCLP    ; Repeat if more
 1771 0C02 E1           NEXITM:    POP      HL          ; Restore code string a
 1772 0C03 CDFA08                  CALL     GETCHR      ; Get next character
 1773 0C06 C3510B                  JP       PRNTLP      ; More to print
 1774                   ;
 1775 0C09 3F5265646F20 REDO:      DB       "?Redo from start",CR,LF,0
           66726F6D2073 
           746172740D0A 
           00           
 1776                   ;
 1777 0C1C 3A1281       BADINP:    LD       A,(READFG)  ; READ or INPUT?
 1778 0C1F B7                      OR       A
 1779 0C20 C29804                  JP       NZ,DATSNR   ; READ - ?SN Error
 1780 0C23 C1                      POP      BC          ; Throw away code strin
 1781 0C24 21090C                  LD       HL,REDO     ; "Redo from start" mes
 1782 0C27 CD4B12                  CALL     PRS         ; Output string
 1783 0C2A C3E905                  JP       DOAGN       ; Do last INPUT again
 1784                   ;
 1785 0C2D CDB611       INPUT:     CALL     IDTEST      ; Test for illegal dire
 1786 0C30 7E                      LD       A,(HL)      ; Get character after "
 1787 0C31 FE22                    CP       '"'         ; Is there a prompt str
 1788 0C33 3E00                    LD       A,0         ; Clear A and leave fla
 1789 0C35 328A80                  LD       (CTLOFG),A  ; Enable output
 1790 0C38 C2470C                  JP       NZ,NOPMPT   ; No prompt - get input
 1791 0C3B CD0A12                  CALL     QTSTR       ; Get string terminated
 1792 0C3E CD6C07                  CALL     CHKSYN      ; Check for ';' after p
 1793 0C41 3B                      DB       ';'
 1794 0C42 E5                      PUSH     HL          ; Save code string addr
 1795 0C43 CD4E12                  CALL     PRS1        ; Output prompt string
 1796 0C46 3E                      DB       3EH         ; Skip "PUSH HL"
 1797 0C47 E5           NOPMPT:    PUSH     HL          ; Save code string addr
 1798 0C48 CDED05                  CALL     PROMPT      ; Get input with "? " p
 1799 0C4B C1                      POP      BC          ; Restore code string a
 1800 0C4C DA5309                  JP       C,INPBRK    ; Break pressed - Exit
 1801 0C4F 23                      INC      HL          ; Next byte
 1802 0C50 7E                      LD       A,(HL)      ; Get it
 1803 0C51 B7                      OR       A           ; End of line?
 1804 0C52 2B                      DEC      HL          ; Back again
 1805 0C53 C5                      PUSH     BC          ; Re-save code string a
 1806 0C54 CA9A0A                  JP       Z,NXTDTA    ; Yes - Find next DATA 
 1807 0C57 362C                    LD       (HL),','    ; Store comma as separa
 1808 0C59 C3610C                  JP       NXTITM      ; Get next item
 1809                   ;
 1810 0C5C E5           READ:      PUSH     HL          ; Save code string addr
 1811 0C5D 2A2181                  LD       HL,(NXTDAT) ; Next DATA statement
 1812 0C60 F6                      DB       0F6H        ; Flag "READ"
 1813 0C61 AF           NXTITM:    XOR      A           ; Flag "INPUT"
 1814 0C62 321281                  LD       (READFG),A  ; Save "READ"/"INPUT" f
 1815 0C65 E3                      EX       (SP),HL     ; Get code str' , Save 
 1816 0C66 C36D0C                  JP       GTVLUS      ; Get values
 1817                   ;
 1818 0C69 CD6C07       NEDMOR:    CALL     CHKSYN      ; Check for comma betwe
 1819 0C6C 2C                      DB       ','
 1820 0C6D CD680F       GTVLUS:    CALL     GETVAR      ; Get variable name
 1821 0C70 E3                      EX       (SP),HL     ; Save code str" , Get 
 1822 0C71 D5                      PUSH     DE          ; Save variable address
 1823 0C72 7E                      LD       A,(HL)      ; Get next "INPUT"/"DAT
 1824 0C73 FE2C                    CP       ','         ; Comma?
 1825 0C75 CA950C                  JP       Z,ANTVLU    ; Yes - Get another val
 1826 0C78 3A1281                  LD       A,(READFG)  ; Is it READ?
 1827 0C7B B7                      OR       A
 1828 0C7C C2020D                  JP       NZ,FDTLP    ; Yes - Find next DATA 
 1829 0C7F 3E3F                    LD       A,'?'       ; More INPUT needed
 1830 0C81 CD7707                  CALL     OUTC        ; Output character
 1831 0C84 CDED05                  CALL     PROMPT      ; Get INPUT with prompt
 1832 0C87 D1                      POP      DE          ; Variable address
 1833 0C88 C1                      POP      BC          ; Code string address
 1834 0C89 DA5309                  JP       C,INPBRK    ; Break pressed
 1835 0C8C 23                      INC      HL          ; Point to next DATA by
 1836 0C8D 7E                      LD       A,(HL)      ; Get byte
 1837 0C8E B7                      OR       A           ; Is it zero (No input)
 1838 0C8F 2B                      DEC      HL          ; Back space INPUT poin
 1839 0C90 C5                      PUSH     BC          ; Save code string addr
 1840 0C91 CA9A0A                  JP       Z,NXTDTA    ; Find end of buffer
 1841 0C94 D5                      PUSH     DE          ; Save variable address
 1842 0C95 3AF280       ANTVLU:    LD       A,(TYPE)    ; Check data type
 1843 0C98 B7                      OR       A           ; Is it numeric?
 1844 0C99 CABF0C                  JP       Z,INPBIN    ; Yes - Convert to bina
 1845 0C9C CDFA08                  CALL     GETCHR      ; Get next character
 1846 0C9F 57                      LD       D,A         ; Save input character
 1847 0CA0 47                      LD       B,A         ; Again
 1848 0CA1 FE22                    CP       '"'         ; Start of literal stin
 1849 0CA3 CAB30C                  JP       Z,STRENT    ; Yes - Create string e
 1850 0CA6 3A1281                  LD       A,(READFG)  ; "READ" or "INPUT" ?
 1851 0CA9 B7                      OR       A
 1852 0CAA 57                      LD       D,A         ; Save 00 if "INPUT"
 1853 0CAB CAB00C                  JP       Z,ITMSEP    ; "INPUT" - End with 00
 1854 0CAE 163A                    LD       D,':'       ; "DATA" - End with 00 
 1855 0CB0 062C         ITMSEP:    LD       B,','       ; Item separator
 1856 0CB2 2B                      DEC      HL          ; Back space for DTSTR
 1857 0CB3 CD0D12       STRENT:    CALL     DTSTR       ; Get string terminated
 1858 0CB6 EB                      EX       DE,HL       ; String address to DE
 1859 0CB7 21CA0C                  LD       HL,LTSTND   ; Where to go after LET
 1860 0CBA E3                      EX       (SP),HL     ; Save HL , get input p
 1861 0CBB D5                      PUSH     DE          ; Save address of strin
 1862 0CBC C3CD0A                  JP       LETSTR      ; Assign string to vari
 1863                   ;
 1864 0CBF CDFA08       INPBIN:    CALL     GETCHR      ; Get next character
 1865 0CC2 CD5D18                  CALL     ASCTFP      ; Convert ASCII to FP n
 1866 0CC5 E3                      EX       (SP),HL     ; Save input ptr, Get v
 1867 0CC6 CDAE17                  CALL     FPTHL       ; Move FPREG to variabl
 1868 0CC9 E1                      POP      HL          ; Restore input pointer
 1869 0CCA 2B           LTSTND:    DEC      HL          ; DEC 'cos GETCHR INCs
 1870 0CCB CDFA08                  CALL     GETCHR      ; Get next character
 1871 0CCE CAD60C                  JP       Z,MORDT     ; End of line - More ne
 1872 0CD1 FE2C                    CP       ','         ; Another value?
 1873 0CD3 C21C0C                  JP       NZ,BADINP   ; No - Bad input
 1874 0CD6 E3           MORDT:     EX       (SP),HL     ; Get code string addre
 1875 0CD7 2B                      DEC      HL          ; DEC 'cos GETCHR INCs
 1876 0CD8 CDFA08                  CALL     GETCHR      ; Get next character
 1877 0CDB C2690C                  JP       NZ,NEDMOR   ; More needed - Get it
 1878 0CDE D1                      POP      DE          ; Restore DATA pointer
 1879 0CDF 3A1281                  LD       A,(READFG)  ; "READ" or "INPUT" ?
 1880 0CE2 B7                      OR       A
 1881 0CE3 EB                      EX       DE,HL       ; DATA pointer to HL
 1882 0CE4 C22009                  JP       NZ,UPDATA   ; Update DATA pointer i
 1883 0CE7 D5                      PUSH     DE          ; Save code string addr
 1884 0CE8 B6                      OR       (HL)        ; More input given?
 1885 0CE9 21F10C                  LD       HL,EXTIG    ; "?Extra ignored" mess
 1886 0CEC C44B12                  CALL     NZ,PRS      ; Output string if extr
 1887 0CEF E1                      POP      HL          ; Restore code string a
 1888 0CF0 C9                      RET
 1889                   ;
 1890 0CF1 3F4578747261 EXTIG:     DB       "?Extra ignored",CR,LF,0
           2069676E6F72 
           65640D0A00   
 1891                   ;
 1892 0D02 CD9B0A       FDTLP:     CALL     DATA        ; Get next statement
 1893 0D05 B7                      OR       A           ; End of line?
 1894 0D06 C21B0D                  JP       NZ,FANDT    ; No - See if DATA stat
 1895 0D09 23                      INC      HL
 1896 0D0A 7E                      LD       A,(HL)      ; End of program?
 1897 0D0B 23                      INC      HL
 1898 0D0C B6                      OR       (HL)        ; 00 00 Ends program
 1899 0D0D 1E06                    LD       E,OD        ; ?OD Error
 1900 0D0F CAB204                  JP       Z,ERROR     ; Yes - Out of DATA
 1901 0D12 23                      INC      HL
 1902 0D13 5E                      LD       E,(HL)      ; LSB of line number
 1903 0D14 23                      INC      HL
 1904 0D15 56                      LD       D,(HL)      ; MSB of line number
 1905 0D16 EB                      EX       DE,HL
 1906 0D17 220E81                  LD       (DATLIN),HL ; Set line of current D
 1907 0D1A EB                      EX       DE,HL
 1908 0D1B CDFA08       FANDT:     CALL     GETCHR      ; Get next character
 1909 0D1E FE83                    CP       ZDATA       ; "DATA" token
 1910 0D20 C2020D                  JP       NZ,FDTLP    ; No "DATA" - Keep look
 1911 0D23 C3950C                  JP       ANTVLU      ; Found - Convert input
 1912                   ;
 1913 0D26 110000       NEXT:      LD       DE,0        ; In case no index give
 1914 0D29 C4680F       NEXT1:     CALL     NZ,GETVAR   ; Get index address
 1915 0D2C 221381                  LD       (BRKLIN),HL ; Save code string addr
 1916 0D2F CD4704                  CALL     BAKSTK      ; Look for "FOR" block
 1917 0D32 C2A404                  JP       NZ,NFERR    ; No "FOR" - ?NF Error
 1918 0D35 F9                      LD       SP,HL       ; Clear nested loops
 1919 0D36 D5                      PUSH     DE          ; Save index address
 1920 0D37 7E                      LD       A,(HL)      ; Get sign of STEP
 1921 0D38 23                      INC      HL
 1922 0D39 F5                      PUSH     AF          ; Save sign of STEP
 1923 0D3A D5                      PUSH     DE          ; Save index address
 1924 0D3B CD9417                  CALL     PHLTFP      ; Move index value to F
 1925 0D3E E3                      EX       (SP),HL     ; Save address of TO va
 1926 0D3F E5                      PUSH     HL          ; Save address of index
 1927 0D40 CD0115                  CALL     ADDPHL      ; Add STEP to index val
 1928 0D43 E1                      POP      HL          ; Restore address of in
 1929 0D44 CDAE17                  CALL     FPTHL       ; Move value to index v
 1930 0D47 E1                      POP      HL          ; Restore address of TO
 1931 0D48 CDA517                  CALL     LOADFP      ; Move TO value to BCDE
 1932 0D4B E5                      PUSH     HL          ; Save address of line 
 1933 0D4C CDD117                  CALL     CMPNUM      ; Compare index with TO
 1934 0D4F E1                      POP      HL          ; Restore address of li
 1935 0D50 C1                      POP      BC          ; Address of sign of ST
 1936 0D51 90                      SUB      B           ; Compare with expected
 1937 0D52 CDA517                  CALL     LOADFP      ; BC = Loop stmt,DE = L
 1938 0D55 CA610D                  JP       Z,KILFOR    ; Loop finished - Termi
 1939 0D58 EB                      EX       DE,HL       ; Loop statement line n
 1940 0D59 22A180                  LD       (LINEAT),HL ; Set loop line number
 1941 0D5C 69                      LD       L,C         ; Set code string to lo
 1942 0D5D 60                      LD       H,B
 1943 0D5E C3B608                  JP       PUTFID      ; Put back "FOR" and co
 1944                   ;
 1945 0D61 F9           KILFOR:    LD       SP,HL       ; Remove "FOR" block
 1946 0D62 2A1381                  LD       HL,(BRKLIN) ; Code string after "NE
 1947 0D65 7E                      LD       A,(HL)      ; Get next byte in code
 1948 0D66 FE2C                    CP       ','         ; More NEXTs ?
 1949 0D68 C2BA08                  JP       NZ,RUNCNT   ; No - Do next statemen
 1950 0D6B CDFA08                  CALL     GETCHR      ; Position to index nam
 1951 0D6E CD290D                  CALL     NEXT1       ; Re-enter NEXT routine
 1952                   ; < will not RETurn to here , Exit to RUNCNT or Loop >
 1953                   ;
 1954 0D71 CD830D       GETNUM:    CALL     EVAL        ; Get a numeric express
 1955 0D74 F6           TSTNUM:    DB       0F6H        ; Clear carry (numeric)
 1956 0D75 37           TSTSTR:    SCF                  ; Set carry (string)
 1957 0D76 3AF280       CHKTYP:    LD       A,(TYPE)    ; Check types match
 1958 0D79 8F                      ADC      A,A         ; Expected + actual
 1959 0D7A B7                      OR       A           ; Clear carry , set par
 1960 0D7B E8                      RET      PE          ; Even parity - Types m
 1961 0D7C C3B004                  JP       TMERR       ; Different types - Err
 1962                   ;
 1963 0D7F CD6C07       OPNPAR:    CALL     CHKSYN      ; Make sure "(" follows
 1964 0D82 28                      DB       "("
 1965 0D83 2B           EVAL:      DEC      HL          ; Evaluate expression &
 1966 0D84 1600                    LD       D,0         ; Precedence value
 1967 0D86 D5           EVAL1:     PUSH     DE          ; Save precedence
 1968 0D87 0E01                    LD       C,1
 1969 0D89 CD7B04                  CALL     CHKSTK      ; Check for 1 level of 
 1970 0D8C CDFA0D                  CALL     OPRND       ; Get next expression v
 1971 0D8F 221581       EVAL2:     LD       (NXTOPR),HL ; Save address of next 
 1972 0D92 2A1581       EVAL3:     LD       HL,(NXTOPR) ; Restore address of ne
 1973 0D95 C1                      POP      BC          ; Precedence value and 
 1974 0D96 78                      LD       A,B         ; Get precedence value
 1975 0D97 FE78                    CP       78H         ; "AND" or "OR" ?
 1976 0D99 D4740D                  CALL     NC,TSTNUM   ; No - Make sure it's a
 1977 0D9C 7E                      LD       A,(HL)      ; Get next operator / f
 1978 0D9D 1600                    LD       D,0         ; Clear Last relation
 1979 0D9F D6B3         RLTLP:     SUB      ZGTR        ; ">" Token
 1980 0DA1 DABB0D                  JP       C,FOPRND    ; + - * / ^ AND OR - Te
 1981 0DA4 FE03                    CP       ZLTH+1-ZGTR ; < = >
 1982 0DA6 D2BB0D                  JP       NC,FOPRND   ; Function - Call it
 1983 0DA9 FE01                    CP       ZEQUAL-ZGTR ; "="
 1984 0DAB 17                      RLA                  ; <- Test for legal
 1985 0DAC AA                      XOR      D           ; <- combinations of < 
 1986 0DAD BA                      CP       D           ; <- by combining last 
 1987 0DAE 57                      LD       D,A         ; <- with current one
 1988 0DAF DA9E04                  JP       C,SNERR     ; Error if "<<' '==" or
 1989 0DB2 220A81                  LD       (CUROPR),HL ; Save address of curre
 1990 0DB5 CDFA08                  CALL     GETCHR      ; Get next character
 1991 0DB8 C39F0D                  JP       RLTLP       ; Treat the two as one
 1992                   ;
 1993 0DBB 7A           FOPRND:    LD       A,D         ; < = > found ?
 1994 0DBC B7                      OR       A
 1995 0DBD C2E30E                  JP       NZ,TSTRED   ; Yes - Test for reduct
 1996 0DC0 7E                      LD       A,(HL)      ; Get operator token
 1997 0DC1 220A81                  LD       (CUROPR),HL ; Save operator address
 1998 0DC4 D6AC                    SUB      ZPLUS       ; Operator or function?
 1999 0DC6 D8                      RET      C           ; Neither - Exit
 2000 0DC7 FE07                    CP       ZOR+1-ZPLUS ; Is it + - * / ^ AND O
 2001 0DC9 D0                      RET      NC          ; No - Exit
 2002 0DCA 5F                      LD       E,A         ; Coded operator
 2003 0DCB 3AF280                  LD       A,(TYPE)    ; Get data type
 2004 0DCE 3D                      DEC      A           ; FF = numeric , 00 = s
 2005 0DCF B3                      OR       E           ; Combine with coded op
 2006 0DD0 7B                      LD       A,E         ; Get coded operator
 2007 0DD1 CA4113                  JP       Z,CONCAT    ; String concatenation
 2008 0DD4 07                      RLCA                 ; Times 2
 2009 0DD5 83                      ADD      A,E         ; Times 3
 2010 0DD6 5F                      LD       E,A         ; To DE (D is 0)
 2011 0DD7 219003                  LD       HL,PRITAB   ; Precedence table
 2012 0DDA 19                      ADD      HL,DE       ; To the operator conce
 2013 0DDB 78                      LD       A,B         ; Last operator precede
 2014 0DDC 56                      LD       D,(HL)      ; Get evaluation preced
 2015 0DDD BA                      CP       D           ; Compare with eval pre
 2016 0DDE D0                      RET      NC          ; Exit if higher preced
 2017 0DDF 23                      INC      HL          ; Point to routine addr
 2018 0DE0 CD740D                  CALL     TSTNUM      ; Make sure it's a numb
 2019                   ;
 2020 0DE3 C5           STKTHS:    PUSH     BC          ; Save last precedence 
 2021 0DE4 01920D                  LD       BC,EVAL3    ; Where to go on prec' 
 2022 0DE7 C5                      PUSH     BC          ; Save on stack for ret
 2023 0DE8 43                      LD       B,E         ; Save operator
 2024 0DE9 4A                      LD       C,D         ; Save precedence
 2025 0DEA CD8717                  CALL     STAKFP      ; Move value to stack
 2026 0DED 58                      LD       E,B         ; Restore operator
 2027 0DEE 51                      LD       D,C         ; Restore precedence
 2028 0DEF 4E                      LD       C,(HL)      ; Get LSB of routine ad
 2029 0DF0 23                      INC      HL
 2030 0DF1 46                      LD       B,(HL)      ; Get MSB of routine ad
 2031 0DF2 23                      INC      HL
 2032 0DF3 C5                      PUSH     BC          ; Save routine address
 2033 0DF4 2A0A81                  LD       HL,(CUROPR) ; Address of current op
 2034 0DF7 C3860D                  JP       EVAL1       ; Loop until prec' brea
 2035                   ;
 2036 0DFA AF           OPRND:     XOR      A           ; Get operand routine
 2037 0DFB 32F280                  LD       (TYPE),A    ; Set numeric expected
 2038 0DFE CDFA08                  CALL     GETCHR      ; Get next character
 2039 0E01 1E24                    LD       E,MO        ; ?MO Error
 2040 0E03 CAB204                  JP       Z,ERROR     ; No operand - Error
 2041 0E06 DA5D18                  JP       C,ASCTFP    ; Number - Get value
 2042 0E09 CDA209                  CALL     CHKLTR      ; See if a letter
 2043 0E0C D2620E                  JP       NC,CONVAR   ; Letter - Find variabl
 2044 0E0F FE26                    CP       '&'         ; &H = HEX, &B = BINARY
 2045 0E11 C2260E                  JP       NZ, NOTAMP
 2046 0E14 CDFA08                  CALL     GETCHR      ; Get next character
 2047 0E17 FE48                    CP       'H'         ; Hex number indicated?
 2048 0E19 CAA71C                  JP       Z,HEXTFP    ; Convert Hex to FPREG
 2049 0E1C FE42                    CP       'B'         ; Binary number indicat
 2050 0E1E CA231D                  JP       Z,BINTFP    ; Convert Bin to FPREG
 2051 0E21 1E02                    LD       E,SN        ; If neither then a ?SN
 2052 0E23 CAB204                  JP       Z,ERROR
 2053 0E26 FEAC         NOTAMP:    CP       ZPLUS       ; '+' Token ?
 2054 0E28 CAFA0D                  JP       Z,OPRND     ; Yes - Look for operan
 2055 0E2B FE2E                    CP       '.'         ; '.' ?
 2056 0E2D CA5D18                  JP       Z,ASCTFP    ; Yes - Create FP numbe
 2057 0E30 FEAD                    CP       ZMINUS      ; '-' Token ?
 2058 0E32 CA510E                  JP       Z,MINUS     ; Yes - Do minus
 2059 0E35 FE22                    CP       '"'         ; Literal string ?
 2060 0E37 CA0A12                  JP       Z,QTSTR     ; Get string terminated
 2061 0E3A FEAA                    CP       ZNOT        ; "NOT" Token ?
 2062 0E3C CA430F                  JP       Z,EVNOT     ; Yes - Eval NOT expres
 2063 0E3F FEA7                    CP       ZFN         ; "FN" Token ?
 2064 0E41 CA6E11                  JP       Z,DOFN      ; Yes - Do FN routine
 2065 0E44 D6B6                    SUB      ZSGN        ; Is it a function?
 2066 0E46 D2730E                  JP       NC,FNOFST   ; Yes - Evaluate functi
 2067 0E49 CD7F0D       EVLPAR:    CALL     OPNPAR      ; Evaluate expression i
 2068 0E4C CD6C07                  CALL     CHKSYN      ; Make sure ")" follows
 2069 0E4F 29                      DB       ")"
 2070 0E50 C9                      RET
 2071                   ;
 2072 0E51 167D         MINUS:     LD       D,7DH       ; '-' precedence
 2073 0E53 CD860D                  CALL     EVAL1       ; Evaluate until prec' 
 2074 0E56 2A1581                  LD       HL,(NXTOPR) ; Get next operator add
 2075 0E59 E5                      PUSH     HL          ; Save next operator ad
 2076 0E5A CD7F17                  CALL     INVSGN      ; Negate value
 2077 0E5D CD740D       RETNUM:    CALL     TSTNUM      ; Make sure it's a numb
 2078 0E60 E1                      POP      HL          ; Restore next operator
 2079 0E61 C9                      RET
 2080                   ;
 2081 0E62 CD680F       CONVAR:    CALL     GETVAR      ; Get variable address 
 2082 0E65 E5           FRMEVL:    PUSH     HL          ; Save code string addr
 2083 0E66 EB                      EX       DE,HL       ; Variable address to H
 2084 0E67 222981                  LD       (FPREG),HL  ; Save address of varia
 2085 0E6A 3AF280                  LD       A,(TYPE)    ; Get type
 2086 0E6D B7                      OR       A           ; Numeric?
 2087 0E6E CC9417                  CALL     Z,PHLTFP    ; Yes - Move contents t
 2088 0E71 E1                      POP      HL          ; Restore code string a
 2089 0E72 C9                      RET
 2090                   ;
 2091 0E73 0600         FNOFST:    LD       B,0         ; Get address of functi
 2092 0E75 07                      RLCA                 ; Double function offse
 2093 0E76 4F                      LD       C,A         ; BC = Offset in functi
 2094 0E77 C5                      PUSH     BC          ; Save adjusted token v
 2095 0E78 CDFA08                  CALL     GETCHR      ; Get next character
 2096 0E7B 79                      LD       A,C         ; Get adjusted token va
 2097 0E7C FE31                    CP       2*(ZLEFT-ZSGN)-1 ; Adj' LEFT$,RIGHT
 2098 0E7E DA9A0E                  JP       C,FNVAL     ; No - Do function
 2099 0E81 CD7F0D                  CALL     OPNPAR      ; Evaluate expression  
 2100 0E84 CD6C07                  CALL     CHKSYN      ; Make sure ',' follows
 2101 0E87 2C                      DB       ','
 2102 0E88 CD750D                  CALL     TSTSTR      ; Make sure it's a stri
 2103 0E8B EB                      EX       DE,HL       ; Save code string addr
 2104 0E8C 2A2981                  LD       HL,(FPREG)  ; Get address of string
 2105 0E8F E3                      EX       (SP),HL     ; Save address of strin
 2106 0E90 E5                      PUSH     HL          ; Save adjusted token v
 2107 0E91 EB                      EX       DE,HL       ; Restore code string a
 2108 0E92 CDD514                  CALL     GETINT      ; Get integer 0-255
 2109 0E95 EB                      EX       DE,HL       ; Save code string addr
 2110 0E96 E3                      EX       (SP),HL     ; Save integer,HL = adj
 2111 0E97 C3A20E                  JP       GOFUNC      ; Jump to string functi
 2112                   ;
 2113 0E9A CD490E       FNVAL:     CALL     EVLPAR      ; Evaluate expression
 2114 0E9D E3                      EX       (SP),HL     ; HL = Adjusted token v
 2115 0E9E 115D0E                  LD       DE,RETNUM   ; Return number from fu
 2116 0EA1 D5                      PUSH     DE          ; Save on stack
 2117 0EA2 01EF01       GOFUNC:    LD       BC,FNCTAB   ; Function routine addr
 2118 0EA5 09                      ADD      HL,BC       ; Point to right addres
 2119 0EA6 4E                      LD       C,(HL)      ; Get LSB of address
 2120 0EA7 23                      INC      HL          ;
 2121 0EA8 66                      LD       H,(HL)      ; Get MSB of address
 2122 0EA9 69                      LD       L,C         ; Address to HL
 2123 0EAA E9                      JP       (HL)        ; Jump to function
 2124                   ;
 2125 0EAB 15           SGNEXP:    DEC      D           ; Dee to flag negative 
 2126 0EAC FEAD                    CP       ZMINUS      ; '-' token ?
 2127 0EAE C8                      RET      Z           ; Yes - Return
 2128 0EAF FE2D                    CP       '-'         ; '-' ASCII ?
 2129 0EB1 C8                      RET      Z           ; Yes - Return
 2130 0EB2 14                      INC      D           ; Inc to flag positive 
 2131 0EB3 FE2B                    CP       '+'         ; '+' ASCII ?
 2132 0EB5 C8                      RET      Z           ; Yes - Return
 2133 0EB6 FEAC                    CP       ZPLUS       ; '+' token ?
 2134 0EB8 C8                      RET      Z           ; Yes - Return
 2135 0EB9 2B                      DEC      HL          ; DEC 'cos GETCHR INCs
 2136 0EBA C9                      RET                  ; Return "NZ"
 2137                   ;
 2138 0EBB F6           POR:       DB       0F6H        ; Flag "OR"
 2139 0EBC AF           PAND:      XOR      A           ; Flag "AND"
 2140 0EBD F5                      PUSH     AF          ; Save "AND" / "OR" fla
 2141 0EBE CD740D                  CALL     TSTNUM      ; Make sure it's a numb
 2142 0EC1 CDB609                  CALL     DEINT       ; Get integer -32768 to
 2143 0EC4 F1                      POP      AF          ; Restore "AND" / "OR" 
 2144 0EC5 EB                      EX       DE,HL       ; <- Get last
 2145 0EC6 C1                      POP      BC          ; <- value
 2146 0EC7 E3                      EX       (SP),HL     ; <- from
 2147 0EC8 EB                      EX       DE,HL       ; <- stack
 2148 0EC9 CD9717                  CALL     FPBCDE      ; Move last value to FP
 2149 0ECC F5                      PUSH     AF          ; Save "AND" / "OR" fla
 2150 0ECD CDB609                  CALL     DEINT       ; Get integer -32768 to
 2151 0ED0 F1                      POP      AF          ; Restore "AND" / "OR" 
 2152 0ED1 C1                      POP      BC          ; Get value
 2153 0ED2 79                      LD       A,C         ; Get LSB
 2154 0ED3 212C11                  LD       HL,ACPASS   ; Address of save AC as
 2155 0ED6 C2DE0E                  JP       NZ,POR1     ; Jump if OR
 2156 0ED9 A3                      AND      E           ; "AND" LSBs
 2157 0EDA 4F                      LD       C,A         ; Save LSB
 2158 0EDB 78                      LD       A,B         ; Get MBS
 2159 0EDC A2                      AND      D           ; "AND" MSBs
 2160 0EDD E9                      JP       (HL)        ; Save AC as current (A
 2161                   ;
 2162 0EDE B3           POR1:      OR       E           ; "OR" LSBs
 2163 0EDF 4F                      LD       C,A         ; Save LSB
 2164 0EE0 78                      LD       A,B         ; Get MSB
 2165 0EE1 B2                      OR       D           ; "OR" MSBs
 2166 0EE2 E9                      JP       (HL)        ; Save AC as current (A
 2167                   ;
 2168 0EE3 21F50E       TSTRED:    LD       HL,CMPLOG   ; Logical compare routi
 2169 0EE6 3AF280                  LD       A,(TYPE)    ; Get data type
 2170 0EE9 1F                      RRA                  ; Carry set = string
 2171 0EEA 7A                      LD       A,D         ; Get last precedence v
 2172 0EEB 17                      RLA                  ; Times 2 plus carry
 2173 0EEC 5F                      LD       E,A         ; To E
 2174 0EED 1664                    LD       D,64H       ; Relational precedence
 2175 0EEF 78                      LD       A,B         ; Get current precedenc
 2176 0EF0 BA                      CP       D           ; Compare with last
 2177 0EF1 D0                      RET      NC          ; Eval if last was rel'
 2178 0EF2 C3E30D                  JP       STKTHS      ; Stack this one and ge
 2179                   ;
 2180 0EF5 F70E         CMPLOG:    DW       CMPLG1      ; Compare two values / 
 2181 0EF7 79           CMPLG1:    LD       A,C         ; Get data type
 2182 0EF8 B7                      OR       A
 2183 0EF9 1F                      RRA
 2184 0EFA C1                      POP      BC          ; Get last expression t
 2185 0EFB D1                      POP      DE
 2186 0EFC F5                      PUSH     AF          ; Save status
 2187 0EFD CD760D                  CALL     CHKTYP      ; Check that types matc
 2188 0F00 21390F                  LD       HL,CMPRES   ; Result to comparison
 2189 0F03 E5                      PUSH     HL          ; Save for RETurn
 2190 0F04 CAD117                  JP       Z,CMPNUM    ; Compare values if num
 2191 0F07 AF                      XOR      A           ; Compare two strings
 2192 0F08 32F280                  LD       (TYPE),A    ; Set type to numeric
 2193 0F0B D5                      PUSH     DE          ; Save string name
 2194 0F0C CD8E13                  CALL     GSTRCU      ; Get current string
 2195 0F0F 7E                      LD       A,(HL)      ; Get length of string
 2196 0F10 23                      INC      HL
 2197 0F11 23                      INC      HL
 2198 0F12 4E                      LD       C,(HL)      ; Get LSB of address
 2199 0F13 23                      INC      HL
 2200 0F14 46                      LD       B,(HL)      ; Get MSB of address
 2201 0F15 D1                      POP      DE          ; Restore string name
 2202 0F16 C5                      PUSH     BC          ; Save address of strin
 2203 0F17 F5                      PUSH     AF          ; Save length of string
 2204 0F18 CD9213                  CALL     GSTRDE      ; Get second string
 2205 0F1B CDA517                  CALL     LOADFP      ; Get address of second
 2206 0F1E F1                      POP      AF          ; Restore length of str
 2207 0F1F 57                      LD       D,A         ; Length to D
 2208 0F20 E1                      POP      HL          ; Restore address of st
 2209 0F21 7B           CMPSTR:    LD       A,E         ; Bytes of string 2 to 
 2210 0F22 B2                      OR       D           ; Bytes of string 1 to 
 2211 0F23 C8                      RET      Z           ; Exit if all bytes com
 2212 0F24 7A                      LD       A,D         ; Get bytes of string 1
 2213 0F25 D601                    SUB      1
 2214 0F27 D8                      RET      C           ; Exit if end of string
 2215 0F28 AF                      XOR      A
 2216 0F29 BB                      CP       E           ; Bytes of string 2 to 
 2217 0F2A 3C                      INC      A
 2218 0F2B D0                      RET      NC          ; Exit if end of string
 2219 0F2C 15                      DEC      D           ; Count bytes in string
 2220 0F2D 1D                      DEC      E           ; Count bytes in string
 2221 0F2E 0A                      LD       A,(BC)      ; Byte in string 2
 2222 0F2F BE                      CP       (HL)        ; Compare to byte in st
 2223 0F30 23                      INC      HL          ; Move up string 1
 2224 0F31 03                      INC      BC          ; Move up string 2
 2225 0F32 CA210F                  JP       Z,CMPSTR    ; Same - Try next bytes
 2226 0F35 3F                      CCF                  ; Flag difference (">" 
 2227 0F36 C36117                  JP       FLGDIF      ; "<" gives -1 , ">" gi
 2228                   ;
 2229 0F39 3C           CMPRES:    INC      A           ; Increment current val
 2230 0F3A 8F                      ADC      A,A         ; Double plus carry
 2231 0F3B C1                      POP      BC          ; Get other value
 2232 0F3C A0                      AND      B           ; Combine them
 2233 0F3D C6FF                    ADD      A,-1        ; Carry set if differen
 2234 0F3F 9F                      SBC      A,A         ; 00 - Equal , FF - Dif
 2235 0F40 C36817                  JP       FLGREL      ; Set current value & c
 2236                   ;
 2237 0F43 165A         EVNOT:     LD       D,5AH       ; Precedence value for 
 2238 0F45 CD860D                  CALL     EVAL1       ; Eval until precedence
 2239 0F48 CD740D                  CALL     TSTNUM      ; Make sure it's a numb
 2240 0F4B CDB609                  CALL     DEINT       ; Get integer -32768 - 
 2241 0F4E 7B                      LD       A,E         ; Get LSB
 2242 0F4F 2F                      CPL                  ; Invert LSB
 2243 0F50 4F                      LD       C,A         ; Save "NOT" of LSB
 2244 0F51 7A                      LD       A,D         ; Get MSB
 2245 0F52 2F                      CPL                  ; Invert MSB
 2246 0F53 CD2C11                  CALL     ACPASS      ; Save AC as current
 2247 0F56 C1                      POP      BC          ; Clean up stack
 2248 0F57 C3920D                  JP       EVAL3       ; Continue evaluation
 2249                   ;
 2250 0F5A 2B           DIMRET:    DEC      HL          ; DEC 'cos GETCHR INCs
 2251 0F5B CDFA08                  CALL     GETCHR      ; Get next character
 2252 0F5E C8                      RET      Z           ; End of DIM statement
 2253 0F5F CD6C07                  CALL     CHKSYN      ; Make sure ',' follows
 2254 0F62 2C                      DB       ','
 2255 0F63 015A0F       DIM:       LD       BC,DIMRET   ; Return to "DIMRET"
 2256 0F66 C5                      PUSH     BC          ; Save on stack
 2257 0F67 F6                      DB       0F6H        ; Flag "Create" variabl
 2258 0F68 AF           GETVAR:    XOR      A           ; Find variable address
 2259 0F69 32F180                  LD       (LCRFLG),A  ; Set locate / create f
 2260 0F6C 46                      LD       B,(HL)      ; Get First byte of nam
 2261 0F6D CDA209       GTFNAM:    CALL     CHKLTR      ; See if a letter
 2262 0F70 DA9E04                  JP       C,SNERR     ; ?SN Error if not a le
 2263 0F73 AF                      XOR      A
 2264 0F74 4F                      LD       C,A         ; Clear second byte of 
 2265 0F75 32F280                  LD       (TYPE),A    ; Set type to numeric
 2266 0F78 CDFA08                  CALL     GETCHR      ; Get next character
 2267 0F7B DA840F                  JP       C,SVNAM2    ; Numeric - Save in nam
 2268 0F7E CDA209                  CALL     CHKLTR      ; See if a letter
 2269 0F81 DA910F                  JP       C,CHARTY    ; Not a letter - Check 
 2270 0F84 4F           SVNAM2:    LD       C,A         ; Save second byte of n
 2271 0F85 CDFA08       ENDNAM:    CALL     GETCHR      ; Get next character
 2272 0F88 DA850F                  JP       C,ENDNAM    ; Numeric - Get another
 2273 0F8B CDA209                  CALL     CHKLTR      ; See if a letter
 2274 0F8E D2850F                  JP       NC,ENDNAM   ; Letter - Get another
 2275 0F91 D624         CHARTY:    SUB      '$'         ; String variable?
 2276 0F93 C2A00F                  JP       NZ,NOTSTR   ; No - Numeric variable
 2277 0F96 3C                      INC      A           ; A = 1 (string type)
 2278 0F97 32F280                  LD       (TYPE),A    ; Set type to string
 2279 0F9A 0F                      RRCA                 ; A = 80H , Flag for st
 2280 0F9B 81                      ADD      A,C         ; 2nd byte of name has 
 2281 0F9C 4F                      LD       C,A         ; Resave second byte on
 2282 0F9D CDFA08                  CALL     GETCHR      ; Get next character
 2283 0FA0 3A1081       NOTSTR:    LD       A,(FORFLG)  ; Array name needed ?
 2284 0FA3 3D                      DEC      A
 2285 0FA4 CA4D10                  JP       Z,ARLDSV    ; Yes - Get array name
 2286 0FA7 F2B00F                  JP       P,NSCFOR    ; No array with "FOR" o
 2287 0FAA 7E                      LD       A,(HL)      ; Get byte again
 2288 0FAB D628                    SUB      '('         ; Subscripted variable?
 2289 0FAD CA2510                  JP       Z,SBSCPT    ; Yes - Sort out subscr
 2290                   ;
 2291 0FB0 AF           NSCFOR:    XOR      A           ; Simple variable
 2292 0FB1 321081                  LD       (FORFLG),A  ; Clear "FOR" flag
 2293 0FB4 E5                      PUSH     HL          ; Save code string addr
 2294 0FB5 50                      LD       D,B         ; DE = Variable name to
 2295 0FB6 59                      LD       E,C
 2296 0FB7 2A2381                  LD       HL,(FNRGNM) ; FN argument name
 2297 0FBA CD6607                  CALL     CPDEHL      ; Is it the FN argument
 2298 0FBD 112581                  LD       DE,FNARG    ; Point to argument val
 2299 0FC0 CA9716                  JP       Z,POPHRT    ; Yes - Return FN argum
 2300 0FC3 2A1D81                  LD       HL,(VAREND) ; End of variables
 2301 0FC6 EB                      EX       DE,HL       ; Address of end of sea
 2302 0FC7 2A1B81                  LD       HL,(PROGND) ; Start of variables ad
 2303 0FCA CD6607       FNDVAR:    CALL     CPDEHL      ; End of variable list 
 2304 0FCD CAE30F                  JP       Z,CFEVAL    ; Yes - Called from EVA
 2305 0FD0 79                      LD       A,C         ; Get second byte of na
 2306 0FD1 96                      SUB      (HL)        ; Compare with name in 
 2307 0FD2 23                      INC      HL          ; Move on to first byte
 2308 0FD3 C2D80F                  JP       NZ,FNTHR    ; Different - Find anot
 2309 0FD6 78                      LD       A,B         ; Get first byte of nam
 2310 0FD7 96                      SUB      (HL)        ; Compare with name in 
 2311 0FD8 23           FNTHR:     INC      HL          ; Move on to LSB of val
 2312 0FD9 CA1710                  JP       Z,RETADR    ; Found - Return addres
 2313 0FDC 23                      INC      HL          ; <- Skip
 2314 0FDD 23                      INC      HL          ; <- over
 2315 0FDE 23                      INC      HL          ; <- F.P.
 2316 0FDF 23                      INC      HL          ; <- value
 2317 0FE0 C3CA0F                  JP       FNDVAR      ; Keep looking
 2318                   ;
 2319 0FE3 E1           CFEVAL:    POP      HL          ; Restore code string a
 2320 0FE4 E3                      EX       (SP),HL     ; Get return address
 2321 0FE5 D5                      PUSH     DE          ; Save address of varia
 2322 0FE6 11650E                  LD       DE,FRMEVL   ; Return address in EVA
 2323 0FE9 CD6607                  CALL     CPDEHL      ; Called from EVAL ?
 2324 0FEC D1                      POP      DE          ; Restore address of va
 2325 0FED CA1A10                  JP       Z,RETNUL    ; Yes - Return null var
 2326 0FF0 E3                      EX       (SP),HL     ; Put back return
 2327 0FF1 E5                      PUSH     HL          ; Save code string addr
 2328 0FF2 C5                      PUSH     BC          ; Save variable name
 2329 0FF3 010600                  LD       BC,6        ; 2 byte name plus 4 by
 2330 0FF6 2A1F81                  LD       HL,(ARREND) ; End of arrays
 2331 0FF9 E5                      PUSH     HL          ; Save end of arrays
 2332 0FFA 09                      ADD      HL,BC       ; Move up 6 bytes
 2333 0FFB C1                      POP      BC          ; Source address in BC
 2334 0FFC E5                      PUSH     HL          ; Save new end address
 2335 0FFD CD6A04                  CALL     MOVUP       ; Move arrays up
 2336 1000 E1                      POP      HL          ; Restore new end addre
 2337 1001 221F81                  LD       (ARREND),HL ; Set new end address
 2338 1004 60                      LD       H,B         ; End of variables to H
 2339 1005 69                      LD       L,C
 2340 1006 221D81                  LD       (VAREND),HL ; Set new end address
 2341                   ;
 2342 1009 2B           ZEROLP:    DEC      HL          ; Back through to zero 
 2343 100A 3600                    LD       (HL),0      ; Zero byte in variable
 2344 100C CD6607                  CALL     CPDEHL      ; Done them all?
 2345 100F C20910                  JP       NZ,ZEROLP   ; No - Keep on going
 2346 1012 D1                      POP      DE          ; Get variable name
 2347 1013 73                      LD       (HL),E      ; Store second characte
 2348 1014 23                      INC      HL
 2349 1015 72                      LD       (HL),D      ; Store first character
 2350 1016 23                      INC      HL
 2351 1017 EB           RETADR:    EX       DE,HL       ; Address of variable i
 2352 1018 E1                      POP      HL          ; Restore code string a
 2353 1019 C9                      RET
 2354                   ;
 2355 101A 322C81       RETNUL:    LD       (FPEXP),A   ; Set result to zero
 2356 101D 213A04                  LD       HL,ZERBYT   ; Also set a null strin
 2357 1020 222981                  LD       (FPREG),HL  ; Save for EVAL
 2358 1023 E1                      POP      HL          ; Restore code string a
 2359 1024 C9                      RET
 2360                   ;
 2361 1025 E5           SBSCPT:    PUSH     HL          ; Save code string addr
 2362 1026 2AF180                  LD       HL,(LCRFLG) ; Locate/Create and Typ
 2363 1029 E3                      EX       (SP),HL     ; Save and get code str
 2364 102A 57                      LD       D,A         ; Zero number of dimens
 2365 102B D5           SCPTLP:    PUSH     DE          ; Save number of dimens
 2366 102C C5                      PUSH     BC          ; Save array name
 2367 102D CDAA09                  CALL     FPSINT      ; Get subscript (0-3276
 2368 1030 C1                      POP      BC          ; Restore array name
 2369 1031 F1                      POP      AF          ; Get number of dimensi
 2370 1032 EB                      EX       DE,HL
 2371 1033 E3                      EX       (SP),HL     ; Save subscript value
 2372 1034 E5                      PUSH     HL          ; Save LCRFLG and TYPE
 2373 1035 EB                      EX       DE,HL
 2374 1036 3C                      INC      A           ; Count dimensions
 2375 1037 57                      LD       D,A         ; Save in D
 2376 1038 7E                      LD       A,(HL)      ; Get next byte in code
 2377 1039 FE2C                    CP       ','         ; Comma (more to come)?
 2378 103B CA2B10                  JP       Z,SCPTLP    ; Yes - More subscripts
 2379 103E CD6C07                  CALL     CHKSYN      ; Make sure ")" follows
 2380 1041 29                      DB       ")"
 2381 1042 221581                  LD       (NXTOPR),HL ; Save code string addr
 2382 1045 E1                      POP      HL          ; Get LCRFLG and TYPE
 2383 1046 22F180                  LD       (LCRFLG),HL ; Restore Locate/create
 2384 1049 1E00                    LD       E,0         ; Flag not CSAVE* or CL
 2385 104B D5                      PUSH     DE          ; Save number of dimens
 2386 104C 11                      DB       11H         ; Skip "PUSH HL" and "P
 2387                   ;
 2388 104D E5           ARLDSV:    PUSH     HL          ; Save code string addr
 2389 104E F5                      PUSH     AF          ; A = 00 , Flags set = 
 2390 104F 2A1D81                  LD       HL,(VAREND) ; Start of arrays
 2391 1052 3E                      DB       3EH         ; Skip "ADD HL,DE"
 2392 1053 19           FNDARY:    ADD      HL,DE       ; Move to next array st
 2393 1054 EB                      EX       DE,HL
 2394 1055 2A1F81                  LD       HL,(ARREND) ; End of arrays
 2395 1058 EB                      EX       DE,HL       ; Current array pointer
 2396 1059 CD6607                  CALL     CPDEHL      ; End of arrays found?
 2397 105C CA8510                  JP       Z,CREARY    ; Yes - Create array
 2398 105F 7E                      LD       A,(HL)      ; Get second byte of na
 2399 1060 B9                      CP       C           ; Compare with name giv
 2400 1061 23                      INC      HL          ; Move on
 2401 1062 C26710                  JP       NZ,NXTARY   ; Different - Find next
 2402 1065 7E                      LD       A,(HL)      ; Get first byte of nam
 2403 1066 B8                      CP       B           ; Compare with name giv
 2404 1067 23           NXTARY:    INC      HL          ; Move on
 2405 1068 5E                      LD       E,(HL)      ; Get LSB of next array
 2406 1069 23                      INC      HL
 2407 106A 56                      LD       D,(HL)      ; Get MSB of next array
 2408 106B 23                      INC      HL
 2409 106C C25310                  JP       NZ,FNDARY   ; Not found - Keep look
 2410 106F 3AF180                  LD       A,(LCRFLG)  ; Found Locate or Creat
 2411 1072 B7                      OR       A
 2412 1073 C2A704                  JP       NZ,DDERR    ; Create - ?DD Error
 2413 1076 F1                      POP      AF          ; Locate - Get number o
 2414 1077 44                      LD       B,H         ; BC Points to array di
 2415 1078 4D                      LD       C,L
 2416 1079 CA9716                  JP       Z,POPHRT    ; Jump if array load/sa
 2417 107C 96                      SUB      (HL)        ; Same number of dimens
 2418 107D CAE310                  JP       Z,FINDEL    ; Yes - Find element
 2419 1080 1E10         BSERR:     LD       E,BS        ; ?BS Error
 2420 1082 C3B204                  JP       ERROR       ; Output error
 2421                   ;
 2422 1085 110400       CREARY:    LD       DE,4        ; 4 Bytes per entry
 2423 1088 F1                      POP      AF          ; Array to save or 0 di
 2424 1089 CACB09                  JP       Z,FCERR     ; Yes - ?FC Error
 2425 108C 71                      LD       (HL),C      ; Save second byte of n
 2426 108D 23                      INC      HL
 2427 108E 70                      LD       (HL),B      ; Save first byte of na
 2428 108F 23                      INC      HL
 2429 1090 4F                      LD       C,A         ; Number of dimensions 
 2430 1091 CD7B04                  CALL     CHKSTK      ; Check if enough memor
 2431 1094 23                      INC      HL          ; Point to number of di
 2432 1095 23                      INC      HL
 2433 1096 220A81                  LD       (CUROPR),HL ; Save address of point
 2434 1099 71                      LD       (HL),C      ; Set number of dimensi
 2435 109A 23                      INC      HL
 2436 109B 3AF180                  LD       A,(LCRFLG)  ; Locate of Create?
 2437 109E 17                      RLA                  ; Carry set = Create
 2438 109F 79                      LD       A,C         ; Get number of dimensi
 2439 10A0 010B00       CRARLP:    LD       BC,10+1     ; Default dimension siz
 2440 10A3 D2A810                  JP       NC,DEFSIZ   ; Locate - Set default 
 2441 10A6 C1                      POP      BC          ; Get specified dimensi
 2442 10A7 03                      INC      BC          ; Include zero element
 2443 10A8 71           DEFSIZ:    LD       (HL),C      ; Save LSB of dimension
 2444 10A9 23                      INC      HL
 2445 10AA 70                      LD       (HL),B      ; Save MSB of dimension
 2446 10AB 23                      INC      HL
 2447 10AC F5                      PUSH     AF          ; Save num' of dim'ns a
 2448 10AD E5                      PUSH     HL          ; Save address of dim'n
 2449 10AE CD4218                  CALL     MLDEBC      ; Multiply DE by BC to 
 2450 10B1 EB                      EX       DE,HL       ; amount of mem needed 
 2451 10B2 E1                      POP      HL          ; Restore address of di
 2452 10B3 F1                      POP      AF          ; Restore number of dim
 2453 10B4 3D                      DEC      A           ; Count them
 2454 10B5 C2A010                  JP       NZ,CRARLP   ; Do next dimension if 
 2455 10B8 F5                      PUSH     AF          ; Save locate/create fl
 2456 10B9 42                      LD       B,D         ; MSB of memory needed
 2457 10BA 4B                      LD       C,E         ; LSB of memory needed
 2458 10BB EB                      EX       DE,HL
 2459 10BC 19                      ADD      HL,DE       ; Add bytes to array st
 2460 10BD DA9304                  JP       C,OMERR     ; Too big - Error
 2461 10C0 CD8404                  CALL     ENFMEM      ; See if enough memory
 2462 10C3 221F81                  LD       (ARREND),HL ; Save new end of array
 2463                   ;
 2464 10C6 2B           ZERARY:    DEC      HL          ; Back through array da
 2465 10C7 3600                    LD       (HL),0      ; Set array element to 
 2466 10C9 CD6607                  CALL     CPDEHL      ; All elements zeroed?
 2467 10CC C2C610                  JP       NZ,ZERARY   ; No - Keep on going
 2468 10CF 03                      INC      BC          ; Number of bytes + 1
 2469 10D0 57                      LD       D,A         ; A=0
 2470 10D1 2A0A81                  LD       HL,(CUROPR) ; Get address of array
 2471 10D4 5E                      LD       E,(HL)      ; Number of dimensions
 2472 10D5 EB                      EX       DE,HL       ; To HL
 2473 10D6 29                      ADD      HL,HL       ; Two bytes per dimensi
 2474 10D7 09                      ADD      HL,BC       ; Add number of bytes
 2475 10D8 EB                      EX       DE,HL       ; Bytes needed to DE
 2476 10D9 2B                      DEC      HL
 2477 10DA 2B                      DEC      HL
 2478 10DB 73                      LD       (HL),E      ; Save LSB of bytes nee
 2479 10DC 23                      INC      HL
 2480 10DD 72                      LD       (HL),D      ; Save MSB of bytes nee
 2481 10DE 23                      INC      HL
 2482 10DF F1                      POP      AF          ; Locate / Create?
 2483 10E0 DA0711                  JP       C,ENDDIM    ; A is 0 , End if creat
 2484 10E3 47           FINDEL:    LD       B,A         ; Find array element
 2485 10E4 4F                      LD       C,A
 2486 10E5 7E                      LD       A,(HL)      ; Number of dimensions
 2487 10E6 23                      INC      HL
 2488 10E7 16                      DB       16H         ; Skip "POP HL"
 2489 10E8 E1           FNDELP:    POP      HL          ; Address of next dim' 
 2490 10E9 5E                      LD       E,(HL)      ; Get LSB of dim'n size
 2491 10EA 23                      INC      HL
 2492 10EB 56                      LD       D,(HL)      ; Get MSB of dim'n size
 2493 10EC 23                      INC      HL
 2494 10ED E3                      EX       (SP),HL     ; Save address - Get in
 2495 10EE F5                      PUSH     AF          ; Save number of dim'ns
 2496 10EF CD6607                  CALL     CPDEHL      ; Dimension too large?
 2497 10F2 D28010                  JP       NC,BSERR    ; Yes - ?BS Error
 2498 10F5 E5                      PUSH     HL          ; Save index
 2499 10F6 CD4218                  CALL     MLDEBC      ; Multiply previous by 
 2500 10F9 D1                      POP      DE          ; Index supplied to DE
 2501 10FA 19                      ADD      HL,DE       ; Add index to pointer
 2502 10FB F1                      POP      AF          ; Number of dimensions
 2503 10FC 3D                      DEC      A           ; Count them
 2504 10FD 44                      LD       B,H         ; MSB of pointer
 2505 10FE 4D                      LD       C,L         ; LSB of pointer
 2506 10FF C2E810                  JP       NZ,FNDELP   ; More - Keep going
 2507 1102 29                      ADD      HL,HL       ; 4 Bytes per element
 2508 1103 29                      ADD      HL,HL
 2509 1104 C1                      POP      BC          ; Start of array
 2510 1105 09                      ADD      HL,BC       ; Point to element
 2511 1106 EB                      EX       DE,HL       ; Address of element to
 2512 1107 2A1581       ENDDIM:    LD       HL,(NXTOPR) ; Got code string addre
 2513 110A C9                      RET
 2514                   ;
 2515 110B 2A1F81       FRE:       LD       HL,(ARREND) ; Start of free memory
 2516 110E EB                      EX       DE,HL       ; To DE
 2517 110F 210000                  LD       HL,0        ; End of free memory
 2518 1112 39                      ADD      HL,SP       ; Current stack value
 2519 1113 3AF280                  LD       A,(TYPE)    ; Dummy argument type
 2520 1116 B7                      OR       A
 2521 1117 CA2711                  JP       Z,FRENUM    ; Numeric - Free variab
 2522 111A CD8E13                  CALL     GSTRCU      ; Current string to poo
 2523 111D CD8E12                  CALL     GARBGE      ; Garbage collection
 2524 1120 2A9F80                  LD       HL,(STRSPC) ; Bottom of string spac
 2525 1123 EB                      EX       DE,HL       ; To DE
 2526 1124 2A0881                  LD       HL,(STRBOT) ; Bottom of string spac
 2527 1127 7D           FRENUM:    LD       A,L         ; Get LSB of end
 2528 1128 93                      SUB      E           ; Subtract LSB of begin
 2529 1129 4F                      LD       C,A         ; Save difference if C
 2530 112A 7C                      LD       A,H         ; Get MSB of end
 2531 112B 9A                      SBC      A,D         ; Subtract MSB of begin
 2532 112C 41           ACPASS:    LD       B,C         ; Return integer AC
 2533 112D 50           ABPASS:    LD       D,B         ; Return integer AB
 2534 112E 1E00                    LD       E,0
 2535 1130 21F280                  LD       HL,TYPE     ; Point to type
 2536 1133 73                      LD       (HL),E      ; Set type to numeric
 2537 1134 0690                    LD       B,80H+16    ; 16 bit integer
 2538 1136 C36D17                  JP       RETINT      ; Return the integr
 2539                   ;
 2540 1139 3AF080       POS:       LD       A,(CURPOS)  ; Get cursor position
 2541 113C 47           PASSA:     LD       B,A         ; Put A into AB
 2542 113D AF                      XOR      A           ; Zero A
 2543 113E C32D11                  JP       ABPASS      ; Return integer AB
 2544                   ;
 2545 1141 CDC411       DEF:       CALL     CHEKFN      ; Get "FN" and name
 2546 1144 CDB611                  CALL     IDTEST      ; Test for illegal dire
 2547 1147 019B0A                  LD       BC,DATA     ; To get next statement
 2548 114A C5                      PUSH     BC          ; Save address for RETu
 2549 114B D5                      PUSH     DE          ; Save address of funct
 2550 114C CD6C07                  CALL     CHKSYN      ; Make sure "(" follows
 2551 114F 28                      DB       "("
 2552 1150 CD680F                  CALL     GETVAR      ; Get argument variable
 2553 1153 E5                      PUSH     HL          ; Save code string addr
 2554 1154 EB                      EX       DE,HL       ; Argument address to H
 2555 1155 2B                      DEC      HL
 2556 1156 56                      LD       D,(HL)      ; Get first byte of arg
 2557 1157 2B                      DEC      HL
 2558 1158 5E                      LD       E,(HL)      ; Get second byte of ar
 2559 1159 E1                      POP      HL          ; Restore code string a
 2560 115A CD740D                  CALL     TSTNUM      ; Make sure numeric arg
 2561 115D CD6C07                  CALL     CHKSYN      ; Make sure ")" follows
 2562 1160 29                      DB       ")"
 2563 1161 CD6C07                  CALL     CHKSYN      ; Make sure "=" follows
 2564 1164 B4                      DB       ZEQUAL      ; "=" token
 2565 1165 44                      LD       B,H         ; Code string address t
 2566 1166 4D                      LD       C,L
 2567 1167 E3                      EX       (SP),HL     ; Save code str , Get F
 2568 1168 71                      LD       (HL),C      ; Save LSB of FN code s
 2569 1169 23                      INC      HL
 2570 116A 70                      LD       (HL),B      ; Save MSB of FN code s
 2571 116B C30312                  JP       SVSTAD      ; Save address and do f
 2572                   ;
 2573 116E CDC411       DOFN:      CALL     CHEKFN      ; Make sure FN follows
 2574 1171 D5                      PUSH     DE          ; Save function pointer
 2575 1172 CD490E                  CALL     EVLPAR      ; Evaluate expression i
 2576 1175 CD740D                  CALL     TSTNUM      ; Make sure numeric res
 2577 1178 E3                      EX       (SP),HL     ; Save code str , Get F
 2578 1179 5E                      LD       E,(HL)      ; Get LSB of FN code st
 2579 117A 23                      INC      HL
 2580 117B 56                      LD       D,(HL)      ; Get MSB of FN code st
 2581 117C 23                      INC      HL
 2582 117D 7A                      LD       A,D         ; And function DEFined?
 2583 117E B3                      OR       E
 2584 117F CAAA04                  JP       Z,UFERR     ; No - ?UF Error
 2585 1182 7E                      LD       A,(HL)      ; Get LSB of argument a
 2586 1183 23                      INC      HL
 2587 1184 66                      LD       H,(HL)      ; Get MSB of argument a
 2588 1185 6F                      LD       L,A         ; HL = Arg variable add
 2589 1186 E5                      PUSH     HL          ; Save it
 2590 1187 2A2381                  LD       HL,(FNRGNM) ; Get old argument name
 2591 118A E3                      EX       (SP),HL     ;        ; Save old , G
 2592 118B 222381                  LD       (FNRGNM),HL ; Set new argument name
 2593 118E 2A2781                  LD       HL,(FNARG+2) ; Get LSB,NLSB of old 
 2594 1191 E5                      PUSH     HL          ; Save it
 2595 1192 2A2581                  LD       HL,(FNARG)  ; Get MSB,EXP of old ar
 2596 1195 E5                      PUSH     HL          ; Save it
 2597 1196 212581                  LD       HL,FNARG    ; HL = Value of argumen
 2598 1199 D5                      PUSH     DE          ; Save FN code string a
 2599 119A CDAE17                  CALL     FPTHL       ; Move FPREG to argumen
 2600 119D E1                      POP      HL          ; Get FN code string ad
 2601 119E CD710D                  CALL     GETNUM      ; Get value from functi
 2602 11A1 2B                      DEC      HL          ; DEC 'cos GETCHR INCs
 2603 11A2 CDFA08                  CALL     GETCHR      ; Get next character
 2604 11A5 C29E04                  JP       NZ,SNERR    ; Bad character in FN -
 2605 11A8 E1                      POP      HL          ; Get MSB,EXP of old ar
 2606 11A9 222581                  LD       (FNARG),HL  ; Restore it
 2607 11AC E1                      POP      HL          ; Get LSB,NLSB of old a
 2608 11AD 222781                  LD       (FNARG+2),HL ; Restore it
 2609 11B0 E1                      POP      HL          ; Get name of old arg
 2610 11B1 222381                  LD       (FNRGNM),HL ; Restore it
 2611 11B4 E1                      POP      HL          ; Restore code string a
 2612 11B5 C9                      RET
 2613                   ;
 2614 11B6 E5           IDTEST:    PUSH     HL          ; Save code string addr
 2615 11B7 2AA180                  LD       HL,(LINEAT) ; Get current line numb
 2616 11BA 23                      INC      HL          ; -1 means direct state
 2617 11BB 7C                      LD       A,H
 2618 11BC B5                      OR       L
 2619 11BD E1                      POP      HL          ; Restore code string a
 2620 11BE C0                      RET      NZ          ; Return if in program
 2621 11BF 1E16                    LD       E,ID        ; ?ID Error
 2622 11C1 C3B204                  JP       ERROR
 2623                   ;
 2624 11C4 CD6C07       CHEKFN:    CALL     CHKSYN      ; Make sure FN follows
 2625 11C7 A7                      DB       ZFN         ; "FN" token
 2626 11C8 3E80                    LD       A,80H
 2627 11CA 321081                  LD       (FORFLG),A  ; Flag FN name to find
 2628 11CD B6                      OR       (HL)        ; FN name has bit 7 set
 2629 11CE 47                      LD       B,A         ; in first byte of name
 2630 11CF CD6D0F                  CALL     GTFNAM      ; Get FN name
 2631 11D2 C3740D                  JP       TSTNUM      ; Make sure numeric fun
 2632                   ;
 2633 11D5 CD740D       STR:       CALL     TSTNUM      ; Make sure it's a numb
 2634 11D8 CDFB18                  CALL     NUMASC      ; Turn number into text
 2635 11DB CD0912       STR1:      CALL     CRTST       ; Create string entry f
 2636 11DE CD8E13                  CALL     GSTRCU      ; Current string to poo
 2637 11E1 01E913                  LD       BC,TOPOOL   ; Save in string pool
 2638 11E4 C5                      PUSH     BC          ; Save address on stack
 2639                   ;
 2640 11E5 7E           SAVSTR:    LD       A,(HL)      ; Get string length
 2641 11E6 23                      INC      HL
 2642 11E7 23                      INC      HL
 2643 11E8 E5                      PUSH     HL          ; Save pointer to strin
 2644 11E9 CD6412                  CALL     TESTR       ; See if enough string 
 2645 11EC E1                      POP      HL          ; Restore pointer to st
 2646 11ED 4E                      LD       C,(HL)      ; Get LSB of address
 2647 11EE 23                      INC      HL
 2648 11EF 46                      LD       B,(HL)      ; Get MSB of address
 2649 11F0 CDFD11                  CALL     CRTMST      ; Create string entry
 2650 11F3 E5                      PUSH     HL          ; Save pointer to MSB o
 2651 11F4 6F                      LD       L,A         ; Length of string
 2652 11F5 CD8113                  CALL     TOSTRA      ; Move to string area
 2653 11F8 D1                      POP      DE          ; Restore pointer to MS
 2654 11F9 C9                      RET
 2655                   ;
 2656 11FA CD6412       MKTMST:    CALL     TESTR       ; See if enough string 
 2657 11FD 210481       CRTMST:    LD       HL,TMPSTR   ; Temporary string
 2658 1200 E5                      PUSH     HL          ; Save it
 2659 1201 77                      LD       (HL),A      ; Save length of string
 2660 1202 23                      INC      HL
 2661 1203 23           SVSTAD:    INC      HL
 2662 1204 73                      LD       (HL),E      ; Save LSB of address
 2663 1205 23                      INC      HL
 2664 1206 72                      LD       (HL),D      ; Save MSB of address
 2665 1207 E1                      POP      HL          ; Restore pointer
 2666 1208 C9                      RET
 2667                   ;
 2668 1209 2B           CRTST:     DEC      HL          ; DEC - INCed after
 2669 120A 0622         QTSTR:     LD       B,'"'       ; Terminating quote
 2670 120C 50                      LD       D,B         ; Quote to D
 2671 120D E5           DTSTR:     PUSH     HL          ; Save start
 2672 120E 0EFF                    LD       C,-1        ; Set counter to -1
 2673 1210 23           QTSTLP:    INC      HL          ; Move on
 2674 1211 7E                      LD       A,(HL)      ; Get byte
 2675 1212 0C                      INC      C           ; Count bytes
 2676 1213 B7                      OR       A           ; End of line?
 2677 1214 CA1F12                  JP       Z,CRTSTE    ; Yes - Create string e
 2678 1217 BA                      CP       D           ; Terminator D found?
 2679 1218 CA1F12                  JP       Z,CRTSTE    ; Yes - Create string e
 2680 121B B8                      CP       B           ; Terminator B found?
 2681 121C C21012                  JP       NZ,QTSTLP   ; No - Keep looking
 2682 121F FE22         CRTSTE:    CP       '"'         ; End with '"'?
 2683 1221 CCFA08                  CALL     Z,GETCHR    ; Yes - Get next charac
 2684 1224 E3                      EX       (SP),HL     ; Starting quote
 2685 1225 23                      INC      HL          ; First byte of string
 2686 1226 EB                      EX       DE,HL       ; To DE
 2687 1227 79                      LD       A,C         ; Get length
 2688 1228 CDFD11                  CALL     CRTMST      ; Create string entry
 2689 122B 110481       TSTOPL:    LD       DE,TMPSTR   ; Temporary string
 2690 122E 2AF680                  LD       HL,(TMSTPT) ; Temporary string pool
 2691 1231 222981                  LD       (FPREG),HL  ; Save address of strin
 2692 1234 3E01                    LD       A,1
 2693 1236 32F280                  LD       (TYPE),A    ; Set type to string
 2694 1239 CDB117                  CALL     DETHL4      ; Move string to pool
 2695 123C CD6607                  CALL     CPDEHL      ; Out of string pool?
 2696 123F 22F680                  LD       (TMSTPT),HL ; Save new pointer
 2697 1242 E1                      POP      HL          ; Restore code string a
 2698 1243 7E                      LD       A,(HL)      ; Get next code byte
 2699 1244 C0                      RET      NZ          ; Return if pool OK
 2700 1245 1E1E                    LD       E,ST        ; ?ST Error
 2701 1247 C3B204                  JP       ERROR       ; String pool overflow
 2702                   ;
 2703 124A 23           PRNUMS:    INC      HL          ; Skip leading space
 2704 124B CD0912       PRS:       CALL     CRTST       ; Create string entry f
 2705 124E CD8E13       PRS1:      CALL     GSTRCU      ; Current string to poo
 2706 1251 CDA517                  CALL     LOADFP      ; Move string block to 
 2707 1254 1C                      INC      E           ; Length + 1
 2708 1255 1D           PRSLP:     DEC      E           ; Count characters
 2709 1256 C8                      RET      Z           ; End of string
 2710 1257 0A                      LD       A,(BC)      ; Get byte to output
 2711 1258 CD7707                  CALL     OUTC        ; Output character in A
 2712 125B FE0D                    CP       CR          ; Return?
 2713 125D CCB60B                  CALL     Z,DONULL    ; Yes - Do nulls
 2714 1260 03                      INC      BC          ; Next byte in string
 2715 1261 C35512                  JP       PRSLP       ; More characters to ou
 2716                   ;
 2717 1264 B7           TESTR:     OR       A           ; Test if enough room
 2718 1265 0E                      DB       0EH         ; No garbage collection
 2719 1266 F1           GRBDON:    POP      AF          ; Garbage collection do
 2720 1267 F5                      PUSH     AF          ; Save status
 2721 1268 2A9F80                  LD       HL,(STRSPC) ; Bottom of string spac
 2722 126B EB                      EX       DE,HL       ; To DE
 2723 126C 2A0881                  LD       HL,(STRBOT) ; Bottom of string area
 2724 126F 2F                      CPL                  ; Negate length (Top do
 2725 1270 4F                      LD       C,A         ; -Length to BC
 2726 1271 06FF                    LD       B,-1        ; BC = -ve length of st
 2727 1273 09                      ADD      HL,BC       ; Add to bottom of spac
 2728 1274 23                      INC      HL          ; Plus one for 2's comp
 2729 1275 CD6607                  CALL     CPDEHL      ; Below string RAM area
 2730 1278 DA8212                  JP       C,TESTOS    ; Tidy up if not done e
 2731 127B 220881                  LD       (STRBOT),HL ; Save new bottom of ar
 2732 127E 23                      INC      HL          ; Point to first byte o
 2733 127F EB                      EX       DE,HL       ; Address to DE
 2734 1280 F1           POPAF:     POP      AF          ; Throw away status pus
 2735 1281 C9                      RET
 2736                   ;
 2737 1282 F1           TESTOS:    POP      AF          ; Garbage collect been 
 2738 1283 1E1A                    LD       E,OS        ; ?OS Error
 2739 1285 CAB204                  JP       Z,ERROR     ; Yes - Not enough stri
 2740 1288 BF                      CP       A           ; Flag garbage collect 
 2741 1289 F5                      PUSH     AF          ; Save status
 2742 128A 016612                  LD       BC,GRBDON   ; Garbage collection do
 2743 128D C5                      PUSH     BC          ; Save for RETurn
 2744 128E 2AF480       GARBGE:    LD       HL,(LSTRAM) ; Get end of RAM pointe
 2745 1291 220881       GARBLP:    LD       (STRBOT),HL ; Reset string pointer
 2746 1294 210000                  LD       HL,0
 2747 1297 E5                      PUSH     HL          ; Flag no string found
 2748 1298 2A9F80                  LD       HL,(STRSPC) ; Get bottom of string 
 2749 129B E5                      PUSH     HL          ; Save bottom of string
 2750 129C 21F880                  LD       HL,TMSTPL   ; Temporary string pool
 2751 129F EB           GRBLP:     EX       DE,HL
 2752 12A0 2AF680                  LD       HL,(TMSTPT) ; Temporary string pool
 2753 12A3 EB                      EX       DE,HL
 2754 12A4 CD6607                  CALL     CPDEHL      ; Temporary string pool
 2755 12A7 019F12                  LD       BC,GRBLP    ; Loop until string poo
 2756 12AA C2F312                  JP       NZ,STPOOL   ; No - See if in string
 2757 12AD 2A1B81                  LD       HL,(PROGND) ; Start of simple varia
 2758 12B0 EB           SMPVAR:    EX       DE,HL
 2759 12B1 2A1D81                  LD       HL,(VAREND) ; End of simple variabl
 2760 12B4 EB                      EX       DE,HL
 2761 12B5 CD6607                  CALL     CPDEHL      ; All simple strings do
 2762 12B8 CAC612                  JP       Z,ARRLP     ; Yes - Do string array
 2763 12BB 7E                      LD       A,(HL)      ; Get type of variable
 2764 12BC 23                      INC      HL
 2765 12BD 23                      INC      HL
 2766 12BE B7                      OR       A           ; "S" flag set if strin
 2767 12BF CDF612                  CALL     STRADD      ; See if string in stri
 2768 12C2 C3B012                  JP       SMPVAR      ; Loop until simple one
 2769                   ;
 2770 12C5 C1           GNXARY:    POP      BC          ; Scrap address of this
 2771 12C6 EB           ARRLP:     EX       DE,HL
 2772 12C7 2A1F81                  LD       HL,(ARREND) ; End of string arrays
 2773 12CA EB                      EX       DE,HL
 2774 12CB CD6607                  CALL     CPDEHL      ; All string arrays don
 2775 12CE CA1C13                  JP       Z,SCNEND    ; Yes - Move string if 
 2776 12D1 CDA517                  CALL     LOADFP      ; Get array name to BCD
 2777 12D4 7B                      LD       A,E         ; Get type of array
 2778 12D5 E5                      PUSH     HL          ; Save address of num o
 2779 12D6 09                      ADD      HL,BC       ; Start of next array
 2780 12D7 B7                      OR       A           ; Test type of array
 2781 12D8 F2C512                  JP       P,GNXARY    ; Numeric array - Ignor
 2782 12DB 220A81                  LD       (CUROPR),HL ; Save address of next 
 2783 12DE E1                      POP      HL          ; Get address of num of
 2784 12DF 4E                      LD       C,(HL)      ; BC = Number of dimens
 2785 12E0 0600                    LD       B,0
 2786 12E2 09                      ADD      HL,BC       ; Two bytes per dimensi
 2787 12E3 09                      ADD      HL,BC
 2788 12E4 23                      INC      HL          ; Plus one for number o
 2789 12E5 EB           GRBARY:    EX       DE,HL
 2790 12E6 2A0A81                  LD       HL,(CUROPR) ; Get address of next a
 2791 12E9 EB                      EX       DE,HL
 2792 12EA CD6607                  CALL     CPDEHL      ; Is this array finishe
 2793 12ED CAC612                  JP       Z,ARRLP     ; Yes - Get next one
 2794 12F0 01E512                  LD       BC,GRBARY   ; Loop until array all 
 2795 12F3 C5           STPOOL:    PUSH     BC          ; Save return address
 2796 12F4 F680                    OR       80H         ; Flag string type
 2797 12F6 7E           STRADD:    LD       A,(HL)      ; Get string length
 2798 12F7 23                      INC      HL
 2799 12F8 23                      INC      HL
 2800 12F9 5E                      LD       E,(HL)      ; Get LSB of string add
 2801 12FA 23                      INC      HL
 2802 12FB 56                      LD       D,(HL)      ; Get MSB of string add
 2803 12FC 23                      INC      HL
 2804 12FD F0                      RET      P           ; Not a string - Return
 2805 12FE B7                      OR       A           ; Set flags on string l
 2806 12FF C8                      RET      Z           ; Null string - Return
 2807 1300 44                      LD       B,H         ; Save variable pointer
 2808 1301 4D                      LD       C,L
 2809 1302 2A0881                  LD       HL,(STRBOT) ; Bottom of new area
 2810 1305 CD6607                  CALL     CPDEHL      ; String been done?
 2811 1308 60                      LD       H,B         ; Restore variable poin
 2812 1309 69                      LD       L,C
 2813 130A D8                      RET      C           ; String done - Ignore
 2814 130B E1                      POP      HL          ; Return address
 2815 130C E3                      EX       (SP),HL     ; Lowest available stri
 2816 130D CD6607                  CALL     CPDEHL      ; String within string 
 2817 1310 E3                      EX       (SP),HL     ; Lowest available stri
 2818 1311 E5                      PUSH     HL          ; Re-save return addres
 2819 1312 60                      LD       H,B         ; Restore variable poin
 2820 1313 69                      LD       L,C
 2821 1314 D0                      RET      NC          ; Outside string area -
 2822 1315 C1                      POP      BC          ; Get return , Throw 2 
 2823 1316 F1                      POP      AF          ;
 2824 1317 F1                      POP      AF          ;
 2825 1318 E5                      PUSH     HL          ; Save variable pointer
 2826 1319 D5                      PUSH     DE          ; Save address of curre
 2827 131A C5                      PUSH     BC          ; Put back return addre
 2828 131B C9                      RET                  ; Go to it
 2829                   ;
 2830 131C D1           SCNEND:    POP      DE          ; Addresses of strings
 2831 131D E1                      POP      HL          ;
 2832 131E 7D                      LD       A,L         ; HL = 0 if no more to 
 2833 131F B4                      OR       H
 2834 1320 C8                      RET      Z           ; No more to do - Retur
 2835 1321 2B                      DEC      HL
 2836 1322 46                      LD       B,(HL)      ; MSB of address of str
 2837 1323 2B                      DEC      HL
 2838 1324 4E                      LD       C,(HL)      ; LSB of address of str
 2839 1325 E5                      PUSH     HL          ; Save variable address
 2840 1326 2B                      DEC      HL
 2841 1327 2B                      DEC      HL
 2842 1328 6E                      LD       L,(HL)      ; HL = Length of string
 2843 1329 2600                    LD       H,0
 2844 132B 09                      ADD      HL,BC       ; Address of end of str
 2845 132C 50                      LD       D,B         ; String address to DE
 2846 132D 59                      LD       E,C
 2847 132E 2B                      DEC      HL          ; Last byte in string
 2848 132F 44                      LD       B,H         ; Address to BC
 2849 1330 4D                      LD       C,L
 2850 1331 2A0881                  LD       HL,(STRBOT) ; Current bottom of str
 2851 1334 CD6D04                  CALL     MOVSTR      ; Move string to new ad
 2852 1337 E1                      POP      HL          ; Restore variable addr
 2853 1338 71                      LD       (HL),C      ; Save new LSB of addre
 2854 1339 23                      INC      HL
 2855 133A 70                      LD       (HL),B      ; Save new MSB of addre
 2856 133B 69                      LD       L,C         ; Next string area+1 to
 2857 133C 60                      LD       H,B
 2858 133D 2B                      DEC      HL          ; Next string area addr
 2859 133E C39112                  JP       GARBLP      ; Look for more strings
 2860                   ;
 2861 1341 C5           CONCAT:    PUSH     BC          ; Save prec' opr & code
 2862 1342 E5                      PUSH     HL          ;
 2863 1343 2A2981                  LD       HL,(FPREG)  ; Get first string
 2864 1346 E3                      EX       (SP),HL     ; Save first string
 2865 1347 CDFA0D                  CALL     OPRND       ; Get second string
 2866 134A E3                      EX       (SP),HL     ; Restore first string
 2867 134B CD750D                  CALL     TSTSTR      ; Make sure it's a stri
 2868 134E 7E                      LD       A,(HL)      ; Get length of second 
 2869 134F E5                      PUSH     HL          ; Save first string
 2870 1350 2A2981                  LD       HL,(FPREG)  ; Get second string
 2871 1353 E5                      PUSH     HL          ; Save second string
 2872 1354 86                      ADD      A,(HL)      ; Add length of second 
 2873 1355 1E1C                    LD       E,LS        ; ?LS Error
 2874 1357 DAB204                  JP       C,ERROR     ; String too long - Err
 2875 135A CDFA11                  CALL     MKTMST      ; Make temporary string
 2876 135D D1                      POP      DE          ; Get second string to 
 2877 135E CD9213                  CALL     GSTRDE      ; Move to string pool i
 2878 1361 E3                      EX       (SP),HL     ; Get first string
 2879 1362 CD9113                  CALL     GSTRHL      ; Move to string pool i
 2880 1365 E5                      PUSH     HL          ; Save first string
 2881 1366 2A0681                  LD       HL,(TMPSTR+2) ; Temporary string ad
 2882 1369 EB                      EX       DE,HL       ; To DE
 2883 136A CD7813                  CALL     SSTSA       ; First string to strin
 2884 136D CD7813                  CALL     SSTSA       ; Second string to stri
 2885 1370 218F0D                  LD       HL,EVAL2    ; Return to evaluation 
 2886 1373 E3                      EX       (SP),HL     ; Save return,get code 
 2887 1374 E5                      PUSH     HL          ; Save code string addr
 2888 1375 C32B12                  JP       TSTOPL      ; To temporary string t
 2889                   ;
 2890 1378 E1           SSTSA:     POP      HL          ; Return address
 2891 1379 E3                      EX       (SP),HL     ; Get string block,save
 2892 137A 7E                      LD       A,(HL)      ; Get length of string
 2893 137B 23                      INC      HL
 2894 137C 23                      INC      HL
 2895 137D 4E                      LD       C,(HL)      ; Get LSB of string add
 2896 137E 23                      INC      HL
 2897 137F 46                      LD       B,(HL)      ; Get MSB of string add
 2898 1380 6F                      LD       L,A         ; Length to L
 2899 1381 2C           TOSTRA:    INC      L           ; INC - DECed after
 2900 1382 2D           TSALP:     DEC      L           ; Count bytes moved
 2901 1383 C8                      RET      Z           ; End of string - Retur
 2902 1384 0A                      LD       A,(BC)      ; Get source
 2903 1385 12                      LD       (DE),A      ; Save destination
 2904 1386 03                      INC      BC          ; Next source
 2905 1387 13                      INC      DE          ; Next destination
 2906 1388 C38213                  JP       TSALP       ; Loop until string mov
 2907                   ;
 2908 138B CD750D       GETSTR:    CALL     TSTSTR      ; Make sure it's a stri
 2909 138E 2A2981       GSTRCU:    LD       HL,(FPREG)  ; Get current string
 2910 1391 EB           GSTRHL:    EX       DE,HL       ; Save DE
 2911 1392 CDAC13       GSTRDE:    CALL     BAKTMP      ; Was it last tmp-str?
 2912 1395 EB                      EX       DE,HL       ; Restore DE
 2913 1396 C0                      RET      NZ          ; No - Return
 2914 1397 D5                      PUSH     DE          ; Save string
 2915 1398 50                      LD       D,B         ; String block address 
 2916 1399 59                      LD       E,C
 2917 139A 1B                      DEC      DE          ; Point to length
 2918 139B 4E                      LD       C,(HL)      ; Get string length
 2919 139C 2A0881                  LD       HL,(STRBOT) ; Current bottom of str
 2920 139F CD6607                  CALL     CPDEHL      ; Last one in string ar
 2921 13A2 C2AA13                  JP       NZ,POPHL    ; No - Return
 2922 13A5 47                      LD       B,A         ; Clear B (A=0)
 2923 13A6 09                      ADD      HL,BC       ; Remove string from st
 2924 13A7 220881                  LD       (STRBOT),HL ; Save new bottom of st
 2925 13AA E1           POPHL:     POP      HL          ; Restore string
 2926 13AB C9                      RET
 2927                   ;
 2928 13AC 2AF680       BAKTMP:    LD       HL,(TMSTPT) ; Get temporary string 
 2929 13AF 2B                      DEC      HL          ; Back
 2930 13B0 46                      LD       B,(HL)      ; Get MSB of address
 2931 13B1 2B                      DEC      HL          ; Back
 2932 13B2 4E                      LD       C,(HL)      ; Get LSB of address
 2933 13B3 2B                      DEC      HL          ; Back
 2934 13B4 2B                      DEC      HL          ; Back
 2935 13B5 CD6607                  CALL     CPDEHL      ; String last in string
 2936 13B8 C0                      RET      NZ          ; Yes - Leave it
 2937 13B9 22F680                  LD       (TMSTPT),HL ; Save new string pool 
 2938 13BC C9                      RET
 2939                   ;
 2940 13BD 013C11       LEN:       LD       BC,PASSA    ; To return integer A
 2941 13C0 C5                      PUSH     BC          ; Save address
 2942 13C1 CD8B13       GETLEN:    CALL     GETSTR      ; Get string and its le
 2943 13C4 AF                      XOR      A
 2944 13C5 57                      LD       D,A         ; Clear D
 2945 13C6 32F280                  LD       (TYPE),A    ; Set type to numeric
 2946 13C9 7E                      LD       A,(HL)      ; Get length of string
 2947 13CA B7                      OR       A           ; Set status flags
 2948 13CB C9                      RET
 2949                   ;
 2950 13CC 013C11       ASC:       LD       BC,PASSA    ; To return integer A
 2951 13CF C5                      PUSH     BC          ; Save address
 2952 13D0 CDC113       GTFLNM:    CALL     GETLEN      ; Get length of string
 2953 13D3 CACB09                  JP       Z,FCERR     ; Null string - Error
 2954 13D6 23                      INC      HL
 2955 13D7 23                      INC      HL
 2956 13D8 5E                      LD       E,(HL)      ; Get LSB of address
 2957 13D9 23                      INC      HL
 2958 13DA 56                      LD       D,(HL)      ; Get MSB of address
 2959 13DB 1A                      LD       A,(DE)      ; Get first byte of str
 2960 13DC C9                      RET
 2961                   ;
 2962 13DD 3E01         CHR:       LD       A,1         ; One character string
 2963 13DF CDFA11                  CALL     MKTMST      ; Make a temporary stri
 2964 13E2 CDD814                  CALL     MAKINT      ; Make it integer A
 2965 13E5 2A0681                  LD       HL,(TMPSTR+2) ; Get address of stri
 2966 13E8 73                      LD       (HL),E      ; Save character
 2967 13E9 C1           TOPOOL:    POP      BC          ; Clean up stack
 2968 13EA C32B12                  JP       TSTOPL      ; Temporary string to p
 2969                   ;
 2970 13ED CD8814       LEFT:      CALL     LFRGNM      ; Get number and ending
 2971 13F0 AF                      XOR      A           ; Start at first byte i
 2972 13F1 E3           RIGHT1:    EX       (SP),HL     ; Save code string,Get 
 2973 13F2 4F                      LD       C,A         ; Starting position in 
 2974 13F3 E5           MID1:      PUSH     HL          ; Save string block add
 2975 13F4 7E                      LD       A,(HL)      ; Get length of string
 2976 13F5 B8                      CP       B           ; Compare with number g
 2977 13F6 DAFB13                  JP       C,ALLFOL    ; All following bytes r
 2978 13F9 78                      LD       A,B         ; Get new length
 2979 13FA 11                      DB       11H         ; Skip "LD C,0"
 2980 13FB 0E00         ALLFOL:    LD       C,0         ; First byte of string
 2981 13FD C5                      PUSH     BC          ; Save position in stri
 2982 13FE CD6412                  CALL     TESTR       ; See if enough string 
 2983 1401 C1                      POP      BC          ; Get position in strin
 2984 1402 E1                      POP      HL          ; Restore string block 
 2985 1403 E5                      PUSH     HL          ; And re-save it
 2986 1404 23                      INC      HL
 2987 1405 23                      INC      HL
 2988 1406 46                      LD       B,(HL)      ; Get LSB of address
 2989 1407 23                      INC      HL
 2990 1408 66                      LD       H,(HL)      ; Get MSB of address
 2991 1409 68                      LD       L,B         ; HL = address of strin
 2992 140A 0600                    LD       B,0         ; BC = starting address
 2993 140C 09                      ADD      HL,BC       ; Point to that byte
 2994 140D 44                      LD       B,H         ; BC = source string
 2995 140E 4D                      LD       C,L
 2996 140F CDFD11                  CALL     CRTMST      ; Create a string entry
 2997 1412 6F                      LD       L,A         ; Length of new string
 2998 1413 CD8113                  CALL     TOSTRA      ; Move string to string
 2999 1416 D1                      POP      DE          ; Clear stack
 3000 1417 CD9213                  CALL     GSTRDE      ; Move to string pool i
 3001 141A C32B12                  JP       TSTOPL      ; Temporary string to p
 3002                   ;
 3003 141D CD8814       RIGHT:     CALL     LFRGNM      ; Get number and ending
 3004 1420 D1                      POP      DE          ; Get string length
 3005 1421 D5                      PUSH     DE          ; And re-save
 3006 1422 1A                      LD       A,(DE)      ; Get length
 3007 1423 90                      SUB      B           ; Move back N bytes
 3008 1424 C3F113                  JP       RIGHT1      ; Go and get sub-string
 3009                   ;
 3010 1427 EB           MID:       EX       DE,HL       ; Get code string addre
 3011 1428 7E                      LD       A,(HL)      ; Get next byte ',' or 
 3012 1429 CD8D14                  CALL     MIDNUM      ; Get number supplied
 3013 142C 04                      INC      B           ; Is it character zero?
 3014 142D 05                      DEC      B
 3015 142E CACB09                  JP       Z,FCERR     ; Yes - Error
 3016 1431 C5                      PUSH     BC          ; Save starting positio
 3017 1432 1EFF                    LD       E,255       ; All of string
 3018 1434 FE29                    CP       ')'         ; Any length given?
 3019 1436 CA4014                  JP       Z,RSTSTR    ; No - Rest of string
 3020 1439 CD6C07                  CALL     CHKSYN      ; Make sure ',' follows
 3021 143C 2C                      DB       ','
 3022 143D CDD514                  CALL     GETINT      ; Get integer 0-255
 3023 1440 CD6C07       RSTSTR:    CALL     CHKSYN      ; Make sure ")" follows
 3024 1443 29                      DB       ")"
 3025 1444 F1                      POP      AF          ; Restore starting posi
 3026 1445 E3                      EX       (SP),HL     ; Get string,8ave code 
 3027 1446 01F313                  LD       BC,MID1     ; Continuation of MID$ 
 3028 1449 C5                      PUSH     BC          ; Save for return
 3029 144A 3D                      DEC      A           ; Starting position-1
 3030 144B BE                      CP       (HL)        ; Compare with length
 3031 144C 0600                    LD       B,0         ; Zero bytes length
 3032 144E D0                      RET      NC          ; Null string if start 
 3033 144F 4F                      LD       C,A         ; Save starting positio
 3034 1450 7E                      LD       A,(HL)      ; Get length of string
 3035 1451 91                      SUB      C           ; Subtract start
 3036 1452 BB                      CP       E           ; Enough string for it?
 3037 1453 47                      LD       B,A         ; Save maximum length a
 3038 1454 D8                      RET      C           ; Truncate string if ne
 3039 1455 43                      LD       B,E         ; Set specified length
 3040 1456 C9                      RET                  ; Go and create string
 3041                   ;
 3042 1457 CDC113       VAL:       CALL     GETLEN      ; Get length of string
 3043 145A CA7615                  JP       Z,RESZER    ; Result zero
 3044 145D 5F                      LD       E,A         ; Save length
 3045 145E 23                      INC      HL
 3046 145F 23                      INC      HL
 3047 1460 7E                      LD       A,(HL)      ; Get LSB of address
 3048 1461 23                      INC      HL
 3049 1462 66                      LD       H,(HL)      ; Get MSB of address
 3050 1463 6F                      LD       L,A         ; HL = String address
 3051 1464 E5                      PUSH     HL          ; Save string address
 3052 1465 19                      ADD      HL,DE
 3053 1466 46                      LD       B,(HL)      ; Get end of string+1 b
 3054 1467 72                      LD       (HL),D      ; Zero it to terminate
 3055 1468 E3                      EX       (SP),HL     ; Save string end,get s
 3056 1469 C5                      PUSH     BC          ; Save end+1 byte
 3057 146A 7E                      LD       A,(HL)      ; Get starting byte
 3058 146B FE24                    CP       '$'         ; Hex number indicated?
 3059 146D C27614                  JP       NZ,VAL1
 3060 1470 CDA71C                  CALL     HEXTFP      ; Convert Hex to FPREG
 3061 1473 C38414                  JP       VAL3
 3062 1476 FE25         VAL1:      CP       '%'         ; Binary number indicat
 3063 1478 C28114                  JP       NZ,VAL2
 3064 147B CD231D                  CALL     BINTFP      ; Convert Bin to FPREG
 3065 147E C38414                  JP       VAL3
 3066 1481 CD5D18       VAL2:      CALL     ASCTFP      ; Convert ASCII string 
 3067 1484 C1           VAL3:      POP      BC          ; Restore end+1 byte
 3068 1485 E1                      POP      HL          ; Restore end+1 address
 3069 1486 70                      LD       (HL),B      ; Put back original byt
 3070 1487 C9                      RET
 3071                   ;
 3072 1488 EB           LFRGNM:    EX       DE,HL       ; Code string address t
 3073 1489 CD6C07                  CALL     CHKSYN      ; Make sure ")" follows
 3074 148C 29                      DB       ")"
 3075 148D C1           MIDNUM:    POP      BC          ; Get return address
 3076 148E D1                      POP      DE          ; Get number supplied
 3077 148F C5                      PUSH     BC          ; Re-save return addres
 3078 1490 43                      LD       B,E         ; Number to B
 3079 1491 C9                      RET
 3080                   ;
 3081 1492 CDD814       INP:       CALL     MAKINT      ; Make it integer A
 3082 1495 328480                  LD       (INPORT),A  ; Set input port
 3083 1498 CD8380                  CALL     INPSUB      ; Get input from port
 3084 149B C33C11                  JP       PASSA       ; Return integer A
 3085                   ;
 3086 149E CDC214       POUT:      CALL     SETIO       ; Set up port number
 3087 14A1 C34B80                  JP       OUTSUB      ; Output data and retur
 3088                   ;
 3089 14A4 CDC214       WAIT:      CALL     SETIO       ; Set up port number
 3090 14A7 F5                      PUSH     AF          ; Save AND mask
 3091 14A8 1E00                    LD       E,0         ; Assume zero if none g
 3092 14AA 2B                      DEC      HL          ; DEC 'cos GETCHR INCs
 3093 14AB CDFA08                  CALL     GETCHR      ; Get next character
 3094 14AE CAB814                  JP       Z,NOXOR     ; No XOR byte given
 3095 14B1 CD6C07                  CALL     CHKSYN      ; Make sure ',' follows
 3096 14B4 2C                      DB       ','
 3097 14B5 CDD514                  CALL     GETINT      ; Get integer 0-255 to 
 3098 14B8 C1           NOXOR:     POP      BC          ; Restore AND mask
 3099 14B9 CD8380       WAITLP:    CALL     INPSUB      ; Get input
 3100 14BC AB                      XOR      E           ; Flip selected bits
 3101 14BD A0                      AND      B           ; Result non-zero?
 3102 14BE CAB914                  JP       Z,WAITLP    ; No = keep waiting
 3103 14C1 C9                      RET
 3104                   ;
 3105 14C2 CDD514       SETIO:     CALL     GETINT      ; Get integer 0-255
 3106 14C5 328480                  LD       (INPORT),A  ; Set input port
 3107 14C8 324C80                  LD       (OTPORT),A  ; Set output port
 3108 14CB CD6C07                  CALL     CHKSYN      ; Make sure ',' follows
 3109 14CE 2C                      DB       ','
 3110 14CF C3D514                  JP       GETINT      ; Get integer 0-255 and
 3111                   ;
 3112 14D2 CDFA08       FNDNUM:    CALL     GETCHR      ; Get next character
 3113 14D5 CD710D       GETINT:    CALL     GETNUM      ; Get a number from 0 t
 3114 14D8 CDB009       MAKINT:    CALL     DEPINT      ; Make sure value 0 - 2
 3115 14DB 7A                      LD       A,D         ; Get MSB of number
 3116 14DC B7                      OR       A           ; Zero?
 3117 14DD C2CB09                  JP       NZ,FCERR    ; No - Error
 3118 14E0 2B                      DEC      HL          ; DEC 'cos GETCHR INCs
 3119 14E1 CDFA08                  CALL     GETCHR      ; Get next character
 3120 14E4 7B                      LD       A,E         ; Get number to A
 3121 14E5 C9                      RET
 3122                   ;
 3123 14E6 CDB609       PEEK:      CALL     DEINT       ; Get memory address
 3124 14E9 1A                      LD       A,(DE)      ; Get byte in memory
 3125 14EA C33C11                  JP       PASSA       ; Return integer A
 3126                   ;
 3127 14ED CD710D       POKE:      CALL     GETNUM      ; Get memory address
 3128 14F0 CDB609                  CALL     DEINT       ; Get integer -32768 to
 3129 14F3 D5                      PUSH     DE          ; Save memory address
 3130 14F4 CD6C07                  CALL     CHKSYN      ; Make sure ',' follows
 3131 14F7 2C                      DB       ','
 3132 14F8 CDD514                  CALL     GETINT      ; Get integer 0-255
 3133 14FB D1                      POP      DE          ; Restore memory addres
 3134 14FC 12                      LD       (DE),A      ; Load it into memory
 3135 14FD C9                      RET
 3136                   ;
 3137 14FE 21D419       ROUND:     LD       HL,HALF     ; Add 0.5 to FPREG
 3138 1501 CDA517       ADDPHL:    CALL     LOADFP      ; Load FP at (HL) to BC
 3139 1504 C31015                  JP       FPADD       ; Add BCDE to FPREG
 3140                   ;
 3141 1507 CDA517       SUBPHL:    CALL     LOADFP      ; FPREG = -FPREG + numb
 3142 150A 21                      DB       21H         ; Skip "POP BC" and "PO
 3143 150B C1           PSUB:      POP      BC          ; Get FP number from st
 3144 150C D1                      POP      DE
 3145 150D CD7F17       SUBCDE:    CALL     INVSGN      ; Negate FPREG
 3146 1510 78           FPADD:     LD       A,B         ; Get FP exponent
 3147 1511 B7                      OR       A           ; Is number zero?
 3148 1512 C8                      RET      Z           ; Yes - Nothing to add
 3149 1513 3A2C81                  LD       A,(FPEXP)   ; Get FPREG exponent
 3150 1516 B7                      OR       A           ; Is this number zero?
 3151 1517 CA9717                  JP       Z,FPBCDE    ; Yes - Move BCDE to FP
 3152 151A 90                      SUB      B           ; BCDE number larger?
 3153 151B D22A15                  JP       NC,NOSWAP   ; No - Don't swap them
 3154 151E 2F                      CPL                  ; Two's complement
 3155 151F 3C                      INC      A           ;       FP exponent
 3156 1520 EB                      EX       DE,HL
 3157 1521 CD8717                  CALL     STAKFP      ; Put FPREG on stack
 3158 1524 EB                      EX       DE,HL
 3159 1525 CD9717                  CALL     FPBCDE      ; Move BCDE to FPREG
 3160 1528 C1                      POP      BC          ; Restore number from s
 3161 1529 D1                      POP      DE
 3162 152A FE19         NOSWAP:    CP       24+1        ; Second number insigni
 3163 152C D0                      RET      NC          ; Yes - First number is
 3164 152D F5                      PUSH     AF          ; Save number of bits t
 3165 152E CDBC17                  CALL     SIGNS       ; Set MSBs & sign of re
 3166 1531 67                      LD       H,A         ; Save sign of result
 3167 1532 F1                      POP      AF          ; Restore scaling facto
 3168 1533 CDD515                  CALL     SCALE       ; Scale BCDE to same ex
 3169 1536 B4                      OR       H           ; Result to be positive
 3170 1537 212981                  LD       HL,FPREG    ; Point to FPREG
 3171 153A F25015                  JP       P,MINCDE    ; No - Subtract FPREG f
 3172 153D CDB515                  CALL     PLUCDE      ; Add FPREG to CDE
 3173 1540 D29615                  JP       NC,RONDUP   ; No overflow - Round i
 3174 1543 23                      INC      HL          ; Point to exponent
 3175 1544 34                      INC      (HL)        ; Increment it
 3176 1545 CAAD04                  JP       Z,OVERR     ; Number overflowed - E
 3177 1548 2E01                    LD       L,1         ; 1 bit to shift right
 3178 154A CDEB15                  CALL     SHRT1       ; Shift result right
 3179 154D C39615                  JP       RONDUP      ; Round it up
 3180                   ;
 3181 1550 AF           MINCDE:    XOR      A           ; Clear A and carry
 3182 1551 90                      SUB      B           ; Negate exponent
 3183 1552 47                      LD       B,A         ; Re-save exponent
 3184 1553 7E                      LD       A,(HL)      ; Get LSB of FPREG
 3185 1554 9B                      SBC      A, E        ; Subtract LSB of BCDE
 3186 1555 5F                      LD       E,A         ; Save LSB of BCDE
 3187 1556 23                      INC      HL
 3188 1557 7E                      LD       A,(HL)      ; Get NMSB of FPREG
 3189 1558 9A                      SBC      A,D         ; Subtract NMSB of BCDE
 3190 1559 57                      LD       D,A         ; Save NMSB of BCDE
 3191 155A 23                      INC      HL
 3192 155B 7E                      LD       A,(HL)      ; Get MSB of FPREG
 3193 155C 99                      SBC      A,C         ; Subtract MSB of BCDE
 3194 155D 4F                      LD       C,A         ; Save MSB of BCDE
 3195 155E DCC115       CONPOS:    CALL     C,COMPL     ; Overflow - Make it po
 3196                   ;
 3197 1561 68           BNORM:     LD       L,B         ; L = Exponent
 3198 1562 63                      LD       H,E         ; H = LSB
 3199 1563 AF                      XOR      A
 3200 1564 47           BNRMLP:    LD       B,A         ; Save bit count
 3201 1565 79                      LD       A,C         ; Get MSB
 3202 1566 B7                      OR       A           ; Is it zero?
 3203 1567 C28315                  JP       NZ,PNORM    ; No - Do it bit at a t
 3204 156A 4A                      LD       C,D         ; MSB = NMSB
 3205 156B 54                      LD       D,H         ; NMSB= LSB
 3206 156C 65                      LD       H,L         ; LSB = VLSB
 3207 156D 6F                      LD       L,A         ; VLSB= 0
 3208 156E 78                      LD       A,B         ; Get exponent
 3209 156F D608                    SUB      8           ; Count 8 bits
 3210 1571 FEE0                    CP       0E0H        ; -24-8 Was number zero
 3211 1573 C26415                  JP       NZ,BNRMLP   ; No - Keep normalising
 3212 1576 AF           RESZER:    XOR      A           ; Result is zero
 3213 1577 322C81       SAVEXP:    LD       (FPEXP),A   ; Save result as zero
 3214 157A C9                      RET
 3215                   ;
 3216 157B 05           NORMAL:    DEC      B           ; Count bits
 3217 157C 29                      ADD      HL,HL       ; Shift HL left
 3218 157D 7A                      LD       A,D         ; Get NMSB
 3219 157E 17                      RLA                  ; Shift left with last 
 3220 157F 57                      LD       D,A         ; Save NMSB
 3221 1580 79                      LD       A,C         ; Get MSB
 3222 1581 8F                      ADC      A,A         ; Shift left with last 
 3223 1582 4F                      LD       C,A         ; Save MSB
 3224 1583 F27B15       PNORM:     JP       P,NORMAL    ; Not done - Keep going
 3225 1586 78                      LD       A,B         ; Number of bits shifte
 3226 1587 5C                      LD       E,H         ; Save HL in EB
 3227 1588 45                      LD       B,L
 3228 1589 B7                      OR       A           ; Any shifting done?
 3229 158A CA9615                  JP       Z,RONDUP    ; No - Round it up
 3230 158D 212C81                  LD       HL,FPEXP    ; Point to exponent
 3231 1590 86                      ADD      A,(HL)      ; Add shifted bits
 3232 1591 77                      LD       (HL),A      ; Re-save exponent
 3233 1592 D27615                  JP       NC,RESZER   ; Underflow - Result is
 3234 1595 C8                      RET      Z           ; Result is zero
 3235 1596 78           RONDUP:    LD       A,B         ; Get VLSB of number
 3236 1597 212C81       RONDB:     LD       HL,FPEXP    ; Point to exponent
 3237 159A B7                      OR       A           ; Any rounding?
 3238 159B FCA815                  CALL     M,FPROND    ; Yes - Round number up
 3239 159E 46                      LD       B,(HL)      ; B = Exponent
 3240 159F 23                      INC      HL
 3241 15A0 7E                      LD       A,(HL)      ; Get sign of result
 3242 15A1 E680                    AND      10000000B   ; Only bit 7 needed
 3243 15A3 A9                      XOR      C           ; Set correct sign
 3244 15A4 4F                      LD       C,A         ; Save correct sign in 
 3245 15A5 C39717                  JP       FPBCDE      ; Move BCDE to FPREG
 3246                   ;
 3247 15A8 1C           FPROND:    INC      E           ; Round LSB
 3248 15A9 C0                      RET      NZ          ; Return if ok
 3249 15AA 14                      INC      D           ; Round NMSB
 3250 15AB C0                      RET      NZ          ; Return if ok
 3251 15AC 0C                      INC      C           ; Round MSB
 3252 15AD C0                      RET      NZ          ; Return if ok
 3253 15AE 0E80                    LD       C,80H       ; Set normal value
 3254 15B0 34                      INC      (HL)        ; Increment exponent
 3255 15B1 C0                      RET      NZ          ; Return if ok
 3256 15B2 C3AD04                  JP       OVERR       ; Overflow error
 3257                   ;
 3258 15B5 7E           PLUCDE:    LD       A,(HL)      ; Get LSB of FPREG
 3259 15B6 83                      ADD      A,E         ; Add LSB of BCDE
 3260 15B7 5F                      LD       E,A         ; Save LSB of BCDE
 3261 15B8 23                      INC      HL
 3262 15B9 7E                      LD       A,(HL)      ; Get NMSB of FPREG
 3263 15BA 8A                      ADC      A,D         ; Add NMSB of BCDE
 3264 15BB 57                      LD       D,A         ; Save NMSB of BCDE
 3265 15BC 23                      INC      HL
 3266 15BD 7E                      LD       A,(HL)      ; Get MSB of FPREG
 3267 15BE 89                      ADC      A,C         ; Add MSB of BCDE
 3268 15BF 4F                      LD       C,A         ; Save MSB of BCDE
 3269 15C0 C9                      RET
 3270                   ;
 3271 15C1 212D81       COMPL:     LD       HL,SGNRES   ; Sign of result
 3272 15C4 7E                      LD       A,(HL)      ; Get sign of result
 3273 15C5 2F                      CPL                  ; Negate it
 3274 15C6 77                      LD       (HL),A      ; Put it back
 3275 15C7 AF                      XOR      A
 3276 15C8 6F                      LD       L,A         ; Set L to zero
 3277 15C9 90                      SUB      B           ; Negate exponent,set c
 3278 15CA 47                      LD       B,A         ; Re-save exponent
 3279 15CB 7D                      LD       A,L         ; Load zero
 3280 15CC 9B                      SBC      A,E         ; Negate LSB
 3281 15CD 5F                      LD       E,A         ; Re-save LSB
 3282 15CE 7D                      LD       A,L         ; Load zero
 3283 15CF 9A                      SBC      A,D         ; Negate NMSB
 3284 15D0 57                      LD       D,A         ; Re-save NMSB
 3285 15D1 7D                      LD       A,L         ; Load zero
 3286 15D2 99                      SBC      A,C         ; Negate MSB
 3287 15D3 4F                      LD       C,A         ; Re-save MSB
 3288 15D4 C9                      RET
 3289                   ;
 3290 15D5 0600         SCALE:     LD       B,0         ; Clear underflow
 3291 15D7 D608         SCALLP:    SUB      8           ; 8 bits (a whole byte)
 3292 15D9 DAE415                  JP       C,SHRITE    ; No - Shift right A bi
 3293 15DC 43                      LD       B,E         ; <- Shift
 3294 15DD 5A                      LD       E,D         ; <- right
 3295 15DE 51                      LD       D,C         ; <- eight
 3296 15DF 0E00                    LD       C,0         ; <- bits
 3297 15E1 C3D715                  JP       SCALLP      ; More bits to shift
 3298                   ;
 3299 15E4 C609         SHRITE:    ADD      A,8+1       ; Adjust count
 3300 15E6 6F                      LD       L,A         ; Save bits to shift
 3301 15E7 AF           SHRLP:     XOR      A           ; Flag for all done
 3302 15E8 2D                      DEC      L           ; All shifting done?
 3303 15E9 C8                      RET      Z           ; Yes - Return
 3304 15EA 79                      LD       A,C         ; Get MSB
 3305 15EB 1F           SHRT1:     RRA                  ; Shift it right
 3306 15EC 4F                      LD       C,A         ; Re-save
 3307 15ED 7A                      LD       A,D         ; Get NMSB
 3308 15EE 1F                      RRA                  ; Shift right with last
 3309 15EF 57                      LD       D,A         ; Re-save it
 3310 15F0 7B                      LD       A,E         ; Get LSB
 3311 15F1 1F                      RRA                  ; Shift right with last
 3312 15F2 5F                      LD       E,A         ; Re-save it
 3313 15F3 78                      LD       A,B         ; Get underflow
 3314 15F4 1F                      RRA                  ; Shift right with last
 3315 15F5 47                      LD       B,A         ; Re-save underflow
 3316 15F6 C3E715                  JP       SHRLP       ; More bits to do
 3317                   ;
 3318 15F9 00000081     UNITY:     DB       000H,000H,000H,081H ; 1.00000
 3319                   ;
 3320 15FD 03           LOGTAB:    DB       3           ; Table used by LOG
 3321 15FE AA561980                DB       0AAH,056H,019H,080H ; 0.59898
 3322 1602 F1227680                DB       0F1H,022H,076H,080H ; 0.96147
 3323 1606 45AA3882                DB       045H,0AAH,038H,082H ; 2.88539
 3324                   ;
 3325 160A CD5617       LOG:       CALL     TSTSGN      ; Test sign of value
 3326 160D B7                      OR       A
 3327 160E EACB09                  JP       PE,FCERR    ; ?FC Error if <= zero
 3328 1611 212C81                  LD       HL,FPEXP    ; Point to exponent
 3329 1614 7E                      LD       A,(HL)      ; Get exponent
 3330 1615 013580                  LD       BC,8035H    ; BCDE = SQR(1/2)
 3331 1618 11F304                  LD       DE,04F3H
 3332 161B 90                      SUB      B           ; Scale value to be < 1
 3333 161C F5                      PUSH     AF          ; Save scale factor
 3334 161D 70                      LD       (HL),B      ; Save new exponent
 3335 161E D5                      PUSH     DE          ; Save SQR(1/2)
 3336 161F C5                      PUSH     BC
 3337 1620 CD1015                  CALL     FPADD       ; Add SQR(1/2) to value
 3338 1623 C1                      POP      BC          ; Restore SQR(1/2)
 3339 1624 D1                      POP      DE
 3340 1625 04                      INC      B           ; Make it SQR(2)
 3341 1626 CDAC16                  CALL     DVBCDE      ; Divide by SQR(2)
 3342 1629 21F915                  LD       HL,UNITY    ; Point to 1.
 3343 162C CD0715                  CALL     SUBPHL      ; Subtract FPREG from 1
 3344 162F 21FD15                  LD       HL,LOGTAB   ; Coefficient table
 3345 1632 CD9E1A                  CALL     SUMSER      ; Evaluate sum of serie
 3346 1635 018080                  LD       BC,8080H    ; BCDE = -0.5
 3347 1638 110000                  LD       DE,0000H
 3348 163B CD1015                  CALL     FPADD       ; Subtract 0.5 from FPR
 3349 163E F1                      POP      AF          ; Restore scale factor
 3350 163F CDD118                  CALL     RSCALE      ; Re-scale number
 3351 1642 013180       MULLN2:    LD       BC,8031H    ; BCDE = Ln(2)
 3352 1645 111872                  LD       DE,7218H
 3353 1648 21                      DB       21H         ; Skip "POP BC" and "PO
 3354                   ;
 3355 1649 C1           MULT:      POP      BC          ; Get number from stack
 3356 164A D1                      POP      DE
 3357 164B CD5617       FPMULT:    CALL     TSTSGN      ; Test sign of FPREG
 3358 164E C8                      RET      Z           ; Return zero if zero
 3359 164F 2E00                    LD       L,0         ; Flag add exponents
 3360 1651 CD1417                  CALL     ADDEXP      ; Add exponents
 3361 1654 79                      LD       A,C         ; Get MSB of multiplier
 3362 1655 323B81                  LD       (MULVAL),A  ; Save MSB of multiplie
 3363 1658 EB                      EX       DE,HL
 3364 1659 223C81                  LD       (MULVAL+1),HL ; Save rest of multip
 3365 165C 010000                  LD       BC,0        ; Partial product (BCDE
 3366 165F 50                      LD       D,B
 3367 1660 58                      LD       E,B
 3368 1661 216115                  LD       HL,BNORM    ; Address of normalise
 3369 1664 E5                      PUSH     HL          ; Save for return
 3370 1665 216D16                  LD       HL,MULT8    ; Address of 8 bit mult
 3371 1668 E5                      PUSH     HL          ; Save for NMSB,MSB
 3372 1669 E5                      PUSH     HL          ;
 3373 166A 212981                  LD       HL,FPREG    ; Point to number
 3374 166D 7E           MULT8:     LD       A,(HL)      ; Get LSB of number
 3375 166E 23                      INC      HL          ; Point to NMSB
 3376 166F B7                      OR       A           ; Test LSB
 3377 1670 CA9916                  JP       Z,BYTSFT    ; Zero - shift to next 
 3378 1673 E5                      PUSH     HL          ; Save address of numbe
 3379 1674 2E08                    LD       L,8         ; 8 bits to multiply by
 3380 1676 1F           MUL8LP:    RRA                  ; Shift LSB right
 3381 1677 67                      LD       H,A         ; Save LSB
 3382 1678 79                      LD       A,C         ; Get MSB
 3383 1679 D28716                  JP       NC,NOMADD   ; Bit was zero - Don't 
 3384 167C E5                      PUSH     HL          ; Save LSB and count
 3385 167D 2A3C81                  LD       HL,(MULVAL+1) ; Get LSB and NMSB
 3386 1680 19                      ADD      HL,DE       ; Add NMSB and LSB
 3387 1681 EB                      EX       DE,HL       ; Leave sum in DE
 3388 1682 E1                      POP      HL          ; Restore MSB and count
 3389 1683 3A3B81                  LD       A,(MULVAL)  ; Get MSB of multiplier
 3390 1686 89                      ADC      A,C         ; Add MSB
 3391 1687 1F           NOMADD:    RRA                  ; Shift MSB right
 3392 1688 4F                      LD       C,A         ; Re-save MSB
 3393 1689 7A                      LD       A,D         ; Get NMSB
 3394 168A 1F                      RRA                  ; Shift NMSB right
 3395 168B 57                      LD       D,A         ; Re-save NMSB
 3396 168C 7B                      LD       A,E         ; Get LSB
 3397 168D 1F                      RRA                  ; Shift LSB right
 3398 168E 5F                      LD       E,A         ; Re-save LSB
 3399 168F 78                      LD       A,B         ; Get VLSB
 3400 1690 1F                      RRA                  ; Shift VLSB right
 3401 1691 47                      LD       B,A         ; Re-save VLSB
 3402 1692 2D                      DEC      L           ; Count bits multiplied
 3403 1693 7C                      LD       A,H         ; Get LSB of multiplier
 3404 1694 C27616                  JP       NZ,MUL8LP   ; More - Do it
 3405 1697 E1           POPHRT:    POP      HL          ; Restore address of nu
 3406 1698 C9                      RET
 3407                   ;
 3408 1699 43           BYTSFT:    LD       B,E         ; Shift partial product
 3409 169A 5A                      LD       E,D
 3410 169B 51                      LD       D,C
 3411 169C 4F                      LD       C,A
 3412 169D C9                      RET
 3413                   ;
 3414 169E CD8717       DIV10:     CALL     STAKFP      ; Save FPREG on stack
 3415 16A1 012084                  LD       BC,8420H    ; BCDE = 10.
 3416 16A4 110000                  LD       DE,0000H
 3417 16A7 CD9717                  CALL     FPBCDE      ; Move 10 to FPREG
 3418                   ;
 3419 16AA C1           DIV:       POP      BC          ; Get number from stack
 3420 16AB D1                      POP      DE
 3421 16AC CD5617       DVBCDE:    CALL     TSTSGN      ; Test sign of FPREG
 3422 16AF CAA104                  JP       Z,DZERR     ; Error if division by 
 3423 16B2 2EFF                    LD       L,-1        ; Flag subtract exponen
 3424 16B4 CD1417                  CALL     ADDEXP      ; Subtract exponents
 3425 16B7 34                      INC      (HL)        ; Add 2 to exponent to 
 3426 16B8 34                      INC      (HL)
 3427 16B9 2B                      DEC      HL          ; Point to MSB
 3428 16BA 7E                      LD       A,(HL)      ; Get MSB of dividend
 3429 16BB 325780                  LD       (DIV3),A    ; Save for subtraction
 3430 16BE 2B                      DEC      HL
 3431 16BF 7E                      LD       A,(HL)      ; Get NMSB of dividend
 3432 16C0 325380                  LD       (DIV2),A    ; Save for subtraction
 3433 16C3 2B                      DEC      HL
 3434 16C4 7E                      LD       A,(HL)      ; Get MSB of dividend
 3435 16C5 324F80                  LD       (DIV1),A    ; Save for subtraction
 3436 16C8 41                      LD       B,C         ; Get MSB
 3437 16C9 EB                      EX       DE,HL       ; NMSB,LSB to HL
 3438 16CA AF                      XOR      A
 3439 16CB 4F                      LD       C,A         ; Clear MSB of quotient
 3440 16CC 57                      LD       D,A         ; Clear NMSB of quotien
 3441 16CD 5F                      LD       E,A         ; Clear LSB of quotient
 3442 16CE 325A80                  LD       (DIV4),A    ; Clear overflow count
 3443 16D1 E5           DIVLP:     PUSH     HL          ; Save divisor
 3444 16D2 C5                      PUSH     BC
 3445 16D3 7D                      LD       A,L         ; Get LSB of number
 3446 16D4 CD4E80                  CALL     DIVSUP      ; Subt' divisor from di
 3447 16D7 DE00                    SBC      A,0         ; Count for overflows
 3448 16D9 3F                      CCF
 3449 16DA D2E416                  JP       NC,RESDIV   ; Restore divisor if bo
 3450 16DD 325A80                  LD       (DIV4),A    ; Re-save overflow coun
 3451 16E0 F1                      POP      AF          ; Scrap divisor
 3452 16E1 F1                      POP      AF
 3453 16E2 37                      SCF                  ; Set carry to
 3454 16E3 D2                      DB       0D2H        ; Skip "POP BC" and "PO
 3455                   ;
 3456 16E4 C1           RESDIV:    POP      BC          ; Restore divisor
 3457 16E5 E1                      POP      HL
 3458 16E6 79                      LD       A,C         ; Get MSB of quotient
 3459 16E7 3C                      INC      A
 3460 16E8 3D                      DEC      A
 3461 16E9 1F                      RRA                  ; Bit 0 to bit 7
 3462 16EA FA9715                  JP       M,RONDB     ; Done - Normalise resu
 3463 16ED 17                      RLA                  ; Restore carry
 3464 16EE 7B                      LD       A,E         ; Get LSB of quotient
 3465 16EF 17                      RLA                  ; Double it
 3466 16F0 5F                      LD       E,A         ; Put it back
 3467 16F1 7A                      LD       A,D         ; Get NMSB of quotient
 3468 16F2 17                      RLA                  ; Double it
 3469 16F3 57                      LD       D,A         ; Put it back
 3470 16F4 79                      LD       A,C         ; Get MSB of quotient
 3471 16F5 17                      RLA                  ; Double it
 3472 16F6 4F                      LD       C,A         ; Put it back
 3473 16F7 29                      ADD      HL,HL       ; Double NMSB,LSB of di
 3474 16F8 78                      LD       A,B         ; Get MSB of divisor
 3475 16F9 17                      RLA                  ; Double it
 3476 16FA 47                      LD       B,A         ; Put it back
 3477 16FB 3A5A80                  LD       A,(DIV4)    ; Get VLSB of quotient
 3478 16FE 17                      RLA                  ; Double it
 3479 16FF 325A80                  LD       (DIV4),A    ; Put it back
 3480 1702 79                      LD       A,C         ; Get MSB of quotient
 3481 1703 B2                      OR       D           ; Merge NMSB
 3482 1704 B3                      OR       E           ; Merge LSB
 3483 1705 C2D116                  JP       NZ,DIVLP    ; Not done - Keep divid
 3484 1708 E5                      PUSH     HL          ; Save divisor
 3485 1709 212C81                  LD       HL,FPEXP    ; Point to exponent
 3486 170C 35                      DEC      (HL)        ; Divide by 2
 3487 170D E1                      POP      HL          ; Restore divisor
 3488 170E C2D116                  JP       NZ,DIVLP    ; Ok - Keep going
 3489 1711 C3AD04                  JP       OVERR       ; Overflow error
 3490                   ;
 3491 1714 78           ADDEXP:    LD       A,B         ; Get exponent of divid
 3492 1715 B7                      OR       A           ; Test it
 3493 1716 CA3817                  JP       Z,OVTST3    ; Zero - Result zero
 3494 1719 7D                      LD       A,L         ; Get add/subtract flag
 3495 171A 212C81                  LD       HL,FPEXP    ; Point to exponent
 3496 171D AE                      XOR      (HL)        ; Add or subtract it
 3497 171E 80                      ADD      A,B         ; Add the other exponen
 3498 171F 47                      LD       B,A         ; Save new exponent
 3499 1720 1F                      RRA                  ; Test exponent for ove
 3500 1721 A8                      XOR      B
 3501 1722 78                      LD       A,B         ; Get exponent
 3502 1723 F23717                  JP       P,OVTST2    ; Positive - Test for o
 3503 1726 C680                    ADD      A,80H       ; Add excess 128
 3504 1728 77                      LD       (HL),A      ; Save new exponent
 3505 1729 CA9716                  JP       Z,POPHRT    ; Zero - Result zero
 3506 172C CDBC17                  CALL     SIGNS       ; Set MSBs and sign of 
 3507 172F 77                      LD       (HL),A      ; Save new exponent
 3508 1730 2B                      DEC      HL          ; Point to MSB
 3509 1731 C9                      RET
 3510                   ;
 3511 1732 CD5617       OVTST1:    CALL     TSTSGN      ; Test sign of FPREG
 3512 1735 2F                      CPL                  ; Invert sign
 3513 1736 E1                      POP      HL          ; Clean up stack
 3514 1737 B7           OVTST2:    OR       A           ; Test if new exponent 
 3515 1738 E1           OVTST3:    POP      HL          ; Clear off return addr
 3516 1739 F27615                  JP       P,RESZER    ; Result zero
 3517 173C C3AD04                  JP       OVERR       ; Overflow error
 3518                   ;
 3519 173F CDA217       MLSP10:    CALL     BCDEFP      ; Move FPREG to BCDE
 3520 1742 78                      LD       A,B         ; Get exponent
 3521 1743 B7                      OR       A           ; Is it zero?
 3522 1744 C8                      RET      Z           ; Yes - Result is zero
 3523 1745 C602                    ADD      A,2         ; Multiply by 4
 3524 1747 DAAD04                  JP       C,OVERR     ; Overflow - ?OV Error
 3525 174A 47                      LD       B,A         ; Re-save exponent
 3526 174B CD1015                  CALL     FPADD       ; Add BCDE to FPREG (Ti
 3527 174E 212C81                  LD       HL,FPEXP    ; Point to exponent
 3528 1751 34                      INC      (HL)        ; Double number (Times 
 3529 1752 C0                      RET      NZ          ; Ok - Return
 3530 1753 C3AD04                  JP       OVERR       ; Overflow error
 3531                   ;
 3532 1756 3A2C81       TSTSGN:    LD       A,(FPEXP)   ; Get sign of FPREG
 3533 1759 B7                      OR       A
 3534 175A C8                      RET      Z           ; RETurn if number is z
 3535 175B 3A2B81                  LD       A,(FPREG+2) ; Get MSB of FPREG
 3536 175E FE                      DB       0FEH        ; Test sign
 3537 175F 2F           RETREL:    CPL                  ; Invert sign
 3538 1760 17                      RLA                  ; Sign bit to carry
 3539 1761 9F           FLGDIF:    SBC      A,A         ; Carry to all bits of 
 3540 1762 C0                      RET      NZ          ; Return -1 if negative
 3541 1763 3C                      INC      A           ; Bump to +1
 3542 1764 C9                      RET                  ; Positive - Return +1
 3543                   ;
 3544 1765 CD5617       SGN:       CALL     TSTSGN      ; Test sign of FPREG
 3545 1768 0688         FLGREL:    LD       B,80H+8     ; 8 bit integer in expo
 3546 176A 110000                  LD       DE,0        ; Zero NMSB and LSB
 3547 176D 212C81       RETINT:    LD       HL,FPEXP    ; Point to exponent
 3548 1770 4F                      LD       C,A         ; CDE = MSB,NMSB and LS
 3549 1771 70                      LD       (HL),B      ; Save exponent
 3550 1772 0600                    LD       B,0         ; CDE = integer to norm
 3551 1774 23                      INC      HL          ; Point to sign of resu
 3552 1775 3680                    LD       (HL),80H    ; Set sign of result
 3553 1777 17                      RLA                  ; Carry = sign of integ
 3554 1778 C35E15                  JP       CONPOS      ; Set sign of result
 3555                   ;
 3556 177B CD5617       ABS:       CALL     TSTSGN      ; Test sign of FPREG
 3557 177E F0                      RET      P           ; Return if positive
 3558 177F 212B81       INVSGN:    LD       HL,FPREG+2  ; Point to MSB
 3559 1782 7E                      LD       A,(HL)      ; Get sign of mantissa
 3560 1783 EE80                    XOR      80H         ; Invert sign of mantis
 3561 1785 77                      LD       (HL),A      ; Re-save sign of manti
 3562 1786 C9                      RET
 3563                   ;
 3564 1787 EB           STAKFP:    EX       DE,HL       ; Save code string addr
 3565 1788 2A2981                  LD       HL,(FPREG)  ; LSB,NLSB of FPREG
 3566 178B E3                      EX       (SP),HL     ; Stack them,get return
 3567 178C E5                      PUSH     HL          ; Re-save return
 3568 178D 2A2B81                  LD       HL,(FPREG+2) ; MSB and exponent of 
 3569 1790 E3                      EX       (SP),HL     ; Stack them,get return
 3570 1791 E5                      PUSH     HL          ; Re-save return
 3571 1792 EB                      EX       DE,HL       ; Restore code string a
 3572 1793 C9                      RET
 3573                   ;
 3574 1794 CDA517       PHLTFP:    CALL     LOADFP      ; Number at HL to BCDE
 3575 1797 EB           FPBCDE:    EX       DE,HL       ; Save code string addr
 3576 1798 222981                  LD       (FPREG),HL  ; Save LSB,NLSB of numb
 3577 179B 60                      LD       H,B         ; Exponent of number
 3578 179C 69                      LD       L,C         ; MSB of number
 3579 179D 222B81                  LD       (FPREG+2),HL ; Save MSB and exponen
 3580 17A0 EB                      EX       DE,HL       ; Restore code string a
 3581 17A1 C9                      RET
 3582                   ;
 3583 17A2 212981       BCDEFP:    LD       HL,FPREG    ; Point to FPREG
 3584 17A5 5E           LOADFP:    LD       E,(HL)      ; Get LSB of number
 3585 17A6 23                      INC      HL
 3586 17A7 56                      LD       D,(HL)      ; Get NMSB of number
 3587 17A8 23                      INC      HL
 3588 17A9 4E                      LD       C,(HL)      ; Get MSB of number
 3589 17AA 23                      INC      HL
 3590 17AB 46                      LD       B,(HL)      ; Get exponent of numbe
 3591 17AC 23           INCHL:     INC      HL          ; Used for conditional 
 3592 17AD C9                      RET
 3593                   ;
 3594 17AE 112981       FPTHL:     LD       DE,FPREG    ; Point to FPREG
 3595 17B1 0604         DETHL4:    LD       B,4         ; 4 bytes to move
 3596 17B3 1A           DETHLB:    LD       A,(DE)      ; Get source
 3597 17B4 77                      LD       (HL),A      ; Save destination
 3598 17B5 13                      INC      DE          ; Next source
 3599 17B6 23                      INC      HL          ; Next destination
 3600 17B7 05                      DEC      B           ; Count bytes
 3601 17B8 C2B317                  JP       NZ,DETHLB   ; Loop if more
 3602 17BB C9                      RET
 3603                   ;
 3604 17BC 212B81       SIGNS:     LD       HL,FPREG+2  ; Point to MSB of FPREG
 3605 17BF 7E                      LD       A,(HL)      ; Get MSB
 3606 17C0 07                      RLCA                 ; Old sign to carry
 3607 17C1 37                      SCF                  ; Set MSBit
 3608 17C2 1F                      RRA                  ; Set MSBit of MSB
 3609 17C3 77                      LD       (HL),A      ; Save new MSB
 3610 17C4 3F                      CCF                  ; Complement sign
 3611 17C5 1F                      RRA                  ; Old sign to carry
 3612 17C6 23                      INC      HL
 3613 17C7 23                      INC      HL
 3614 17C8 77                      LD       (HL),A      ; Set sign of result
 3615 17C9 79                      LD       A,C         ; Get MSB
 3616 17CA 07                      RLCA                 ; Old sign to carry
 3617 17CB 37                      SCF                  ; Set MSBit
 3618 17CC 1F                      RRA                  ; Set MSBit of MSB
 3619 17CD 4F                      LD       C,A         ; Save MSB
 3620 17CE 1F                      RRA
 3621 17CF AE                      XOR      (HL)        ; New sign of result
 3622 17D0 C9                      RET
 3623                   ;
 3624 17D1 78           CMPNUM:    LD       A,B         ; Get exponent of numbe
 3625 17D2 B7                      OR       A
 3626 17D3 CA5617                  JP       Z,TSTSGN    ; Zero - Test sign of F
 3627 17D6 215F17                  LD       HL,RETREL   ; Return relation routi
 3628 17D9 E5                      PUSH     HL          ; Save for return
 3629 17DA CD5617                  CALL     TSTSGN      ; Test sign of FPREG
 3630 17DD 79                      LD       A,C         ; Get MSB of number
 3631 17DE C8                      RET      Z           ; FPREG zero - Number's
 3632 17DF 212B81                  LD       HL,FPREG+2  ; MSB of FPREG
 3633 17E2 AE                      XOR      (HL)        ; Combine signs
 3634 17E3 79                      LD       A,C         ; Get MSB of number
 3635 17E4 F8                      RET      M           ; Exit if signs differe
 3636 17E5 CDEB17                  CALL     CMPFP       ; Compare FP numbers
 3637 17E8 1F                      RRA                  ; Get carry to sign
 3638 17E9 A9                      XOR      C           ; Combine with MSB of n
 3639 17EA C9                      RET
 3640                   ;
 3641 17EB 23           CMPFP:     INC      HL          ; Point to exponent
 3642 17EC 78                      LD       A,B         ; Get exponent
 3643 17ED BE                      CP       (HL)        ; Compare exponents
 3644 17EE C0                      RET      NZ          ; Different
 3645 17EF 2B                      DEC      HL          ; Point to MBS
 3646 17F0 79                      LD       A,C         ; Get MSB
 3647 17F1 BE                      CP       (HL)        ; Compare MSBs
 3648 17F2 C0                      RET      NZ          ; Different
 3649 17F3 2B                      DEC      HL          ; Point to NMSB
 3650 17F4 7A                      LD       A,D         ; Get NMSB
 3651 17F5 BE                      CP       (HL)        ; Compare NMSBs
 3652 17F6 C0                      RET      NZ          ; Different
 3653 17F7 2B                      DEC      HL          ; Point to LSB
 3654 17F8 7B                      LD       A,E         ; Get LSB
 3655 17F9 96                      SUB      (HL)        ; Compare LSBs
 3656 17FA C0                      RET      NZ          ; Different
 3657 17FB E1                      POP      HL          ; Drop RETurn
 3658 17FC E1                      POP      HL          ; Drop another RETurn
 3659 17FD C9                      RET
 3660                   ;
 3661 17FE 47           FPINT:     LD       B,A         ; <- Move
 3662 17FF 4F                      LD       C,A         ; <- exponent
 3663 1800 57                      LD       D,A         ; <- to all
 3664 1801 5F                      LD       E,A         ; <- bits
 3665 1802 B7                      OR       A           ; Test exponent
 3666 1803 C8                      RET      Z           ; Zero - Return zero
 3667 1804 E5                      PUSH     HL          ; Save pointer to numbe
 3668 1805 CDA217                  CALL     BCDEFP      ; Move FPREG to BCDE
 3669 1808 CDBC17                  CALL     SIGNS       ; Set MSBs & sign of re
 3670 180B AE                      XOR      (HL)        ; Combine with sign of 
 3671 180C 67                      LD       H,A         ; Save combined signs
 3672 180D FC2218                  CALL     M,DCBCDE    ; Negative - Decrement 
 3673 1810 3E98                    LD       A,80H+24    ; 24 bits
 3674 1812 90                      SUB      B           ; Bits to shift
 3675 1813 CDD515                  CALL     SCALE       ; Shift BCDE
 3676 1816 7C                      LD       A,H         ; Get combined sign
 3677 1817 17                      RLA                  ; Sign to carry
 3678 1818 DCA815                  CALL     C,FPROND    ; Negative - Round numb
 3679 181B 0600                    LD       B,0         ; Zero exponent
 3680 181D DCC115                  CALL     C,COMPL     ; If negative make posi
 3681 1820 E1                      POP      HL          ; Restore pointer to nu
 3682 1821 C9                      RET
 3683                   ;
 3684 1822 1B           DCBCDE:    DEC      DE          ; Decrement BCDE
 3685 1823 7A                      LD       A,D         ; Test LSBs
 3686 1824 A3                      AND      E
 3687 1825 3C                      INC      A
 3688 1826 C0                      RET      NZ          ; Exit if LSBs not FFFF
 3689 1827 0B                      DEC      BC          ; Decrement MSBs
 3690 1828 C9                      RET
 3691                   ;
 3692 1829 212C81       INT:       LD       HL,FPEXP    ; Point to exponent
 3693 182C 7E                      LD       A,(HL)      ; Get exponent
 3694 182D FE98                    CP       80H+24      ; Integer accuracy only
 3695 182F 3A2981                  LD       A,(FPREG)   ; Get LSB
 3696 1832 D0                      RET      NC          ; Yes - Already integer
 3697 1833 7E                      LD       A,(HL)      ; Get exponent
 3698 1834 CDFE17                  CALL     FPINT       ; F.P to integer
 3699 1837 3698                    LD       (HL),80H+24 ; Save 24 bit integer
 3700 1839 7B                      LD       A,E         ; Get LSB of number
 3701 183A F5                      PUSH     AF          ; Save LSB
 3702 183B 79                      LD       A,C         ; Get MSB of number
 3703 183C 17                      RLA                  ; Sign to carry
 3704 183D CD5E15                  CALL     CONPOS      ; Set sign of result
 3705 1840 F1                      POP      AF          ; Restore LSB of number
 3706 1841 C9                      RET
 3707                   ;
 3708 1842 210000       MLDEBC:    LD       HL,0        ; Clear partial product
 3709 1845 78                      LD       A,B         ; Test multiplier
 3710 1846 B1                      OR       C
 3711 1847 C8                      RET      Z           ; Return zero if zero
 3712 1848 3E10                    LD       A,16        ; 16 bits
 3713 184A 29           MLDBLP:    ADD      HL,HL       ; Shift P.P left
 3714 184B DA8010                  JP       C,BSERR     ; ?BS Error if overflow
 3715 184E EB                      EX       DE,HL
 3716 184F 29                      ADD      HL,HL       ; Shift multiplier left
 3717 1850 EB                      EX       DE,HL
 3718 1851 D25818                  JP       NC,NOMLAD   ; Bit was zero - No add
 3719 1854 09                      ADD      HL,BC       ; Add multiplicand
 3720 1855 DA8010                  JP       C,BSERR     ; ?BS Error if overflow
 3721 1858 3D           NOMLAD:    DEC      A           ; Count bits
 3722 1859 C24A18                  JP       NZ,MLDBLP   ; More
 3723 185C C9                      RET
 3724                   ;
 3725 185D FE2D         ASCTFP:    CP       '-'         ; Negative?
 3726 185F F5                      PUSH     AF          ; Save it and flags
 3727 1860 CA6918                  JP       Z,CNVNUM    ; Yes - Convert number
 3728 1863 FE2B                    CP       '+'         ; Positive?
 3729 1865 CA6918                  JP       Z,CNVNUM    ; Yes - Convert number
 3730 1868 2B                      DEC      HL          ; DEC 'cos GETCHR INCs
 3731 1869 CD7615       CNVNUM:    CALL     RESZER      ; Set result to zero
 3732 186C 47                      LD       B,A         ; Digits after point co
 3733 186D 57                      LD       D,A         ; Sign of exponent
 3734 186E 5F                      LD       E,A         ; Exponent of ten
 3735 186F 2F                      CPL
 3736 1870 4F                      LD       C,A         ; Before or after point
 3737 1871 CDFA08       MANLP:     CALL     GETCHR      ; Get next character
 3738 1874 DABA18                  JP       C,ADDIG     ; Digit - Add to number
 3739 1877 FE2E                    CP       '.'
 3740 1879 CA9518                  JP       Z,DPOINT    ; '.' - Flag point
 3741 187C FE45                    CP       'E'
 3742 187E C29918                  JP       NZ,CONEXP   ; Not 'E' - Scale numbe
 3743 1881 CDFA08                  CALL     GETCHR      ; Get next character
 3744 1884 CDAB0E                  CALL     SGNEXP      ; Get sign of exponent
 3745 1887 CDFA08       EXPLP:     CALL     GETCHR      ; Get next character
 3746 188A DADC18                  JP       C,EDIGIT    ; Digit - Add to expone
 3747 188D 14                      INC      D           ; Is sign negative?
 3748 188E C29918                  JP       NZ,CONEXP   ; No - Scale number
 3749 1891 AF                      XOR      A
 3750 1892 93                      SUB      E           ; Negate exponent
 3751 1893 5F                      LD       E,A         ; And re-save it
 3752 1894 0C                      INC      C           ; Flag end of number
 3753 1895 0C           DPOINT:    INC      C           ; Flag point passed
 3754 1896 CA7118                  JP       Z,MANLP     ; Zero - Get another di
 3755 1899 E5           CONEXP:    PUSH     HL          ; Save code string addr
 3756 189A 7B                      LD       A,E         ; Get exponent
 3757 189B 90                      SUB      B           ; Subtract digits after
 3758 189C F4B218       SCALMI:    CALL     P,SCALPL    ; Positive - Multiply n
 3759 189F F2A818                  JP       P,ENDCON    ; Positive - All done
 3760 18A2 F5                      PUSH     AF          ; Save number of times 
 3761 18A3 CD9E16                  CALL     DIV10       ; Divide by 10
 3762 18A6 F1                      POP      AF          ; Restore count
 3763 18A7 3C                      INC      A           ; Count divides
 3764                   ;
 3765 18A8 C29C18       ENDCON:    JP       NZ,SCALMI   ; More to do
 3766 18AB D1                      POP      DE          ; Restore code string a
 3767 18AC F1                      POP      AF          ; Restore sign of numbe
 3768 18AD CC7F17                  CALL     Z,INVSGN    ; Negative - Negate num
 3769 18B0 EB                      EX       DE,HL       ; Code string address t
 3770 18B1 C9                      RET
 3771                   ;
 3772 18B2 C8           SCALPL:    RET      Z           ; Exit if no scaling ne
 3773 18B3 F5           MULTEN:    PUSH     AF          ; Save count
 3774 18B4 CD3F17                  CALL     MLSP10      ; Multiply number by 10
 3775 18B7 F1                      POP      AF          ; Restore count
 3776 18B8 3D                      DEC      A           ; Count multiplies
 3777 18B9 C9                      RET
 3778                   ;
 3779 18BA D5           ADDIG:     PUSH     DE          ; Save sign of exponent
 3780 18BB 57                      LD       D,A         ; Save digit
 3781 18BC 78                      LD       A,B         ; Get digits after poin
 3782 18BD 89                      ADC      A,C         ; Add one if after poin
 3783 18BE 47                      LD       B,A         ; Re-save counter
 3784 18BF C5                      PUSH     BC          ; Save point flags
 3785 18C0 E5                      PUSH     HL          ; Save code string addr
 3786 18C1 D5                      PUSH     DE          ; Save digit
 3787 18C2 CD3F17                  CALL     MLSP10      ; Multiply number by 10
 3788 18C5 F1                      POP      AF          ; Restore digit
 3789 18C6 D630                    SUB      '0'         ; Make it absolute
 3790 18C8 CDD118                  CALL     RSCALE      ; Re-scale number
 3791 18CB E1                      POP      HL          ; Restore code string a
 3792 18CC C1                      POP      BC          ; Restore point flags
 3793 18CD D1                      POP      DE          ; Restore sign of expon
 3794 18CE C37118                  JP       MANLP       ; Get another digit
 3795                   ;
 3796 18D1 CD8717       RSCALE:    CALL     STAKFP      ; Put number on stack
 3797 18D4 CD6817                  CALL     FLGREL      ; Digit to add to FPREG
 3798 18D7 C1           PADD:      POP      BC          ; Restore number
 3799 18D8 D1                      POP      DE
 3800 18D9 C31015                  JP       FPADD       ; Add BCDE to FPREG and
 3801                   ;
 3802 18DC 7B           EDIGIT:    LD       A,E         ; Get digit
 3803 18DD 07                      RLCA                 ; Times 2
 3804 18DE 07                      RLCA                 ; Times 4
 3805 18DF 83                      ADD      A,E         ; Times 5
 3806 18E0 07                      RLCA                 ; Times 10
 3807 18E1 86                      ADD      A,(HL)      ; Add next digit
 3808 18E2 D630                    SUB      '0'         ; Make it absolute
 3809 18E4 5F                      LD       E,A         ; Save new digit
 3810 18E5 C38718                  JP       EXPLP       ; Look for another digi
 3811                   ;
 3812 18E8 E5           LINEIN:    PUSH     HL          ; Save code string addr
 3813 18E9 213604                  LD       HL,INMSG    ; Output " in "
 3814 18EC CD4B12                  CALL     PRS         ; Output string at HL
 3815 18EF E1                      POP      HL          ; Restore code string a
 3816 18F0 EB           PRNTHL:    EX       DE,HL       ; Code string address t
 3817 18F1 AF                      XOR      A
 3818 18F2 0698                    LD       B,80H+24    ; 24 bits
 3819 18F4 CD6D17                  CALL     RETINT      ; Return the integer
 3820 18F7 214A12                  LD       HL,PRNUMS   ; Print number string
 3821 18FA E5                      PUSH     HL          ; Save for return
 3822 18FB 212E81       NUMASC:    LD       HL,PBUFF    ; Convert number to ASC
 3823 18FE E5                      PUSH     HL          ; Save for return
 3824 18FF CD5617                  CALL     TSTSGN      ; Test sign of FPREG
 3825 1902 3620                    LD       (HL),' '    ; Space at start
 3826 1904 F20919                  JP       P,SPCFST    ; Positive - Space to s
 3827 1907 362D                    LD       (HL),'-'    ; '-' sign at start
 3828 1909 23           SPCFST:    INC      HL          ; First byte of number
 3829 190A 3630                    LD       (HL),'0'    ; '0' if zero
 3830 190C CABF19                  JP       Z,JSTZER    ; Return '0' if zero
 3831 190F E5                      PUSH     HL          ; Save buffer address
 3832 1910 FC7F17                  CALL     M,INVSGN    ; Negate FPREG if negat
 3833 1913 AF                      XOR      A           ; Zero A
 3834 1914 F5                      PUSH     AF          ; Save it
 3835 1915 CDC519                  CALL     RNGTST      ; Test number is in ran
 3836 1918 014391       SIXDIG:    LD       BC,9143H    ; BCDE - 99999.9
 3837 191B 11F84F                  LD       DE,4FF8H
 3838 191E CDD117                  CALL     CMPNUM      ; Compare numbers
 3839 1921 B7                      OR       A
 3840 1922 E23619                  JP       PO,INRNG    ; > 99999.9 - Sort it o
 3841 1925 F1                      POP      AF          ; Restore count
 3842 1926 CDB318                  CALL     MULTEN      ; Multiply by ten
 3843 1929 F5                      PUSH     AF          ; Re-save count
 3844 192A C31819                  JP       SIXDIG      ; Test it again
 3845                   ;
 3846 192D CD9E16       GTSIXD:    CALL     DIV10       ; Divide by 10
 3847 1930 F1                      POP      AF          ; Get count
 3848 1931 3C                      INC      A           ; Count divides
 3849 1932 F5                      PUSH     AF          ; Re-save count
 3850 1933 CDC519                  CALL     RNGTST      ; Test number is in ran
 3851 1936 CDFE14       INRNG:     CALL     ROUND       ; Add 0.5 to FPREG
 3852 1939 3C                      INC      A
 3853 193A CDFE17                  CALL     FPINT       ; F.P to integer
 3854 193D CD9717                  CALL     FPBCDE      ; Move BCDE to FPREG
 3855 1940 010603                  LD       BC,0306H    ; 1E+06 to 1E-03 range
 3856 1943 F1                      POP      AF          ; Restore count
 3857 1944 81                      ADD      A,C         ; 6 digits before point
 3858 1945 3C                      INC      A           ; Add one
 3859 1946 FA5219                  JP       M,MAKNUM    ; Do it in 'E' form if 
 3860 1949 FE08                    CP       6+1+1       ; More than 999999 ?
 3861 194B D25219                  JP       NC,MAKNUM   ; Yes - Do it in 'E' fo
 3862 194E 3C                      INC      A           ; Adjust for exponent
 3863 194F 47                      LD       B,A         ; Exponent of number
 3864 1950 3E02                    LD       A,2         ; Make it zero after
 3865                   ;
 3866 1952 3D           MAKNUM:    DEC      A           ; Adjust for digits to 
 3867 1953 3D                      DEC      A
 3868 1954 E1                      POP      HL          ; Restore buffer addres
 3869 1955 F5                      PUSH     AF          ; Save count
 3870 1956 11D819                  LD       DE,POWERS   ; Powers of ten
 3871 1959 05                      DEC      B           ; Count digits before p
 3872 195A C26319                  JP       NZ,DIGTXT   ; Not zero - Do number
 3873 195D 362E                    LD       (HL),'.'    ; Save point
 3874 195F 23                      INC      HL          ; Move on
 3875 1960 3630                    LD       (HL),'0'    ; Save zero
 3876 1962 23                      INC      HL          ; Move on
 3877 1963 05           DIGTXT:    DEC      B           ; Count digits before p
 3878 1964 362E                    LD       (HL),'.'    ; Save point in case
 3879 1966 CCAC17                  CALL     Z,INCHL     ; Last digit - move on
 3880 1969 C5                      PUSH     BC          ; Save digits before po
 3881 196A E5                      PUSH     HL          ; Save buffer address
 3882 196B D5                      PUSH     DE          ; Save powers of ten
 3883 196C CDA217                  CALL     BCDEFP      ; Move FPREG to BCDE
 3884 196F E1                      POP      HL          ; Powers of ten table
 3885 1970 062F                    LD       B, '0'-1    ; ASCII '0' - 1
 3886 1972 04           TRYAGN:    INC      B           ; Count subtractions
 3887 1973 7B                      LD       A,E         ; Get LSB
 3888 1974 96                      SUB      (HL)        ; Subtract LSB
 3889 1975 5F                      LD       E,A         ; Save LSB
 3890 1976 23                      INC      HL
 3891 1977 7A                      LD       A,D         ; Get NMSB
 3892 1978 9E                      SBC      A,(HL)      ; Subtract NMSB
 3893 1979 57                      LD       D,A         ; Save NMSB
 3894 197A 23                      INC      HL
 3895 197B 79                      LD       A,C         ; Get MSB
 3896 197C 9E                      SBC      A,(HL)      ; Subtract MSB
 3897 197D 4F                      LD       C,A         ; Save MSB
 3898 197E 2B                      DEC      HL          ; Point back to start
 3899 197F 2B                      DEC      HL
 3900 1980 D27219                  JP       NC,TRYAGN   ; No overflow - Try aga
 3901 1983 CDB515                  CALL     PLUCDE      ; Restore number
 3902 1986 23                      INC      HL          ; Start of next number
 3903 1987 CD9717                  CALL     FPBCDE      ; Move BCDE to FPREG
 3904 198A EB                      EX       DE,HL       ; Save point in table
 3905 198B E1                      POP      HL          ; Restore buffer addres
 3906 198C 70                      LD       (HL),B      ; Save digit in buffer
 3907 198D 23                      INC      HL          ; And move on
 3908 198E C1                      POP      BC          ; Restore digit count
 3909 198F 0D                      DEC      C           ; Count digits
 3910 1990 C26319                  JP       NZ,DIGTXT   ; More - Do them
 3911 1993 05                      DEC      B           ; Any decimal part?
 3912 1994 CAA319                  JP       Z,DOEBIT    ; No - Do 'E' bit
 3913 1997 2B           SUPTLZ:    DEC      HL          ; Move back through buf
 3914 1998 7E                      LD       A,(HL)      ; Get character
 3915 1999 FE30                    CP       '0'         ; '0' character?
 3916 199B CA9719                  JP       Z,SUPTLZ    ; Yes - Look back for m
 3917 199E FE2E                    CP       '.'         ; A decimal point?
 3918 19A0 C4AC17                  CALL     NZ,INCHL    ; Move back over digit
 3919                   ;
 3920 19A3 F1           DOEBIT:    POP      AF          ; Get 'E' flag
 3921 19A4 CAC219                  JP       Z,NOENED    ; No 'E' needed - End b
 3922 19A7 3645                    LD       (HL),'E'    ; Put 'E' in buffer
 3923 19A9 23                      INC      HL          ; And move on
 3924 19AA 362B                    LD       (HL),'+'    ; Put '+' in buffer
 3925 19AC F2B319                  JP       P,OUTEXP    ; Positive - Output exp
 3926 19AF 362D                    LD       (HL),'-'    ; Put '-' in buffer
 3927 19B1 2F                      CPL                  ; Negate exponent
 3928 19B2 3C                      INC      A
 3929 19B3 062F         OUTEXP:    LD       B,'0'-1     ; ASCII '0' - 1
 3930 19B5 04           EXPTEN:    INC      B           ; Count subtractions
 3931 19B6 D60A                    SUB      10          ; Tens digit
 3932 19B8 D2B519                  JP       NC,EXPTEN   ; More to do
 3933 19BB C63A                    ADD      A,'0'+10    ; Restore and make ASCI
 3934 19BD 23                      INC      HL          ; Move on
 3935 19BE 70                      LD       (HL),B      ; Save MSB of exponent
 3936 19BF 23           JSTZER:    INC      HL          ;
 3937 19C0 77                      LD       (HL),A      ; Save LSB of exponent
 3938 19C1 23                      INC      HL
 3939 19C2 71           NOENED:    LD       (HL),C      ; Mark end of buffer
 3940 19C3 E1                      POP      HL          ; Restore code string a
 3941 19C4 C9                      RET
 3942                   ;
 3943 19C5 017494       RNGTST:    LD       BC,9474H    ; BCDE = 999999.
 3944 19C8 11F723                  LD       DE,23F7H
 3945 19CB CDD117                  CALL     CMPNUM      ; Compare numbers
 3946 19CE B7                      OR       A
 3947 19CF E1                      POP      HL          ; Return address to HL
 3948 19D0 E22D19                  JP       PO,GTSIXD   ; Too big - Divide by t
 3949 19D3 E9                      JP       (HL)        ; Otherwise return to c
 3950                   ;
 3951 19D4 00000080     HALF:      DB       00H,00H,00H,80H ; 0.5
 3952                   ;
 3953 19D8 A08601       POWERS:    DB       0A0H,086H,001H ; 100000
 3954 19DB 102700                  DB       010H,027H,000H ; 10000
 3955 19DE E80300                  DB       0E8H,003H,000H ; 1000
 3956 19E1 640000                  DB       064H,000H,000H ; 100
 3957 19E4 0A0000                  DB       00AH,000H,000H ; 10
 3958 19E7 010000                  DB       001H,000H,000H ; 1
 3959                   ;
 3960 19EA 217F17       NEGAFT:    LD       HL,INVSGN   ; Negate result
 3961 19ED E3                      EX       (SP),HL     ; To be done after call
 3962 19EE E9                      JP       (HL)        ; Return to caller
 3963                   ;
 3964 19EF CD8717       SQR:       CALL     STAKFP      ; Put value on stack
 3965 19F2 21D419                  LD       HL,HALF     ; Set power to 1/2
 3966 19F5 CD9417                  CALL     PHLTFP      ; Move 1/2 to FPREG
 3967                   ;
 3968 19F8 C1           POWER:     POP      BC          ; Get base
 3969 19F9 D1                      POP      DE
 3970 19FA CD5617                  CALL     TSTSGN      ; Test sign of power
 3971 19FD 78                      LD       A,B         ; Get exponent of base
 3972 19FE CA3D1A                  JP       Z,EXP       ; Make result 1 if zero
 3973 1A01 F2081A                  JP       P,POWER1    ; Positive base - Ok
 3974 1A04 B7                      OR       A           ; Zero to negative powe
 3975 1A05 CAA104                  JP       Z,DZERR     ; Yes - ?/0 Error
 3976 1A08 B7           POWER1:    OR       A           ; Base zero?
 3977 1A09 CA7715                  JP       Z,SAVEXP    ; Yes - Return zero
 3978 1A0C D5                      PUSH     DE          ; Save base
 3979 1A0D C5                      PUSH     BC
 3980 1A0E 79                      LD       A,C         ; Get MSB of base
 3981 1A0F F67F                    OR       01111111B   ; Get sign status
 3982 1A11 CDA217                  CALL     BCDEFP      ; Move power to BCDE
 3983 1A14 F2251A                  JP       P,POWER2    ; Positive base - Ok
 3984 1A17 D5                      PUSH     DE          ; Save power
 3985 1A18 C5                      PUSH     BC
 3986 1A19 CD2918                  CALL     INT         ; Get integer of power
 3987 1A1C C1                      POP      BC          ; Restore power
 3988 1A1D D1                      POP      DE
 3989 1A1E F5                      PUSH     AF          ; MSB of base
 3990 1A1F CDD117                  CALL     CMPNUM      ; Power an integer?
 3991 1A22 E1                      POP      HL          ; Restore MSB of base
 3992 1A23 7C                      LD       A,H         ; but don't affect flag
 3993 1A24 1F                      RRA                  ; Exponent odd or even?
 3994 1A25 E1           POWER2:    POP      HL          ; Restore MSB and expon
 3995 1A26 222B81                  LD       (FPREG+2),HL ; Save base in FPREG
 3996 1A29 E1                      POP      HL          ; LSBs of base
 3997 1A2A 222981                  LD       (FPREG),HL  ; Save in FPREG
 3998 1A2D DCEA19                  CALL     C,NEGAFT    ; Odd power - Negate re
 3999 1A30 CC7F17                  CALL     Z,INVSGN    ; Negative base - Negat
 4000 1A33 D5                      PUSH     DE          ; Save power
 4001 1A34 C5                      PUSH     BC
 4002 1A35 CD0A16                  CALL     LOG         ; Get LOG of base
 4003 1A38 C1                      POP      BC          ; Restore power
 4004 1A39 D1                      POP      DE
 4005 1A3A CD4B16                  CALL     FPMULT      ; Multiply LOG by power
 4006                   ;
 4007 1A3D CD8717       EXP:       CALL     STAKFP      ; Put value on stack
 4008 1A40 013881                  LD       BC,08138H   ; BCDE = 1/Ln(2)
 4009 1A43 113BAA                  LD       DE,0AA3BH
 4010 1A46 CD4B16                  CALL     FPMULT      ; Multiply value by 1/L
 4011 1A49 3A2C81                  LD       A,(FPEXP)   ; Get exponent
 4012 1A4C FE88                    CP       80H+8       ; Is it in range?
 4013 1A4E D23217                  JP       NC,OVTST1   ; No - Test for overflo
 4014 1A51 CD2918                  CALL     INT         ; Get INT of FPREG
 4015 1A54 C680                    ADD      A,80H       ; For excess 128
 4016 1A56 C602                    ADD      A,2         ; Exponent > 126?
 4017 1A58 DA3217                  JP       C,OVTST1    ; Yes - Test for overfl
 4018 1A5B F5                      PUSH     AF          ; Save scaling factor
 4019 1A5C 21F915                  LD       HL,UNITY    ; Point to 1.
 4020 1A5F CD0115                  CALL     ADDPHL      ; Add 1 to FPREG
 4021 1A62 CD4216                  CALL     MULLN2      ; Multiply by LN(2)
 4022 1A65 F1                      POP      AF          ; Restore scaling facto
 4023 1A66 C1                      POP      BC          ; Restore exponent
 4024 1A67 D1                      POP      DE
 4025 1A68 F5                      PUSH     AF          ; Save scaling factor
 4026 1A69 CD0D15                  CALL     SUBCDE      ; Subtract exponent fro
 4027 1A6C CD7F17                  CALL     INVSGN      ; Negate result
 4028 1A6F 217D1A                  LD       HL,EXPTAB   ; Coefficient table
 4029 1A72 CDAD1A                  CALL     SMSER1      ; Sum the series
 4030 1A75 110000                  LD       DE,0        ; Zero LSBs
 4031 1A78 C1                      POP      BC          ; Scaling factor
 4032 1A79 4A                      LD       C,D         ; Zero MSB
 4033 1A7A C34B16                  JP       FPMULT      ; Scale result to corre
 4034                   ;
 4035 1A7D 08           EXPTAB:    DB       8           ; Table used by EXP
 4036 1A7E 402E9474                DB       040H,02EH,094H,074H ; -1/7! (-1/504
 4037 1A82 704F2E77                DB       070H,04FH,02EH,077H ;  1/6! ( 1/720
 4038 1A86 6E02887A                DB       06EH,002H,088H,07AH ; -1/5! (-1/120
 4039 1A8A E6A02A7C                DB       0E6H,0A0H,02AH,07CH ;  1/4! ( 1/24)
 4040 1A8E 50AAAA7E                DB       050H,0AAH,0AAH,07EH ; -1/3! (-1/6)
 4041 1A92 FFFF7F7F                DB       0FFH,0FFH,07FH,07FH ;  1/2! ( 1/2)
 4042 1A96 00008081                DB       000H,000H,080H,081H ; -1/1! (-1/1)
 4043 1A9A 00000081                DB       000H,000H,000H,081H ;  1/0! ( 1/1)
 4044                   ;
 4045 1A9E CD8717       SUMSER:    CALL     STAKFP      ; Put FPREG on stack
 4046 1AA1 114916                  LD       DE,MULT     ; Multiply by "X"
 4047 1AA4 D5                      PUSH     DE          ; To be done after
 4048 1AA5 E5                      PUSH     HL          ; Save address of table
 4049 1AA6 CDA217                  CALL     BCDEFP      ; Move FPREG to BCDE
 4050 1AA9 CD4B16                  CALL     FPMULT      ; Square the value
 4051 1AAC E1                      POP      HL          ; Restore address of ta
 4052 1AAD CD8717       SMSER1:    CALL     STAKFP      ; Put value on stack
 4053 1AB0 7E                      LD       A,(HL)      ; Get number of coeffic
 4054 1AB1 23                      INC      HL          ; Point to start of tab
 4055 1AB2 CD9417                  CALL     PHLTFP      ; Move coefficient to F
 4056 1AB5 06                      DB       06H         ; Skip "POP AF"
 4057 1AB6 F1           SUMLP:     POP      AF          ; Restore count
 4058 1AB7 C1                      POP      BC          ; Restore number
 4059 1AB8 D1                      POP      DE
 4060 1AB9 3D                      DEC      A           ; Cont coefficients
 4061 1ABA C8                      RET      Z           ; All done
 4062 1ABB D5                      PUSH     DE          ; Save number
 4063 1ABC C5                      PUSH     BC
 4064 1ABD F5                      PUSH     AF          ; Save count
 4065 1ABE E5                      PUSH     HL          ; Save address in table
 4066 1ABF CD4B16                  CALL     FPMULT      ; Multiply FPREG by BCD
 4067 1AC2 E1                      POP      HL          ; Restore address in ta
 4068 1AC3 CDA517                  CALL     LOADFP      ; Number at HL to BCDE
 4069 1AC6 E5                      PUSH     HL          ; Save address in table
 4070 1AC7 CD1015                  CALL     FPADD       ; Add coefficient to FP
 4071 1ACA E1                      POP      HL          ; Restore address in ta
 4072 1ACB C3B61A                  JP       SUMLP       ; More coefficients
 4073                   ;
 4074 1ACE CD5617       RND:       CALL     TSTSGN      ; Test sign of FPREG
 4075 1AD1 215E80                  LD       HL,SEED+2   ; Random number seed
 4076 1AD4 FA2F1B                  JP       M,RESEED    ; Negative - Re-seed
 4077 1AD7 217F80                  LD       HL,LSTRND   ; Last random number
 4078 1ADA CD9417                  CALL     PHLTFP      ; Move last RND to FPRE
 4079 1ADD 215E80                  LD       HL,SEED+2   ; Random number seed
 4080 1AE0 C8                      RET      Z           ; Return if RND(0)
 4081 1AE1 86                      ADD      A,(HL)      ; Add (SEED)+2)
 4082 1AE2 E607                    AND      00000111B   ; 0 to 7
 4083 1AE4 0600                    LD       B,0
 4084 1AE6 77                      LD       (HL),A      ; Re-save seed
 4085 1AE7 23                      INC      HL          ; Move to coefficient t
 4086 1AE8 87                      ADD      A,A         ; 4 bytes
 4087 1AE9 87                      ADD      A,A         ; per entry
 4088 1AEA 4F                      LD       C,A         ; BC = Offset into tabl
 4089 1AEB 09                      ADD      HL,BC       ; Point to coefficient
 4090 1AEC CDA517                  CALL     LOADFP      ; Coefficient to BCDE
 4091 1AEF CD4B16                  CALL     FPMULT      ;       ; Multiply FPRE
 4092 1AF2 3A5D80                  LD       A,(SEED+1)  ; Get (SEED+1)
 4093 1AF5 3C                      INC      A           ; Add 1
 4094 1AF6 E603                    AND      00000011B   ; 0 to 3
 4095 1AF8 0600                    LD       B,0
 4096 1AFA FE01                    CP       1           ; Is it zero?
 4097 1AFC 88                      ADC      A,B         ; Yes - Make it 1
 4098 1AFD 325D80                  LD       (SEED+1),A  ; Re-save seed
 4099 1B00 21331B                  LD       HL,RNDTAB-4 ; Addition table
 4100 1B03 87                      ADD      A,A         ; 4 bytes
 4101 1B04 87                      ADD      A,A         ; per entry
 4102 1B05 4F                      LD       C,A         ; BC = Offset into tabl
 4103 1B06 09                      ADD      HL,BC       ; Point to value
 4104 1B07 CD0115                  CALL     ADDPHL      ; Add value to FPREG
 4105 1B0A CDA217       RND1:      CALL     BCDEFP      ; Move FPREG to BCDE
 4106 1B0D 7B                      LD       A,E         ; Get LSB
 4107 1B0E 59                      LD       E,C         ; LSB = MSB
 4108 1B0F EE4F                    XOR      01001111B   ; Fiddle around
 4109 1B11 4F                      LD       C,A         ; New MSB
 4110 1B12 3680                    LD       (HL),80H    ; Set exponent
 4111 1B14 2B                      DEC      HL          ; Point to MSB
 4112 1B15 46                      LD       B,(HL)      ; Get MSB
 4113 1B16 3680                    LD       (HL),80H    ; Make value -0.5
 4114 1B18 215C80                  LD       HL,SEED     ; Random number seed
 4115 1B1B 34                      INC      (HL)        ; Count seed
 4116 1B1C 7E                      LD       A,(HL)      ; Get seed
 4117 1B1D D6AB                    SUB      171         ; Do it modulo 171
 4118 1B1F C2261B                  JP       NZ,RND2     ; Non-zero - Ok
 4119 1B22 77                      LD       (HL),A      ; Zero seed
 4120 1B23 0C                      INC      C           ; Fillde about
 4121 1B24 15                      DEC      D           ; with the
 4122 1B25 1C                      INC      E           ; number
 4123 1B26 CD6115       RND2:      CALL     BNORM       ; Normalise number
 4124 1B29 217F80                  LD       HL,LSTRND   ; Save random number
 4125 1B2C C3AE17                  JP       FPTHL       ; Move FPREG to last an
 4126                   ;
 4127 1B2F 77           RESEED:    LD       (HL),A      ; Re-seed random number
 4128 1B30 2B                      DEC      HL
 4129 1B31 77                      LD       (HL),A
 4130 1B32 2B                      DEC      HL
 4131 1B33 77                      LD       (HL),A
 4132 1B34 C30A1B                  JP       RND1        ; Return RND seed
 4133                   ;
 4134 1B37 68B14668     RNDTAB:    DB       068H,0B1H,046H,068H ; Table used by
 4135 1B3B 99E99269                DB       099H,0E9H,092H,069H
 4136 1B3F 10D17568                DB       010H,0D1H,075H,068H
 4137                   ;
 4138 1B43 218D1B       COS:       LD       HL,HALFPI   ; Point to PI/2
 4139 1B46 CD0115                  CALL     ADDPHL      ; Add it to PPREG
 4140 1B49 CD8717       SIN:       CALL     STAKFP      ; Put angle on stack
 4141 1B4C 014983                  LD       BC,8349H    ; BCDE = 2 PI
 4142 1B4F 11DB0F                  LD       DE,0FDBH
 4143 1B52 CD9717                  CALL     FPBCDE      ; Move 2 PI to FPREG
 4144 1B55 C1                      POP      BC          ; Restore angle
 4145 1B56 D1                      POP      DE
 4146 1B57 CDAC16                  CALL     DVBCDE      ; Divide angle by 2 PI
 4147 1B5A CD8717                  CALL     STAKFP      ; Put it on stack
 4148 1B5D CD2918                  CALL     INT         ; Get INT of result
 4149 1B60 C1                      POP      BC          ; Restore number
 4150 1B61 D1                      POP      DE
 4151 1B62 CD0D15                  CALL     SUBCDE      ; Make it 0 <= value < 
 4152 1B65 21911B                  LD       HL,QUARTR   ; Point to 0.25
 4153 1B68 CD0715                  CALL     SUBPHL      ; Subtract value from 0
 4154 1B6B CD5617                  CALL     TSTSGN      ; Test sign of value
 4155 1B6E 37                      SCF                  ; Flag positive
 4156 1B6F F2791B                  JP       P,SIN1      ; Positive - Ok
 4157 1B72 CDFE14                  CALL     ROUND       ; Add 0.5 to value
 4158 1B75 CD5617                  CALL     TSTSGN      ; Test sign of value
 4159 1B78 B7                      OR       A           ; Flag negative
 4160 1B79 F5           SIN1:      PUSH     AF          ; Save sign
 4161 1B7A F47F17                  CALL     P,INVSGN    ; Negate value if posit
 4162 1B7D 21911B                  LD       HL,QUARTR   ; Point to 0.25
 4163 1B80 CD0115                  CALL     ADDPHL      ; Add 0.25 to value
 4164 1B83 F1                      POP      AF          ; Restore sign
 4165 1B84 D47F17                  CALL     NC,INVSGN   ; Negative - Make posit
 4166 1B87 21951B                  LD       HL,SINTAB   ; Coefficient table
 4167 1B8A C39E1A                  JP       SUMSER      ; Evaluate sum of serie
 4168                   ;
 4169 1B8D DB0F4981     HALFPI:    DB       0DBH,00FH,049H,081H ; 1.5708 (PI/2)
 4170                   ;
 4171 1B91 0000007F     QUARTR:    DB       000H,000H,000H,07FH ; 0.25
 4172                   ;
 4173 1B95 05           SINTAB:    DB       5           ; Table used by SIN
 4174 1B96 BAD71E86                DB       0BAH,0D7H,01EH,086H ; 39.711
 4175 1B9A 64269987                DB       064H,026H,099H,087H ;-76.575
 4176 1B9E 58342387                DB       058H,034H,023H,087H ; 81.602
 4177 1BA2 E05DA586                DB       0E0H,05DH,0A5H,086H ;-41.342
 4178 1BA6 DA0F4983                DB       0DAH,00FH,049H,083H ; 6.2832
 4179                   ;
 4180 1BAA CD8717       TAN:       CALL     STAKFP      ; Put angle on stack
 4181 1BAD CD491B                  CALL     SIN         ; Get SIN of angle
 4182 1BB0 C1                      POP      BC          ; Restore angle
 4183 1BB1 E1                      POP      HL
 4184 1BB2 CD8717                  CALL     STAKFP      ; Save SIN of angle
 4185 1BB5 EB                      EX       DE,HL       ; BCDE = Angle
 4186 1BB6 CD9717                  CALL     FPBCDE      ; Angle to FPREG
 4187 1BB9 CD431B                  CALL     COS         ; Get COS of angle
 4188 1BBC C3AA16                  JP       DIV         ; TAN = SIN / COS
 4189                   ;
 4190 1BBF CD5617       ATN:       CALL     TSTSGN      ; Test sign of value
 4191 1BC2 FCEA19                  CALL     M,NEGAFT    ; Negate result after i
 4192 1BC5 FC7F17                  CALL     M,INVSGN    ; Negate value if -ve
 4193 1BC8 3A2C81                  LD       A,(FPEXP)   ; Get exponent
 4194 1BCB FE81                    CP       81H         ; Number less than 1?
 4195 1BCD DADC1B                  JP       C,ATN1      ; Yes - Get arc tangnt
 4196 1BD0 010081                  LD       BC,8100H    ; BCDE = 1
 4197 1BD3 51                      LD       D,C
 4198 1BD4 59                      LD       E,C
 4199 1BD5 CDAC16                  CALL     DVBCDE      ; Get reciprocal of num
 4200 1BD8 210715                  LD       HL,SUBPHL   ; Sub angle from PI/2
 4201 1BDB E5                      PUSH     HL          ; Save for angle > 1
 4202 1BDC 21E61B       ATN1:      LD       HL,ATNTAB   ; Coefficient table
 4203 1BDF CD9E1A                  CALL     SUMSER      ; Evaluate sum of serie
 4204 1BE2 218D1B                  LD       HL,HALFPI   ; PI/2 - angle in case 
 4205 1BE5 C9                      RET                  ; Number > 1 - Sub from
 4206                   ;
 4207 1BE6 09           ATNTAB:    DB       9           ; Table used by ATN
 4208 1BE7 4AD73B78                DB       04AH,0D7H,03BH,078H ; 1/17
 4209 1BEB 026E847B                DB       002H,06EH,084H,07BH ;-1/15
 4210 1BEF FEC12F7C                DB       0FEH,0C1H,02FH,07CH ; 1/13
 4211 1BF3 74319A7D                DB       074H,031H,09AH,07DH ;-1/11
 4212 1BF7 843D5A7D                DB       084H,03DH,05AH,07DH ; 1/9
 4213 1BFB C87F917E                DB       0C8H,07FH,091H,07EH ;-1/7
 4214 1BFF E4BB4C7E                DB       0E4H,0BBH,04CH,07EH ; 1/5
 4215 1C03 6CAAAA7F                DB       06CH,0AAH,0AAH,07FH ;-1/3
 4216 1C07 00000081                DB       000H,000H,000H,081H ; 1/1
 4217                   ;
 4218                   
 4219 1C0B C9           ARET:      RET                  ; A RETurn instruction
 4220                   ;
 4221 1C0C              CLS:
 4222 1C0C 3E0C                    LD       A,CS        ; ASCII Clear screen
 4223 1C0E C3A700                  JP       TXA         ; Output character
 4224                   ;
 4225 1C11 CDD514       WIDTH:     CALL     GETINT      ; Get integer 0-255
 4226 1C14 7B                      LD       A,E         ; Width to A
 4227 1C15 328780                  LD       (LWIDTH),A  ; Set width
 4228 1C18 C9                      RET
 4229                   ;
 4230 1C19 CD710D       LINES:     CALL     GETNUM      ; Get a number
 4231 1C1C CDB609                  CALL     DEINT       ; Get integer -32768 to
 4232                   ;       LD      (LINESC),DE     ; Set lines counter
 4233                   ;       LD      (LINESN),DE     ; Set lines number
 4234 1C1F E5                      PUSH     HL          ; REPLACE Z80 CODE
 4235 1C20 D5                      PUSH     DE          ; REPLACE Z80 CODE
 4236 1C21 E1                      POP      HL          ; REPLACE Z80 CODE
 4237 1C22 228B80                  LD       (LINESC),HL ; REPLACE Z80 CODE
 4238 1C25 228D80                  LD       (LINESN),HL ; REPLACE Z80 CODE
 4239 1C28 E1                      POP      HL          ; REPLACE Z80 CODE
 4240 1C29 C9                      RET
 4241                   ;
 4242 1C2A CDB609       DEEK:      CALL     DEINT       ; Get integer -32768 to
 4243 1C2D D5                      PUSH     DE          ; Save number
 4244 1C2E E1                      POP      HL          ; Number to HL
 4245 1C2F 46                      LD       B,(HL)      ; Get LSB of contents
 4246 1C30 23                      INC      HL
 4247 1C31 7E                      LD       A,(HL)      ; Get MSB of contents
 4248 1C32 C32D11                  JP       ABPASS      ; Return integer AB
 4249                   ;
 4250 1C35 CD710D       DOKE:      CALL     GETNUM      ; Get a number
 4251 1C38 CDB609                  CALL     DEINT       ; Get integer -32768 to
 4252 1C3B D5                      PUSH     DE          ; Save address
 4253 1C3C CD6C07                  CALL     CHKSYN      ; Make sure ',' follows
 4254 1C3F 2C                      DB       ','
 4255 1C40 CD710D                  CALL     GETNUM      ; Get a number
 4256 1C43 CDB609                  CALL     DEINT       ; Get integer -32768 to
 4257 1C46 E3                      EX       (SP),HL     ; Save value,get addres
 4258 1C47 73                      LD       (HL),E      ; Save LSB of value
 4259 1C48 23                      INC      HL
 4260 1C49 72                      LD       (HL),D      ; Save MSB of value
 4261 1C4A E1                      POP      HL          ; Restore code string a
 4262 1C4B C9                      RET
 4263                   ;
 4264                   ; HEX$(nn) Convert 16 bit number to Hexadecimal string
 4265                   ;
 4266 1C4C CD740D       HEX:       CALL     TSTNUM      ; Verify it's a number
 4267 1C4F CDB609                  CALL     DEINT       ; Get integer -32768 to
 4268 1C52 C5                      PUSH     BC          ; Save contents of BC
 4269 1C53 212E81                  LD       HL,PBUFF
 4270 1C56 7A                      LD       A,D         ; Get high order into A
 4271 1C57 FE00                    CP       0
 4272 1C59 CA691C                  JP       Z,HEX2      ; Skip output if both h
 4273 1C5C CD881C                  CALL     BYT2ASC     ; Convert D to ASCII
 4274 1C5F 78                      LD       A,B
 4275 1C60 FE30                    CP       '0'
 4276 1C62 CA671C                  JP       Z,HEX1      ; Don't store high digi
 4277 1C65 70                      LD       (HL),B      ; Store it to PBUFF
 4278 1C66 23                      INC      HL          ; Next location
 4279 1C67 71           HEX1:      LD       (HL),C      ; Store C to PBUFF+1
 4280 1C68 23                      INC      HL          ; Next location
 4281 1C69 7B           HEX2:      LD       A,E         ; Get lower byte
 4282 1C6A CD881C                  CALL     BYT2ASC     ; Convert E to ASCII
 4283 1C6D 7A                      LD       A,D
 4284 1C6E FE00                    CP       0
 4285 1C70 C2791C                  JP       NZ,HEX3     ; If upper byte was not
 4286 1C73 78                      LD       A,B
 4287 1C74 FE30                    CP       '0'         ; If high digit of lowe
 4288 1C76 CA7B1C                  JP       Z,HEX4
 4289 1C79 70           HEX3:      LD       (HL),B      ; to PBUFF+2
 4290 1C7A 23                      INC      HL          ; Next location
 4291 1C7B 71           HEX4:      LD       (HL),C      ; to PBUFF+3
 4292 1C7C 23                      INC      HL          ; PBUFF+4 to zero
 4293 1C7D AF                      XOR      A           ; Terminating character
 4294 1C7E 77                      LD       (HL),A      ; Store zero to termina
 4295 1C7F 23                      INC      HL          ; Make sure PBUFF is te
 4296 1C80 77                      LD       (HL),A      ; Store the double zero
 4297 1C81 C1                      POP      BC          ; Get BC back
 4298 1C82 212E81                  LD       HL,PBUFF    ; Reset to start of PBU
 4299 1C85 C3DB11                  JP       STR1        ; Convert the PBUFF to 
 4300                   ;
 4301 1C88 47           BYT2ASC    LD       B,A         ; Save original value
 4302 1C89 E60F                    AND      0FH         ; Strip off upper nybbl
 4303 1C8B FE0A                    CP       0AH         ; 0-9?
 4304 1C8D DA921C                  JP       C,ADD30     ; If A-F, add 7 more
 4305 1C90 C607                    ADD      A,07H       ; Bring value up to ASC
 4306 1C92 C630         ADD30      ADD      A,30H       ; And make ASCII
 4307 1C94 4F                      LD       C,A         ; Save converted char t
 4308 1C95 78                      LD       A,B         ; Retrieve original val
 4309 1C96 0F                      RRCA                 ; and Rotate it right
 4310 1C97 0F                      RRCA
 4311 1C98 0F                      RRCA
 4312 1C99 0F                      RRCA
 4313 1C9A E60F                    AND      0FH         ; Mask off upper nybble
 4314 1C9C FE0A                    CP       0AH         ; 0-9? < A hex?
 4315 1C9E DAA31C                  JP       C,ADD301    ; Skip Add 7
 4316 1CA1 C607                    ADD      A,07H       ; Bring it up to ASCII 
 4317 1CA3 C630         ADD301     ADD      A,30H       ; And make it full ASCI
 4318 1CA5 47                      LD       B,A         ; Store high order byte
 4319 1CA6 C9                      RET
 4320                   ;
 4321                   ; Convert "&Hnnnn" to FPREG
 4322                   ; Gets a character from (HL) checks for Hexadecimal ASC
 4323                   ; Char is in A, NC if char is;<=>?@ A-z, CY is set if 0
 4324 1CA7 EB           HEXTFP     EX       DE,HL       ; Move code string poin
 4325 1CA8 210000                  LD       HL,0000H    ; Zero out the value
 4326 1CAB CDC31C                  CALL     GETHEX      ; Check the number for 
 4327 1CAE DAE41C                  JP       C,HXERR     ; First value wasn't he
 4328 1CB1 C3BA1C                  JP       HEXLP1      ; Convert first charact
 4329 1CB4 CDC31C       HEXLP      CALL     GETHEX      ; Get second and addtio
 4330 1CB7 DADB1C                  JP       C,HEXIT     ; Exit if not a hex cha
 4331 1CBA 29           HEXLP1     ADD      HL,HL       ; Rotate 4 bits to the 
 4332 1CBB 29                      ADD      HL,HL
 4333 1CBC 29                      ADD      HL,HL
 4334 1CBD 29                      ADD      HL,HL
 4335 1CBE B5                      OR       L           ; Add in D0-D3 into L
 4336 1CBF 6F                      LD       L,A         ; Save new value
 4337 1CC0 C3B41C                  JP       HEXLP       ; And continue until al
 4338                   ;
 4339 1CC3 13           GETHEX     INC      DE          ; Next location
 4340 1CC4 1A                      LD       A,(DE)      ; Load character at poi
 4341 1CC5 FE20                    CP       ' '
 4342 1CC7 CAC31C                  JP       Z,GETHEX    ; Skip spaces
 4343 1CCA D630                    SUB      30H         ; Get absolute value
 4344 1CCC D8                      RET      C           ; < "0", error
 4345 1CCD FE0A                    CP       0AH
 4346 1CCF DAD71C                  JP       C,NOSUB7    ; Is already in the ran
 4347 1CD2 D607                    SUB      07H         ; Reduce to A-F
 4348 1CD4 FE0A                    CP       0AH         ; Value should be $0A-$
 4349 1CD6 D8                      RET      C           ; CY set if was :      
 4350 1CD7 FE10         NOSUB7     CP       10H         ; > Greater than "F"?
 4351 1CD9 3F                      CCF
 4352 1CDA C9                      RET                  ; CY set if it wasn't v
 4353                   
 4354 1CDB EB           HEXIT      EX       DE,HL       ; Value into DE, Code s
 4355 1CDC 7A                      LD       A,D         ; Load DE into AC
 4356 1CDD 4B                      LD       C,E         ; For prep to
 4357 1CDE E5                      PUSH     HL
 4358 1CDF CD2C11                  CALL     ACPASS      ; ACPASS to set AC as i
 4359 1CE2 E1                      POP      HL
 4360 1CE3 C9                      RET
 4361                   ;
 4362 1CE4 1E26         HXERR:     LD       E,HX        ; ?HEX Error
 4363 1CE6 C3B204                  JP       ERROR
 4364                   ;
 4365                   ; BIN$(NN) Convert integer to a 1-16 char binary string
 4366 1CE9 CD740D       BIN:       CALL     TSTNUM      ; Verify it's a number
 4367 1CEC CDB609                  CALL     DEINT       ; Get integer -32768 to
 4368 1CEF C5           BIN2:      PUSH     BC          ; Save contents of BC
 4369 1CF0 212E81                  LD       HL,PBUFF
 4370 1CF3 0611                    LD       B,17        ; One higher than max c
 4371 1CF5              ZEROSUP:                        ; Suppress leading zero
 4372 1CF5 05                      DEC      B           ; Max 16 chars
 4373 1CF6 78                      LD       A,B
 4374 1CF7 FE01                    CP       01H
 4375 1CF9 CA081D                  JP       Z,BITOUT    ; Always output at leas
 4376                   ;       RL      E
 4377                   ;       RL      D
 4378 1CFC 7B                      LD       A,E         ; REPLACE Z80 CODE
 4379 1CFD 17                      RLA                  ; REPLACE Z80 CODE
 4380 1CFE 5F                      LD       E,A         ; REPLACE Z80 CODE
 4381 1CFF 7A                      LD       A,D         ; REPLACE Z80 CODE
 4382 1D00 17                      RLA                  ; REPLACE Z80 CODE
 4383 1D01 57                      LD       D,A         ; REPLACE Z80 CODE
 4384 1D02 D2F51C                  JP       NC,ZEROSUP
 4385 1D05 C30E1D                  JP       BITOUT2
 4386 1D08              BITOUT:
 4387                   ;       RL      E
 4388                   ;       RL      D               ; Top bit now in carry
 4389 1D08 7B                      LD       A,E         ; REPLACE Z80 CODE
 4390 1D09 17                      RLA                  ; REPLACE Z80 CODE
 4391 1D0A 5F                      LD       E,A         ; REPLACE Z80 CODE
 4392 1D0B 7A                      LD       A,D         ; REPLACE Z80 CODE
 4393 1D0C 17                      RLA                  ; REPLACE Z80 CODE
 4394 1D0D 57                      LD       D,A         ; REPLACE Z80 CODE
 4395 1D0E              BITOUT2:
 4396 1D0E 3E30                    LD       A,'0'       ; Char for '0'
 4397 1D10 CE00                    ADC      A,0         ; If carry set then '0'
 4398 1D12 77                      LD       (HL),A
 4399 1D13 23                      INC      HL
 4400 1D14 05                      DEC      B
 4401 1D15 C2081D                  JP       NZ,BITOUT
 4402 1D18 AF                      XOR      A           ; Terminating character
 4403 1D19 77                      LD       (HL),A      ; Store zero to termina
 4404 1D1A 23                      INC      HL          ; Make sure PBUFF is te
 4405 1D1B 77                      LD       (HL),A      ; Store the double zero
 4406 1D1C C1                      POP      BC
 4407 1D1D 212E81                  LD       HL,PBUFF
 4408 1D20 C3DB11                  JP       STR1
 4409                   ;
 4410                   ; Convert "&Bnnnn" to FPREG
 4411                   ; Gets a character from (HL) checks for Binary ASCII nu
 4412 1D23 EB           BINTFP:    EX       DE,HL       ; Move code string poin
 4413 1D24 210000                  LD       HL,0000H    ; Zero out the value
 4414 1D27 CD411D                  CALL     CHKBIN      ; Check the number for 
 4415 1D2A DA4F1D                  JP       C,BINERR    ; First value wasn't bi
 4416 1D2D D630         BINIT:     SUB      '0'
 4417 1D2F 29                      ADD      HL,HL       ; Rotate HL left
 4418 1D30 B5                      OR       L
 4419 1D31 6F                      LD       L,A
 4420 1D32 CD411D                  CALL     CHKBIN      ; Get second and addtio
 4421 1D35 D22D1D                  JP       NC,BINIT    ; Process if a bin char
 4422 1D38 EB                      EX       DE,HL       ; Value into DE, Code s
 4423 1D39 7A                      LD       A,D         ; Load DE into AC
 4424 1D3A 4B                      LD       C,E         ; For prep to
 4425 1D3B E5                      PUSH     HL
 4426 1D3C CD2C11                  CALL     ACPASS      ; ACPASS to set AC as i
 4427 1D3F E1                      POP      HL
 4428 1D40 C9                      RET
 4429                   ;
 4430                   ; Char is in A, NC if char is 0 or 1
 4431 1D41 13           CHKBIN:    INC      DE
 4432 1D42 1A                      LD       A,(DE)
 4433 1D43 FE20                    CP       ' '
 4434 1D45 CA411D                  JP       Z,CHKBIN    ; Skip spaces
 4435 1D48 FE30                    CP       '0'         ; Set C if < '0'
 4436 1D4A D8                      RET      C
 4437 1D4B FE32                    CP       '2'
 4438 1D4D 3F                      CCF                  ; Set C if > '1'
 4439 1D4E C9                      RET
 4440                   ;
 4441 1D4F 1E28         BINERR:    LD       E,BN        ; ?BIN Error
 4442 1D51 C3B204                  JP       ERROR
 4443                   ;
 4444 1D54 C3F100       JJUMP1:    JP       CSTART      ; Go and initialise
 4445                   ;
 4446 1D57 C30000       MONITR:    JP       0000H       ; Restart (Normally Mon
 4447                   ;
 4448 1D5A 3E00         INITST:    LD       A,0         ; Clear break flag
 4449 1D5C 329280                  LD       (BRKFLG),A
 4450 1D5F C3F800                  JP       INIT
 4451                   ;
 4452 1D62 F5           TSTBIT:    PUSH     AF          ; Save bit mask
 4453 1D63 A0                      AND      B           ; Get common bits
 4454 1D64 C1                      POP      BC          ; Restore bit mask
 4455 1D65 B8                      CP       B           ; Same bit set?
 4456 1D66 3E00                    LD       A,0         ; Return 0 in A
 4457 1D68 C9                      RET
 4458                   ;
 4459 1D69 CD7707       OUTNCR:    CALL     OUTC        ; Output character in A
 4460 1D6C C3AC0B                  JP       PRCRLF      ; Output CRLF
 4461                   ;
 4462 1D6F                         END
